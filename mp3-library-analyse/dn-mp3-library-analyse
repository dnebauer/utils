#!/usr/bin/perl

use Moo;    # {{{1
use strictures 2;
use 5.006;
use 5.022001;
use version; our $VERSION = qv('0.1');
use namespace::clean;    # }}}1
use utf8;

{

    package Dn::Mp3LibraryAnalyse;

    use Moo;             # {{{1
    use strictures 2;
    use namespace::clean;
    use Carp qw(croak);
    use Const::Fast;
    use Cwd;
    use Encode;
    use English qw(-no_match_vars);
    use Env qw(HOME);
    use File::Find::Rule;
    use File::Spec;
    use Function::Parameters;
    use IPC::Cmd;
    use IPC::Run;    # required by IPC::Cmd
    use Log::Log4perl qw(get_logger);
    use MooX::Options protect_argv => 0;
    use Path::Iterator::Rule;
    use Types::Standard;

    with qw(Role::Utils::Dn);

    const my $TRUE     => 1;
    const my $FALSE    => 0;
    const my @ANALYSES => qw(missing_key_tags);
    const my $DEFAULT_LOG =>
        File::Spec->catfile( $HOME, 'tmp', 'dn-mp3-library-analyse.log' );
    const my $MAX_DEPTH           => 100;
    const my $PREORDER_DEPTHFIRST => -1;    # }}}1

    # options

    # analysis (-a)    {{{1
    option 'analysis' => (
        is      => 'ro',
        format  => 's@',
        default => sub { [] },
        short   => 'a',
        doc     => q{Analysis ('missing_key_tags')},
    );

    # log_file  (-f)    {{{1
    option 'log_file' => (
        is      => 'ro',
        format  => 's@',
        default => sub { [] },
        short   => 'f',
        doc     => 'Path to log file',
    );

    # use_logger (-l)    {{{1
    option 'use_logger' => (
        is    => 'ro',
        short => 'l',
        doc =>
            'Log feedback (default file: ~/tmp/dn-mp3-library-analyse.log)',
    );    # }}}1

    # attributes

    # _analysis    {{{1
    has '_analysis' => (
        is  => 'lazy',
        isa => Types::Standard::Maybe [Types::Standard::Str],
        doc => 'Analysis to perform',
    );

    method _build__analysis () {
        my @analysis = @{ $self->analysis };
        if ( not @analysis ) { die "No analysis specified\n"; }
        my $analysis       = $analysis[0];
        my %valid_analysis = map { $_ => 1 } @ANALYSES;
        if ( exists $valid_analysis{$analysis} ) { return $analysis; }
        die "Invalid analysis: $analysis\n";
    }

    # _log_file    {{{1
    has '_log_file' => (
        is  => 'lazy',
        isa => Types::Standard::Str,
        doc => 'Log filepath to use in script',
    );

    method _build__log_file () {
        my @log_files = @{ $self->log_file };
        return (@log_files) ? $log_files[0] : $DEFAULT_LOG;
    }    # }}}1

    # methods

    # make_utf8($string)    {{{1
    #
    # does:   encode as utf8
    # params: $string - scalar string to encode [required]
    # prints: feedback
    # return: scalar string, dies on failure
    method make_utf8 ($string) {
        return Encode::encode( 'UTF-8', $string );
    }

    # info()    {{{1
    #
    # does:   log informational message
    # params: nil
    # prints: feedback
    # return: n/a, dies on failure
    # note:   relies on Log::Log4perl being configured elsewhere
    method info ($msg) {
        my $logger   = get_logger();
        my $msg_utf8 = $self->make_utf8($msg);
        $logger->info($msg_utf8);
        return;
    }

    # startup()    {{{1
    #
    # does:   startup tasks
    # params: nil
    # prints: feedback
    # return: n/a, dies on failure
    method startup () {

        # check options    {{{2
        $self->_log_file;
        $self->_analysis;

        # initialise logger    {{{2
        # - if requested by user
        # - only echo info and above to screen
        # - echo everything to file
        if ( $self->use_logger ) {
            my $log_fp = $self->_log_file;
            my $conf
                = "log4perl.logger = DEBUG, File\n"
                . "log4perl.appender.File = Log::Log4perl::Appender::File\n"
                . "log4perl.appender.File.filename = $log_fp\n"
                . "log4perl.appender.File.mode = write\n"
                . "log4perl.appender.File.layout = PatternLayout\n"
                . 'log4perl.appender.File.layout.ConversionPattern = %m%n';
            Log::Log4perl->init_once( \$conf );
        }    # }}}2

        return;
    }

    # detect_missing_key_tags($fp)    {{{1
    #
    # does:   find out if any key id3v2 tags are missing from an mp3 file
    # params: $fp - path to mp3 file to analyse
    # prints: nil
    # return: arrayref, dies on failure
    method detect_missing_key_tags ($fp) {

        # get id3v2 tag information
        my @output;
        my $cmd    = [ 'id3v2', '-l', $fp ];
        my $result = $self->shell_command($cmd);    # croaks on failure
        push @output, $result->stdout;

        # set key tags to search for
        my %key_tags = (
            album_art => qr{\AAPIC[ ][(]Attached[ ]picture[)]:[ ]}xsm,
            album     => qr{\ATALB[ ][(]Album/Movie/Show[ ]title[)]:[ ]}xsm,
            genre     => qr{\ATCON[ ][(]Content[ ]type[)]:[ ]}xsm,
            title =>
                qr{\ATIT2[ ][(]Title/songname/content[ ]description[)]:[ ]}xsm,
            artist =>
                qr{\ATPE1[ ][(]Lead[ ]performer[(]s[)]/Soloist[(]s[)][)]:[ ]}xsm,
            track =>
                qr{\ATRCK[ ][(]Track[ ]number/Position[ ]in[ ]set[)]:[ ]}xsm,
        );

        # find missing tags
        my @missing_tags;
        while ( my ( $tag, $tag_re ) = each %key_tags ) {
            my @re_match = grep {/$tag_re/xsm} @output;
            if ( not @re_match ) { push @missing_tags, $tag; }
        }

        return [@missing_tags];
    }

    # filter_on_missing_key_tags()    {{{1
    #
    # does:   return function that filters for missing key tags
    # params: nil
    # prints: nil
    # return: arrayref, dies on failure
    method filter_on_missing_key_tags () {

        my $filter = sub {

            # get current directory path
            # - dir path is Path::Iterator::Rule parameter 1
            my $path = $ARG[0];

            # look for mp3 files
            my $sep       = File::Spec->catfile( q{}, q{} );
            my @mp3_fps   = glob "${path}${sep}*.mp3";
            my @mp3_files = map { ( File::Spec->splitpath($_) )[2] } @mp3_fps;

            # abort if no mp3 files
            if ( not @mp3_files ) { return $FALSE; }

            # look for mp3 files without key id3v2 tags
            my @missing_tags;
            for my $mp3_fp (@mp3_fps) {
                my @tags = @{ $self->detect_missing_key_tags($mp3_fp) };
                if (@tags) {
                    my $mp3_file = $self->file_name($mp3_fp);
                    push @missing_tags, " - $mp3_file";
                    my $tag_list = join q{, }, sort @tags;
                    push @missing_tags, "   . $tag_list";
                }
            }
            if (@missing_tags) { unshift @missing_tags, q{}, "$path:"; }

            if ( $self->use_logger and @missing_tags ) {
                $self->info( join "\n", @missing_tags );
            }

            # return true if any missing tags detected
            return ( scalar @missing_tags > 0 );

        };

        return $filter;
    }

    # main()    {{{1
    #
    # does:   main method
    # params: nil
    # prints: feedback
    # return: n/a, dies on failure
    method main () {

        $self->startup;

        const my $CWD => Cwd::getcwd;

        # set appropriate filter for specified analysis
        my $analysis = $self->_analysis;

        my $filter;
        for ($analysis) {
            /\Amissing_key_tags\Z/xsm and do {
                $filter = $self->filter_on_missing_key_tags;
                last;
            };
            die "Invalid analysis: $analysis\n";
        }

        # analyse all subdirectories for those matching the selected filter
        my $rule = Path::Iterator::Rule->new;
        my $next = $rule->dir->and($filter)
            ->iter( { depthfirst => $PREORDER_DEPTHFIRST } );
        my @dirpaths;
        while ( defined( my $dir = $next->() ) ) { push @dirpaths, $dir; }

        # convert all found (absolute) directory paths into relative paths
        sub relativise {
            my ( $cwd, $dirpath ) = @ARG;
            my $sep = File::Spec->catfile( q{}, q{} );
            $dirpath =~ s/\A${cwd}${sep}//xsm;
            return $dirpath;
        }
        my @dirs = map { relativise( $CWD, $_ ) } @dirpaths;

        # output directories to stdout
        for ( sort @dirs ) { say or croak; }

    }    # }}}1

}

my $p = Dn::Mp3LibraryAnalyse->new_with_options->main;

1;

# POD    {{{1
__END__

=encoding utf8

=head1 NAME

dn-mp3-library-analyse - analyse mp3 files recursively

=head1 USAGE

B<dn-mp3-library-analyse> B<-a> I<analysis> [B<-l>] [B<-f> I<logfile>]

B<dn-mp3-library-analyse -h>

=head1 REQUIRED ARGUMENTS

There are no required arguments.

=head1 OPTIONS

=over

=item B<-a>  B<--analyse>

The analysis to perform on the mp3 audio files. Valid keywords:
'missing_key_tags'. Required.

=item B<-f>  B<--log_file>

Path to log file. Directory part of path must exist. Optional.

=item B<-l>  B<--use_logger>

Output feedback to a log file. Default: F<~/tmp/dn-mp3-library-analyse.log>.
Optional.

=item B<-h>

Display help and exit.

=back

=head1 DESCRIPTION

Search the current directory recursively for subdirectories that contain mp3
audio files. For each of those (sub)directories perform an analysis determined
by the C<-a> option. All subdirectories meeting the criteria of the analysis
are printed to STDOUT, one per line.

If the C<-l> flag is used then feedback is logged to a log file. A file path to
the log file can be specified with the C<-f> option. If no file path is
provided, the default log file path S<F<~/tmp/dn-mp3-library-analyse.log>> is
used. If the directory component of the log file path is not present, the
script exits with a fatal error.

The exact feedback written to the log file depends on the analysis performed.

=head2 Analysis: missing_key_tags

If this analysis is selected each (sub)directory is scanned for mp3 audio files
missing any of the following id3v2 tags: album art (APIC), album (TALB), genre
(TCON), title (TIT2), artist (TPE1), and track (TRCK). Directories meeting this
criteria are output to stdout. The feedback written to the log file is of the
form:

    /full/path/to/directory:
      - d1_01_audio-file-name.mp3
        . album_art, album, artist, genre, title, track
      - d2_11_audio-file-name.mp3
        . genre, track

=head1 DIAGNOSTICS

=head2 Invalid analysis: I<analysis>

Occurs when an invalid analysis keyword is provided to the C<-a> option.

=head2 No analysis specified

Occurs when no analysis keyword is provided.

=head2 Option I<x> requires and argument

Occurs when no argument is provided to an option that requires one.

=head2 Unknown option: I<x>

Occurs when an invalid option is supplied.

=head1 DEPENDENCIES

=head2 Perl modules

Carp, Const::Fast, Cwd, Role::Utils::Dn, Encode, English, Env, File::Spec,
Function::Parameters, IPC::Cmd, IPC::Run, Log::Log4perl, namespace::clean, Moo,
MooX::Options, Path::Iterator::Rule, strictures, Types::Standard, utf8,
version.

=head1 CONFIGURATION

There is no configuration for this script.

=head1 EXIT STATUS

This script exits with a successful status unless a fatal error has been
thrown by:

=over

=item *

the script, in which case it exits with error code 1

=item *

an underlying module or by the operating system, in which case it exits
with the underlying error code.

=back

=head1 BUGS AND LIMITATIONS

Please report any bugs to the author.

=head1 INCOMPATIBILITIES

There are no known incompatibilities.

=head1 AUTHOR

David Nebauer (david at nebauer dot org)

=head1 LICENSE AND COPYRIGHT

Copyright (c) 2021 David Nebauer (david at nebauer dot org)

This script is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.

=cut
# vim:foldmethod=marker:
