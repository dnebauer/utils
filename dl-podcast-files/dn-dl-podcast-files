#!/usr/bin/perl

use Moo;    # {{{1
use strictures 2;
use 5.036_001;
use version; our $VERSION = qv('0.1');
use namespace::clean;
use Const::Fast;

const my $DASH => q{-};    # }}}1

{    # package: Dn::Episode    {{{1

  package Dn::Episode;

  # modules    {{{2
  use Moo;
  use strictures 2;
  use namespace::clean;
  use Carp qw(croak);
  use Const::Fast;
  use English qw(-no_match_vars);
  use Time::Simple;
  use Types::URI -all;
  use Types::DateTime -all;
  use Types::Standard -all;

  with qw(Role::Utils::Dn);

  const my $TRUE  => 1;
  const my $FALSE => 0;    # }}}2

  # attributes

  # url    {{{2
  has 'url' => (
    is            => 'ro',
    isa           => Types::URI::Uri,
    coerce        => $TRUE,
    required      => $TRUE,
    documentation => 'URL of mp3 file',
  );

  # title    {{{2
  has 'title' => (
    is            => 'ro',
    isa           => Types::Standard::Str,
    required      => $TRUE,
    documentation => 'Title of mp3 file',
  );

  # date    {{{2
  has 'date' => (
    is       => 'ro',
    isa      => Types::DateTime::DateTime->plus_coercions(Format ['ISO8601']),
    coerce   => $TRUE,
    required => $TRUE,
    documentation => 'Date of release of mp3 file (ISO format)',
  );

  # time    {{{2
  has 'time' => (
    is            => 'ro',
    isa           => Types::Standard::Str,
    required      => $TRUE,
    documentation => 'Time of day on which mp3 file was released',
  );

  # validated_time    {{{2
  has 'validated_time' => (
    is       => 'ro',
    isa      => Types::Standard::Str,
    required => $FALSE,
    lazy     => $TRUE,
    default  => sub {
      my $self = shift;
      return if not $self->time;
      my $time = $self->time;

      # "colonify" 4-digit time value
      if ($time =~ /^ ( \d{2} ) ( \d{2} ) \z/xsm) { $time = "$1:$2"; }

      # evaluate time value
      my $valid = eval { Time::Simple->new($time); 1 };
      if (not $valid) {
        my $url = $self->url;
        croak "Invalid time value '$time' for url '$url'";
      }
      return $self->time;
    },
    documentation => 'Validated time of mp3 file release',
  );

  # ep_filename    {{{2
  has 'ep_filename' => (
    is       => 'ro',
    isa      => Types::Standard::Str,
    required => $FALSE,
    lazy     => $TRUE,
    default  => sub {
      my $self = shift;

      # prefix with date (and time if provided)
      my $name = $self->date->ymd(q{});
      if ($self->validated_time) {
        $name .= $DASH . $self->validated_time;
      }

      # add original url filename
      my $url          = $self->file_name($self->url);
      my $url_filename = $self->file_name($url);
      if (not $url_filename) {
        die "Unable to extract filename from url '$url'\n";
      }
      $name .= '_' . $url_filename;
      return $name;
    },
    documentation => 'Name of downloaded file',
  );    # }}}1

}    # }}}1

{

  package Dn::Internal;    ## no critic (ProhibitMultiplePackages)

  # modules    # {{{1
  use Moo;
  use strictures 2;
  use namespace::clean -except => [ '_options_data', '_options_config' ];
  use autodie qw(open close);
  binmode STDOUT, ':encoding(UTF-8)';
  use Carp;
  use Const::Fast;
  use English qw(-no_match_vars);
  use File::Copy;
  use File::Fetch;
  use MooX::HandlesVia;
  use MooX::Options;
  use Types::Standard;
  use YAML;

  with qw(Role::Utils::Dn);

  const my $TRUE      => 1;
  const my $FALSE     => 0;
  const my $DIV_WIDTH => 20;    # }}}1

  # options

  # file (-f)    {{{1
  option 'file' => (
    is            => 'ro',
    format        => 's',
    required      => $TRUE,
    short         => 'f',
    documentation => 'YAML import file',
  );    # }}}1

  # attributes

  # _episodes, _add_episode[s], _has_episode    {{{1
  has '_episode_list' => (
    is  => 'rw',
    isa => Types::Standard::ArrayRef [
      Types::Standard::InstanceOf ['Dn::Episode'],
    ],
    lazy        => $TRUE,
    default     => sub { [] },
    handles_via => 'Array',
    handles     => {
      _episodes     => 'elements',
      _add_episode  => 'push',
      _add_episodes => 'push',
      _has_episode  => 'count',
    },
    documentation => 'Array of episodes',
  );    # }}}1

  # methods

  # main()    {{{1
  #
  # does:   main method
  # params: nil
  # prints: feedback
  # return: n/a, dies on failure
  sub main ($self) {    ## no critic (RequireInterpolationOfMetachars)
    $self->_import();    # dies on failure
    $self->_download_files();
    return $TRUE;
  }

  # _import    {{{1
  #
  # does:   imports YAML data file
  #
  # params: nil
  # prints: feedback on success or failure
  # return: n/a, dies on import failure
  sub _import ($self) {    ## no critic (RequireInterpolationOfMetachars)

    # import file must be valid
    if (not $self->file) { die "No import file specified\n"; }
    my $file = $self->file;
    if (not -e $file) { die "Cannot find '$file'\n"; }

    # import the file
    my @imported = YAML::LoadFile($file);
    my $count    = @imported;
    if (not $count) { croak "No episodes were imported from file $file"; }

    # extract episode details
    my @episodes;
    for my $details (@imported) {
      my $episode = Dn::Episode->new(
        ## no critic (ProhibitDuplicateLiteral)
        url   => $details->{'url'},
        title => $details->{'title'},
        date  => $details->{'date'},
        time  => $details->{'time'},
        ## use critic
      );
      push @episodes, $episode;
    }
    $count = @episodes;
    if ($count) {
      say $self->pluralise(
        "Obtained download details for $count (file|files)", $count)
          or croak;
    }
    else {
      die "No episode details were extracted from file '$file' data\n";
    }

    # save episode details
    $self->_add_episodes(@episodes);

    return $TRUE;
  }    # }}}1

  # _download_files()    {{{1
  #
  # does:   download files
  # params: nil
  # prints: nil, except error messages
  # return: n/a, dies on failure
  sub _download_files ($self) { ## no critic (RequireInterpolationOfMetachars)
    for my $episode ($self->_episodes) {

      # set details
      my $title = $episode->title;

      # give feedback
      my $div = $DASH x $DIV_WIDTH;
      say "Downloading episode '$title'" or croak;
      say $div                           or croak;

      # perform download
      my $ff    = File::Fetch->new(uri => $episode->url);
      my $where = $ff->fetch;
      if (not $where) { die "Download failed\n"; }

      # rename file
      my $old = $self->file_name($where);
      my $new = $episode->ep_filename;
      File::Copy::move($old, $new)
          or die "Unable to rename '$old' to '$new'\n";
    }
    return $TRUE;
  }    # }}}1

}

my $p = Dn::Internal->new_with_options->main;

1;

# POD    {{{1

## no critic (RequirePodSections)

__END__

=head1 NAME

dn-dl-podcast-files - downloads podcast files

=head1 USAGE

B<dn-dl-podcast-files> I<-f file>

B<dn-dl-podcast-files> I<-h>

=head1 OPTIONS

=over

=item B<-f>

Name of input file.

Required.

=item B<-h>

Display help and exit.

=back

=head1 DESCRIPTION

A script developed for downloading podcast files that are too old to appear in a podcast feed but that are still included in the rss feed file online. Details of the files are obtained and a yaml input file created. The input file lists the following for each download file: url, title, date and time. Date and time are the date and time the file was published. Required values are url, title and time. Date is optional.

Here is an example input file. It lists episodes from the "Fear the Boot" podcast.

    ---
    url: http://media.libsyn.com/media/feartheboot/feartheboot_0001.mp3
    title: Episode 1 - when player abilities eclipse character abilities
    date: 2006-05-15
    time: 2230
    ---
    url: http://media.libsyn.com/media/feartheboot/feartheboot_0002.mp3
    title: Episode 2 - creating a group template
    date: 2006-05-23
    time: 0611
    ---
    url: http://media.libsyn.com/media/feartheboot/feartheboot_0003.mp3
    title: Episode 3 - character creation
    date: 2006-05-30
    time: 0836

The downloaded file name consists of the url filename with a prefix constructed from the episode's date and, if provided, time. Here are the download files corresponding to the input file shown above:

    20060515-2230_feartheboot_0001.mp3
    20060523-0611_feartheboot_0002.mp3
    20060530-0836_feartheboot_0003.mp3

=head1 DEPENDENCIES

=head2 Perl modules

Carp, Const::Fast, English, File::Copy, File::Fetch, Moo, MooX::HandlesVia,
MooX::Options, Role::Utils::Dn, Time::Simple, Types::DateTime, Types::Standard,
Types::URI, YAML, autodie, namespace::clean, strictures, version.

=head2 Executables

wget.

=head1 BUGS AND LIMITATIONS

Please report any bugs to the author.

=head1 AUTHOR

David Nebauer E<lt>davidnebauer@hotkey.net.auE<gt>

=head1 LICENSE AND COPYRIGHT

Copyright (c) 2015 David Nebauer E<lt>davidnebauer@hotkey.net.auE<gt>

This script is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

=cut
# vim:fdm=marker

