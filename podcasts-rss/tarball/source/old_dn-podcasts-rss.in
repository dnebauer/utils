#!/usr/bin/perl

###############################################################################
# The perlpod documentation in this script is designed to produce a man page. #
# To perform the conversion, execute this command:                            #
#                                                                             #
# 		pod2man dn-podcasts-rss dn-podcasts-rss.1                             #
#                                                                             #
# in the dn-qk-deb build directory.                                           #
###############################################################################

=head1 NAME

dn-podcasts-rss - maintains podcasts files and generates an rss feed

=head1 SUMMARY

Assists the user to maintain podcast files.  Will also generate an rss feed (xml) file, along with a subscription opml file that can be used to add the feed.

When generating the rss feed files necessary information is drawn from the podcast files themselves as well as a series of input files.  (Execute this script with the '-i' option to see the input file names.)

The input files are created and maintained by this script.

When run this script does the following:

	process new/unpublished podcast files
	create/update channel metadata
	create/update rss feed files

Processing unpublished podcast files is an interactive task.  It involves renaming the audio files according to a template and using default values for audio file tags.

Creating or updating existing channel metadata is an interactive process.

Creating or updating rss feed files is automatic once the previous steps have occurred.

This script supports only one channel per rss feed and requires all files for a given feed to be in the same directory.  This script must be run from inside that directory.

To use this script for the first time simply ensure the podcast feed audio files are in a single directory and run this script in that directory.

At this time only mp3 audio files are supported.

=head1 USAGE

dn-podcasts-rss

=over

This is the standard usage.

The output files are called 'rss-feed.xml' and 'rss-feed.opml' by default but the file basename can be changed in the channel metadata input file.

=back

dn-podcasts-rss -c

=over

Display categorisation scheme for rss channels.

=back

dn-podcasts-rss -i

=over

This script relies on a number of input files the script automatically creates in the podcast directory.  This usage displays the names of these input files.

=back

dn-podcasts-rss -h

=over

Displays help text and exits.

=back

=head1 STRUCTURE

RSS feed files consist of one or more channels, each of which contains one or more items.  Each item is a single audio track.  In this implementation there is only one channel per RSS feed.  If you have multiple channels you will have to create an RSS feed for each one.

References throughout this documentation are made to the Apple specification for RSS feeds.  This specification was accessed at C<http://www.apple.com/itunes/podcasts/specs.html> on or about 2010-01-03.

This script defines the following classes (packages):

=head2 'DnFeed'

Models the rss feed.

=head2 'DnChannel'

Models the single channel for the rss feed.  Retrieves channel metadata and passes one (base url) to the DnItem class.  Also retrieves published input file data (pubdates) and passes them to the DnItem class.

=head2 'DnItem'

Models a single channel item.  Data are assembled from podcast file attributes, mp3 tags, podcasts input file data and published input file data.  Data are written to mp3 tags, podcasts input file data and published input file.

=head2 'DnAudioFile'

Models a single podcast audio mp3 file.  Retrieves various attributes about file.  Enable setting and getting of mp3 tag values.  Also enables changing of file name.

=head1 PACKAGE: DnAudioFile

An internal package encapsulating methods and data for updating podcast mp3 file tags and retrieving information about podcast mp3 files.

The following is a list of what is required to generate an rss feed channel item.  The source of each is shown.

	audio mp3 file: in directory
	title: mp3 tag 'title'
	author: try mp3 tag 'composer', then mp3 tag 'artist'
	summary: mp3 tag 'comment'
	filepath/guid: channel attribute 'base_url' + file attribute 'filename'
	type: file attribute 'mime-type'
	size: file attribute 'size'
	pubdate: input file 'podcasts'
	duration: file attribute 'duration'
	explicit: channel attribute 'explicit'  **DELETE**

In summary, then, here are the sources for rss feed channel items metadata:

	file attributes: 'filename', 'mime-type', 'size', and 'duration',
	mp3 tags: 'title', 'composer'/'artist', and 'comment',
	channel attributes: 'base_url', and 'explicit', and
	podcasts input file: 'pubdate'

The mp3 tags mentioned are able to be edited.  There are other mp3 tags that are not required for generating an rss feed channel item, but that users often want to alter for the sake of completeness.  As a convenience, this utility enables setting them as well.  These additional tags are:

	album
	year
	genre: default = 'podcast'
	disc:  default = ''
	track: default = ''

=cut

package DnAudioFile;

use strict;
use warnings;
use parent qw/ Dn::PodcastsRss /;

our $VERSION = '0.1';

use constant TRUE => 1;
use constant FALSE => 0;

=head2 Methods

TODO: Set only data members that can be altered, i.e., not duration, guid, mime-type, etc.

=head3 Data Members

%self = (

	$file      =>  "<filename>" ,

	$podcast   =>  MP3::Info object ,

	$guid      =>  "<guid>" ,

	$duration  =>  "HH:MM:SS" ,

	$size      =>  <bytes> ,

	$type      =>  "<type>" ,

	$title     =>  "<title>" ,

	$author    =>  "<author>" ,

	$summary   =>  "<summary>" ,

	$explicit  =>  "'yes'|'clean'|'no'" ,

	$pubdate   =>  "<pubdate>" ,

)

=cut

sub new {
	my $proto = shift;
	my $class = ref($proto) || $proto;
	my $self  = {};

=over

=item

B<filepath>

Filepath of mp3 pod.  If invocation argument is present, use it as filepath.  Base url will be prepended to this filepath when outputting.

=cut

	$self->{'filepath'} = shift;  # undef if no file path parameter

=item

B<guid>

Globally unique identifier used for pod mp3.  According to the Apple specification it should consist of 32 characters.  Set now if filepath known.

=cut

	$self->{'guid'} = undef;

=item

B<duration>

Duration of pod mp3.  Format = "[HH:]MM:SS"/"[H:]M:S".  Set now if filepath known.

=cut

	$self->{'duration'} = undef;

=item

B<size>

Size of pod mp3 file in bytes.  Set now if filepath known.

=cut

	$self->{'size'} = undef;

=item

B<type>

Mime type pod file in bytes.  Should be 'audio/mp3' or 'audio/mpeg'.  Set now if filepath known.

=cut

	$self->{'type'} = undef;

=item

B<title>

Track title.

=cut

	$self->{'title'} = undef;

=item

B<author>

Track author.

=cut

	$self->{'author'} = undef;

=item

B<summary>

Track summary.

=cut

	$self->{'summary'} = undef;

=item

B<explicit>

Whether track contains explicit content.  Values: 'yes'|'clean'|'no'.  Default = 'no'.

=cut

	$self->{'explicit'} = 'no';

=item

B<pubdate>

Track publication date.  The Apple specification for rss feeds states:

	The date and time format in <pubDate> must conform to RFC 2822.
	
	The date must be "day-of-week, day month year". The time must be
	in 24 hour format (no AM or PM) and must include the time zone offset.
	
	<! — date and time not in RFC 2822 format — >
	<pubDate>7/6/2005 1:00:00 PM</pubDate>
	
	<! — valid date and time format — >
	<pubDate>Wed, 6 Jul 2005 13:00:00 PDT</pubDate>
	<pubDate>Wed, 6 Jul 2005 13:00:00 -0700</pubDate>

=cut

	$self->{'pubdate'} = undef;

=back

=head3 Constructors

There are two method signatures: one with filepath and one without:

	my $ojb = new DnItem;  OR  my $ojb = DnItem->new();
	my $ojb = DnItem->new( <filepath> );

=cut

	bless ( $self , $class );
	return $self;
	}

=head3 Setters

GUID, mp3 duration, size and type are set automatically when filepath is set or, if filepath set at object contruction, when any of those attribute getters are called.

	$i->set_filepath( '<filepath>' );
	$i->set_guid( '<guid>' );
	$i->set_duration( '<duration>' );
	$i->set_size( '<size>' );
	$i->set_type( '<type>' );
	$i->set_title( '<title>' );
	$i->set_author( '<author>' );
	$i->set_summary( '<summary>' );
	$i->set_explicit( 'yes|clean|no' );
	$i->set_pubdate( '<date>' );

=cut

	sub set_filepath { $_[0]->{'filepath'} = $_[1] ; $_[0]->set_file_attr(); }
	sub set_guid { $_[0]->{'guid'} = $_[1]; }
	sub set_duration { $_[0]->{'duration'} = $_[1]; }
	sub set_size { $_[0]->{'size'} = $_[1]; }
	sub set_type { $_[0]->{'type'} = $_[1]; }
	sub set_title { $_[0]->{'title'} = $_[1]; }
	sub set_author { $_[0]->{'author'} = $_[1]; }
	sub set_summary { $_[0]->{'summary'} = $_[1]; }
	sub set_explicit { $_[0]->{'explicit'} = $_[1]; }
	sub set_pubdate { $_[0]->{'pubdate'} = $_[1]; }

=head3 Getters

	$i->filepath();
	$i->guid();
	$i->duration();
	$i->size();
	$i->type();
	$i->title();
	$i->author();
	$i->summary();
	$i->explicit();
	$i->pubdate();

=cut

	sub filepath  { $_[0]->{'filepath'}; }
	sub guid      { $_[0]->set_file_attr() unless $_[0]->{'guid'} ; $_[0]->{'guid'}; }
	sub duration  { $_[0]->set_file_attr() unless $_[0]->{'duration'} ; $_[0]->{'duration'}; }
	sub size      { $_[0]->set_file_attr() unless $_[0]->{'size'} ; $_[0]->{'size'}; }
	sub type      { $_[0]->set_file_attr() unless $_[0]->{'type'} ; $_[0]->{'type'}; }
	sub title     { $_[0]->{'title'};    }
	sub author    { $_[0]->{'author'};   }
	sub summary   { $_[0]->{'summary'};  }
	sub explicit  { $_[0]->{'explicit'}; }
	sub pubdate   { $_[0]->{'pubdate'};  }

=head3 Other

=head4 set_file_attr()

Sets file attributes: guid, duration, size and type.

Uses data member 'filepath' for the file to analyse when setting duration, size and type.  If no filepath is set, those attributes are set to 'undef'.

Parameters: [ 0 = class ].

Return type: N/A.

=cut

sub set_file_attr {
	my $self = shift;
	my $fp = $self->filepath();
	$self->set_guid( $self->uuid() );
	$self->set_duration( ( $fp ) ? $self->mp3_duration( $fp ) : undef );
	$self->set_size( ( $fp ) ? $self->file_size( $fp ) : undef );
	$self->set_type( ( $fp ) ? $self->mime_type( $fp ) : undef );
}

=head4 xml()

Prints xml fragment for item.  It is intended to be included in the final rss feed file.  Here is example output:

	<item>
		<title><![CDATA[01 Political Incorrections]]></title>
		<itunes:author>Bill Maher</itunes:author>
		<itunes:summary><![CDATA[Track 01 of a compilation of selected extracts from Bill Maher's "Politically Incorrect"]]></itunes:summary>
		<enclosure url="http://localhost/podcasts/pol-inc/bill-maher_track-01.mp3" type="audio/mpeg" length="23576367"/>
		<pubDate>Sun, 29 Nov 2009 00:00:00 +1000</pubDate>
		<itunes:duration>08:00</itunes:duration>
		<itunes:explicit/>
		<itunes:keywords><![CDATA[politics, satire]]></itunes:keywords>
	</item>

By default the 'item' element is flush left with all subsidiary elements indented normally.  You can increase the left indent of all output by supplying the number of additional tab indents in an argument.

Requires the base url to prepend to track names.

Parameters: [ 0 = class ] , 1 = base_url , 2 = tabs.

Return type: List reference (one line per element, newline ends each line).

=cut

sub xml {
	my ( $self , $base_url , $tab_count ) = ( shift , shift , shift );
	my ( $tabs , @xml ) = ( "" , () );
	$tab_count = 0 if not $tab_count;
	$tabs .= "\t" foreach ( 1..$tab_count );
	# write xml
	push @xml , "$tabs<item>\n";
	push @xml , sprintf( "$tabs\t<title>%s</title>\n" ,
		                 $self->title() );
	push @xml , sprintf( "$tabs\t<itunes:author>%s</itunes:author>\n" ,
	                     $self->author() );
	push @xml , sprintf( "$tabs\t<itunes:summary>%s</itunes:summary>\n" ,
	                     $self->summary() );
	push @xml , sprintf( "$tabs\t<enclosure url=\"%s/%s\" \n" ,
	                     $base_url , $self->filepath() );
	push @xml , sprintf( "$tabs\t           type=\"%s\" \n" ,
	                     $self->type() );
	push @xml , sprintf( "$tabs\t           length=\"%d\"/>\n" ,
	                     $self->size() );
	push @xml , sprintf( "$tabs\t<pubDate>%s</pubDate>\n" ,
		                 $self->pubdate() );
	push @xml , sprintf( "$tabs\t<itunes:duration>%s</itunes:duration>\n" ,
		                 $self->duration() );
	push @xml , sprintf( "$tabs\t<itunes:explicit>%s</itunes:explicit>\n" , 
		                 $self->explicit() );
	push @xml , "$tabs</item>\n";
	# return result
	\@xml;
}

=head4 valid_explicit()

Determines whether explicit setting is valid.  Valid settings are 'yes', 'clean' and 'no'.  This method accepts only these values although some systems will interpret any value other than 'yes' and 'clean' as 'no'.

Parameters: [ 0 = class ].

Return type: Boolean.

=cut

sub valid_explicit {
	my $explicit = $_[0]->explicit();
	grep /^$explicit$/ , qw( yes clean no );
}

=head4 audio_mime_type()

Determines whether mime type is valid.  Currently the only valid mime types are 'audio/mp3' and 'audio/mpeg'.

Parameters: [ 0 = class ].

Return type: Boolean.

=cut

sub audio_mime_type {
	my $mime_type = $_[0]->type();
	grep /^$mime_type$/ , qw( audio/mp3 audio/mpeg );
}

=head4 valid_pubdate_format()

Note: This method is not intended to be called directly.  The method 'valid_pubdate' calls it before checking the date value itself is valid.

Determines whether publication date is in valid RFC 2822 format.  This format requires:

	day, DD MMM YYYY HH:MM:SS +/-OFFSET

where 'day' is Mon, Tue, etc.; MMM is Apr, May, etc.; time is 24-hour time; and OFFSET is time zone offset such as +0930.

This is an example date:

	Wed, 6 Jul 2005 13:00:00 -0700

The *nix date command outputs in RFC 2822 format when the '-R' or '--rfc-2822' flags are used.

Parameters: [ 0 = class ].

Return type: Boolean.

=cut

sub valid_pubdate_format {
	my $pubdate = $_[0]->pubdate();
	# do general pass for most formatting
	return 0 if not $pubdate
		=~ '^[A-Z][a-z]{2}, \d{1,2} [A-Z][a-z]{2} \d{4} \d{1,2}:\d{1,2}:\d{1,2} [+-]\d{4}$';
	# now check day of week and month name
	my ( $dow , $month ) = ( split /\s+/ , $pubdate )[0,2];
	$dow = substr( $dow , 0 , 3 );  # terminal comma confuses grep
	return 0 if not grep /\b$dow\b/ , qw( Mon Tue Wed Thu Fri Sat Sun );
	return 0 if not grep /\b$month\b/ ,
	                     qw( Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec );
	1;  # if reached end then valid format
}

=head4 valid_pubdate()

Determines whether publication date is valid.  It first calls 'valid_date_format' to ensure date is in valid RFC 2822 format.

It then confirms the date itself is valid.  In particular, it performs three checks:

=over

=item that date exists and is valid

=item that time is valid

=item that day of the week is correct for the date

=back

Parameters: [ 0 = class ].

Return type: Boolean.

=cut

sub valid_pubdate {
	my ( $self ) = ( shift );
	# check date format
	return 0 if not $self->valid_pubdate_format();
	# check date validity
	my $pubdate = $self->pubdate();
	my ( $dow_name , $day , $month_name , $year , $time )
		= ( split /\s+/ , $pubdate )[0,1,2,3,4];
	# date
	my $month = $self->decode_month( $month_name );
	my $iso_date = $self->assemble_iso_date( $year , $month , $day );
	return 0 if not $self->valid_iso_date( $iso_date );
	# day name
	$dow_name = substr( $dow_name , 0 , 3 );  # leave off terminal comma
	my $dow = $self->decode_day_of_week( $dow_name );
	return 0 if not $dow == $self->day_of_week_index( $iso_date );
	# time
	return 0 if not $self->valid_time( $time );
	1;  # if still here then date is valid
}

=head4 empty()

Determines whether item is empty.  This requires the following items to be undefined: filepath, duration, size, mime type, title, author, summary, explicit and publication date.

Parameters: [ 0 = class ].

Return type: Boolean.

=cut

sub empty {
	my ( $self ) = ( shift );
	# check that elements are undefined
	return undef if $self->filepath();
	return undef if $self->duration();
	return undef if $self->size();
	return undef if $self->type();
	return undef if $self->title();
	return undef if $self->author();
	return undef if $self->summary();
	return undef if $self->pubdate();
	# return success if till here
	1;
}

=head4 complete()

Determines whether item is complete.  This requires:

	- all of the following items: filepath, guid, duration, size, mime type, title, author, summary, explicit and publication date,
	- explicit is set to 'yes', 'clean' or 'no',
	- mime type is either 'audio/mp3' or 'audio/mpeg', and
	- publication date is in RFC 2822 format.

Parameters: [ 0 = class ].

Return type: Boolean.

=cut

sub complete {
	my ( $self ) = ( shift );
	# check that all elements are present
	return undef if not $self->filepath();
	return undef if not $self->guid();
	return undef if not $self->duration();
	return undef if not $self->size();
	return undef if not $self->type();
	return undef if not $self->title();
	return undef if not $self->author();
	return undef if not $self->summary();
	return undef if not $self->explicit();
	return undef if not $self->pubdate();
	# check explicit setting
	return undef if not $self->valid_explicit();
	# check mime type
	return undef if not $self->audio_mime_type();
	# check publication date
	return undef if not $self->valid_pubdate();
	1;  # return sucess if till here
}

=head4 why_incomplete()

Returns list of reasons why item is incomplete.

Does not check whether item is complete -- it is presumed the 'complete' method has already determined this.  It is therefore possible for this function, if improperly called on a complete item, to return an empty list.

See 'complete' method for the requirements of a complete item.

Parameters: [ 0 = class ].

Return type: List reference (one line per element, newline end each line).

=cut

sub why_incomplete {
	my ( $self , @ret ) = ( shift );
	# check that all elements are present
	push( @ret , "no filepath\n" ) if not $self->filepath();
	push( @ret , "no item GUID\n" ) if not $self->guid();
	push( @ret , "no track duration\n" ) if not $self->duration();
	push( @ret , "no file size\n" ) if not $self->size();
	push( @ret , "no mime type\n" ) if not $self->type();
	push( @ret , "no title\n" ) if not $self->title();
	push( @ret , "no author\n" ) if not $self->author();
	push( @ret , "no summary\n" ) if not $self->summary();
	push( @ret , "no explicit setting\n" ) if not $self->explicit();
	push( @ret , "no publication date\n" ) if not $self->pubdate();
	# check explicit setting
	if ( $self->explicit() ) {
		if ( not $self->valid_explicit() ) {
			push( @ret , "invalid explicit seting '" . $self->explicit() . "'\n" );
		}
	}
	# check mime type
	if ( $self->type() ) {
		if ( not $self->audio_mime_type() ) {
			push( @ret , "invalid mime type '" . $self->type() . "'\n" );
		}
	}
	# check publication date
	if ( $self->pubdate() ) {
		if ( not $self->valid_pubdate() ) {
			push( @ret , "invalid publication date '" . $self->pubdate() . "'\n" );
		}
	}
	# return result
	\@ret;
}

=head4 clear()

Clear all values from item.

Parameters: [ 0 = class ].

Return type: N/A.

=cut

sub clear {
	my ( $self ) = ( shift );
	# check that all elements are present
	$self->set_filepath( undef );  # also clears guid, duration, size and type
	$self->set_title( undef );
	$self->set_author( undef );
	$self->set_summary( undef );
	$self->set_explicit( 'no' );
	$self->set_pubdate( undef );
}

=head1 PACKAGE: DnItem

An internal package encapsulating methods and data for updating podcast mp3 file tags and retrieving information about podcast mp3 files.

The following is a list of what is required to generate an rss feed channel item.  The source of each is shown.

	audio mp3 file: in directory
	title: mp3 tag 'title'
	author: try mp3 tag 'composer', then mp3 tag 'artist'
	summary: mp3 tag 'comment'
	filepath/guid: channel attribute 'base_url' + file attribute 'filename'
	type: file attribute 'mime-type'
	size: file attribute 'size'
	pubdate: input file 'podcasts'
	duration: file attribute 'duration'
	explicit: channel attribute 'explicit'  **DELETE**

In summary, then, here are the sources for rss feed channel items metadata:

	file attributes: 'filename', 'mime-type', 'size', and 'duration',
	mp3 tags: 'title', 'composer'/'artist', and 'comment',
	channel attributes: 'base_url', and 'explicit', and
	podcasts input file: 'pubdate'

The mp3 tags mentioned are able to be edited.  There are other mp3 tags that are not required for generating an rss feed channel item, but that users often want to alter for the sake of completeness.  As a convenience, this utility enables setting them as well.  These additional tags are:

	album
	year
	genre: default = 'podcast'
	disc:  default = ''
	track: default = ''

=cut

package DnItem;

use strict;
use warnings;
use parent qw/ Dn::PodcastsRss /;

our $VERSION = '0.1';

use constant TRUE => 1;
use constant FALSE => 0;

=head2 Methods

TODO: Set only data members that can be altered, i.e., not duration, guid, mime-type, etc.

=head3 Data Members

%self = (

	$file      =>  "<filename>" ,

	$podcast   =>  MP3::Info object ,

	$guid      =>  "<guid>" ,

	$duration  =>  "HH:MM:SS" ,

	$size      =>  <bytes> ,

	$type      =>  "<type>" ,

	$title     =>  "<title>" ,

	$author    =>  "<author>" ,

	$summary   =>  "<summary>" ,

	$explicit  =>  "'yes'|'clean'|'no'" ,

	$pubdate   =>  "<pubdate>" ,

)

=cut

sub new {
	my $proto = shift;
	my $class = ref($proto) || $proto;
	my $self  = {};

=over

=item

B<filepath>

Filepath of mp3 pod.  If invocation argument is present, use it as filepath.  Base url will be prepended to this filepath when outputting.

=cut

	$self->{'filepath'} = shift;  # undef if no file path parameter

=item

B<guid>

Globally unique identifier used for pod mp3.  According to the Apple specification it should consist of 32 characters.  Set now if filepath known.

=cut

	$self->{'guid'} = undef;

=item

B<duration>

Duration of pod mp3.  Format = "[HH:]MM:SS"/"[H:]M:S".  Set now if filepath known.

=cut

	$self->{'duration'} = undef;

=item

B<size>

Size of pod mp3 file in bytes.  Set now if filepath known.

=cut

	$self->{'size'} = undef;

=item

B<type>

Mime type pod file in bytes.  Should be 'audio/mp3' or 'audio/mpeg'.  Set now if filepath known.

=cut

	$self->{'type'} = undef;

=item

B<title>

Track title.

=cut

	$self->{'title'} = undef;

=item

B<author>

Track author.

=cut

	$self->{'author'} = undef;

=item

B<summary>

Track summary.

=cut

	$self->{'summary'} = undef;

=item

B<explicit>

Whether track contains explicit content.  Values: 'yes'|'clean'|'no'.  Default = 'no'.

=cut

	$self->{'explicit'} = 'no';

=item

B<pubdate>

Track publication date.  The Apple specification for rss feeds states:

	The date and time format in <pubDate> must conform to RFC 2822.
	
	The date must be "day-of-week, day month year". The time must be
	in 24 hour format (no AM or PM) and must include the time zone offset.
	
	<! — date and time not in RFC 2822 format — >
	<pubDate>7/6/2005 1:00:00 PM</pubDate>
	
	<! — valid date and time format — >
	<pubDate>Wed, 6 Jul 2005 13:00:00 PDT</pubDate>
	<pubDate>Wed, 6 Jul 2005 13:00:00 -0700</pubDate>

=cut

	$self->{'pubdate'} = undef;

=back

=head3 Constructors

There are two method signatures: one with filepath and one without:

	my $ojb = new DnItem;  OR  my $ojb = DnItem->new();
	my $ojb = DnItem->new( <filepath> );

=cut

	bless ( $self , $class );
	return $self;
	}

=head3 Setters

GUID, mp3 duration, size and type are set automatically when filepath is set or, if filepath set at object contruction, when any of those attribute getters are called.

	$i->set_filepath( '<filepath>' );
	$i->set_guid( '<guid>' );
	$i->set_duration( '<duration>' );
	$i->set_size( '<size>' );
	$i->set_type( '<type>' );
	$i->set_title( '<title>' );
	$i->set_author( '<author>' );
	$i->set_summary( '<summary>' );
	$i->set_explicit( 'yes|clean|no' );
	$i->set_pubdate( '<date>' );

=cut

	sub set_filepath { $_[0]->{'filepath'} = $_[1] ; $_[0]->set_file_attr(); }
	sub set_guid { $_[0]->{'guid'} = $_[1]; }
	sub set_duration { $_[0]->{'duration'} = $_[1]; }
	sub set_size { $_[0]->{'size'} = $_[1]; }
	sub set_type { $_[0]->{'type'} = $_[1]; }
	sub set_title { $_[0]->{'title'} = $_[1]; }
	sub set_author { $_[0]->{'author'} = $_[1]; }
	sub set_summary { $_[0]->{'summary'} = $_[1]; }
	sub set_explicit { $_[0]->{'explicit'} = $_[1]; }
	sub set_pubdate { $_[0]->{'pubdate'} = $_[1]; }

=head3 Getters

	$i->filepath();
	$i->guid();
	$i->duration();
	$i->size();
	$i->type();
	$i->title();
	$i->author();
	$i->summary();
	$i->explicit();
	$i->pubdate();

=cut

	sub filepath  { $_[0]->{'filepath'}; }
	sub guid      { $_[0]->set_file_attr() unless $_[0]->{'guid'} ; $_[0]->{'guid'}; }
	sub duration  { $_[0]->set_file_attr() unless $_[0]->{'duration'} ; $_[0]->{'duration'}; }
	sub size      { $_[0]->set_file_attr() unless $_[0]->{'size'} ; $_[0]->{'size'}; }
	sub type      { $_[0]->set_file_attr() unless $_[0]->{'type'} ; $_[0]->{'type'}; }
	sub title     { $_[0]->{'title'};    }
	sub author    { $_[0]->{'author'};   }
	sub summary   { $_[0]->{'summary'};  }
	sub explicit  { $_[0]->{'explicit'}; }
	sub pubdate   { $_[0]->{'pubdate'};  }

=head3 Other

=head4 set_file_attr()

Sets file attributes: guid, duration, size and type.

Uses data member 'filepath' for the file to analyse when setting duration, size and type.  If no filepath is set, those attributes are set to 'undef'.

Parameters: [ 0 = class ].

Return type: N/A.

=cut

sub set_file_attr {
	my $self = shift;
	my $fp = $self->filepath();
	$self->set_guid( $self->uuid() );
	$self->set_duration( ( $fp ) ? $self->mp3_duration( $fp ) : undef );
	$self->set_size( ( $fp ) ? $self->file_size( $fp ) : undef );
	$self->set_type( ( $fp ) ? $self->mime_type( $fp ) : undef );
}

=head4 xml()

Prints xml fragment for item.  It is intended to be included in the final rss feed file.  Here is example output:

	<item>
		<title><![CDATA[01 Political Incorrections]]></title>
		<itunes:author>Bill Maher</itunes:author>
		<itunes:summary><![CDATA[Track 01 of a compilation of selected extracts from Bill Maher's "Politically Incorrect"]]></itunes:summary>
		<enclosure url="http://localhost/podcasts/pol-inc/bill-maher_track-01.mp3" type="audio/mpeg" length="23576367"/>
		<pubDate>Sun, 29 Nov 2009 00:00:00 +1000</pubDate>
		<itunes:duration>08:00</itunes:duration>
		<itunes:explicit/>
		<itunes:keywords><![CDATA[politics, satire]]></itunes:keywords>
	</item>

By default the 'item' element is flush left with all subsidiary elements indented normally.  You can increase the left indent of all output by supplying the number of additional tab indents in an argument.

Requires the base url to prepend to track names.

Parameters: [ 0 = class ] , 1 = base_url , 2 = tabs.

Return type: List reference (one line per element, newline ends each line).

=cut

sub xml {
	my ( $self , $base_url , $tab_count ) = ( shift , shift , shift );
	my ( $tabs , @xml ) = ( "" , () );
	$tab_count = 0 if not $tab_count;
	$tabs .= "\t" foreach ( 1..$tab_count );
	# write xml
	push @xml , "$tabs<item>\n";
	push @xml , sprintf( "$tabs\t<title>%s</title>\n" ,
		                 $self->title() );
	push @xml , sprintf( "$tabs\t<itunes:author>%s</itunes:author>\n" ,
	                     $self->author() );
	push @xml , sprintf( "$tabs\t<itunes:summary>%s</itunes:summary>\n" ,
	                     $self->summary() );
	push @xml , sprintf( "$tabs\t<enclosure url=\"%s/%s\" \n" ,
	                     $base_url , $self->filepath() );
	push @xml , sprintf( "$tabs\t           type=\"%s\" \n" ,
	                     $self->type() );
	push @xml , sprintf( "$tabs\t           length=\"%d\"/>\n" ,
	                     $self->size() );
	push @xml , sprintf( "$tabs\t<pubDate>%s</pubDate>\n" ,
		                 $self->pubdate() );
	push @xml , sprintf( "$tabs\t<itunes:duration>%s</itunes:duration>\n" ,
		                 $self->duration() );
	push @xml , sprintf( "$tabs\t<itunes:explicit>%s</itunes:explicit>\n" , 
		                 $self->explicit() );
	push @xml , "$tabs</item>\n";
	# return result
	\@xml;
}

=head4 valid_explicit()

Determines whether explicit setting is valid.  Valid settings are 'yes', 'clean' and 'no'.  This method accepts only these values although some systems will interpret any value other than 'yes' and 'clean' as 'no'.

Parameters: [ 0 = class ].

Return type: Boolean.

=cut

sub valid_explicit {
	my $explicit = $_[0]->explicit();
	grep /^$explicit$/ , qw( yes clean no );
}

=head4 audio_mime_type()

Determines whether mime type is valid.  Currently the only valid mime types are 'audio/mp3' and 'audio/mpeg'.

Parameters: [ 0 = class ].

Return type: Boolean.

=cut

sub audio_mime_type {
	my $mime_type = $_[0]->type();
	grep /^$mime_type$/ , qw( audio/mp3 audio/mpeg );
}

=head4 valid_pubdate_format()

Note: This method is not intended to be called directly.  The method 'valid_pubdate' calls it before checking the date value itself is valid.

Determines whether publication date is in valid RFC 2822 format.  This format requires:

	day, DD MMM YYYY HH:MM:SS +/-OFFSET

where 'day' is Mon, Tue, etc.; MMM is Apr, May, etc.; time is 24-hour time; and OFFSET is time zone offset such as +0930.

This is an example date:

	Wed, 6 Jul 2005 13:00:00 -0700

The *nix date command outputs in RFC 2822 format when the '-R' or '--rfc-2822' flags are used.

Parameters: [ 0 = class ].

Return type: Boolean.

=cut

sub valid_pubdate_format {
	my $pubdate = $_[0]->pubdate();
	# do general pass for most formatting
	return 0 if not $pubdate
		=~ '^[A-Z][a-z]{2}, \d{1,2} [A-Z][a-z]{2} \d{4} \d{1,2}:\d{1,2}:\d{1,2} [+-]\d{4}$';
	# now check day of week and month name
	my ( $dow , $month ) = ( split /\s+/ , $pubdate )[0,2];
	$dow = substr( $dow , 0 , 3 );  # terminal comma confuses grep
	return 0 if not grep /\b$dow\b/ , qw( Mon Tue Wed Thu Fri Sat Sun );
	return 0 if not grep /\b$month\b/ ,
	                     qw( Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec );
	1;  # if reached end then valid format
}

=head4 valid_pubdate()

Determines whether publication date is valid.  It first calls 'valid_date_format' to ensure date is in valid RFC 2822 format.

It then confirms the date itself is valid.  In particular, it performs three checks:

=over

=item that date exists and is valid

=item that time is valid

=item that day of the week is correct for the date

=back

Parameters: [ 0 = class ].

Return type: Boolean.

=cut

sub valid_pubdate {
	my ( $self ) = ( shift );
	# check date format
	return 0 if not $self->valid_pubdate_format();
	# check date validity
	my $pubdate = $self->pubdate();
	my ( $dow_name , $day , $month_name , $year , $time )
		= ( split /\s+/ , $pubdate )[0,1,2,3,4];
	# date
	my $month = $self->decode_month( $month_name );
	my $iso_date = $self->assemble_iso_date( $year , $month , $day );
	return 0 if not $self->valid_iso_date( $iso_date );
	# day name
	$dow_name = substr( $dow_name , 0 , 3 );  # leave off terminal comma
	my $dow = $self->decode_day_of_week( $dow_name );
	return 0 if not $dow == $self->day_of_week_index( $iso_date );
	# time
	return 0 if not $self->valid_time( $time );
	1;  # if still here then date is valid
}

=head4 empty()

Determines whether item is empty.  This requires the following items to be undefined: filepath, duration, size, mime type, title, author, summary, explicit and publication date.

Parameters: [ 0 = class ].

Return type: Boolean.

=cut

sub empty {
	my ( $self ) = ( shift );
	# check that elements are undefined
	return undef if $self->filepath();
	return undef if $self->duration();
	return undef if $self->size();
	return undef if $self->type();
	return undef if $self->title();
	return undef if $self->author();
	return undef if $self->summary();
	return undef if $self->pubdate();
	# return success if till here
	1;
}

=head4 complete()

Determines whether item is complete.  This requires:

	- all of the following items: filepath, guid, duration, size, mime type, title, author, summary, explicit and publication date,
	- explicit is set to 'yes', 'clean' or 'no',
	- mime type is either 'audio/mp3' or 'audio/mpeg', and
	- publication date is in RFC 2822 format.

Parameters: [ 0 = class ].

Return type: Boolean.

=cut

sub complete {
	my ( $self ) = ( shift );
	# check that all elements are present
	return undef if not $self->filepath();
	return undef if not $self->guid();
	return undef if not $self->duration();
	return undef if not $self->size();
	return undef if not $self->type();
	return undef if not $self->title();
	return undef if not $self->author();
	return undef if not $self->summary();
	return undef if not $self->explicit();
	return undef if not $self->pubdate();
	# check explicit setting
	return undef if not $self->valid_explicit();
	# check mime type
	return undef if not $self->audio_mime_type();
	# check publication date
	return undef if not $self->valid_pubdate();
	1;  # return sucess if till here
}

=head4 why_incomplete()

Returns list of reasons why item is incomplete.

Does not check whether item is complete -- it is presumed the 'complete' method has already determined this.  It is therefore possible for this function, if improperly called on a complete item, to return an empty list.

See 'complete' method for the requirements of a complete item.

Parameters: [ 0 = class ].

Return type: List reference (one line per element, newline end each line).

=cut

sub why_incomplete {
	my ( $self , @ret ) = ( shift );
	# check that all elements are present
	push( @ret , "no filepath\n" ) if not $self->filepath();
	push( @ret , "no item GUID\n" ) if not $self->guid();
	push( @ret , "no track duration\n" ) if not $self->duration();
	push( @ret , "no file size\n" ) if not $self->size();
	push( @ret , "no mime type\n" ) if not $self->type();
	push( @ret , "no title\n" ) if not $self->title();
	push( @ret , "no author\n" ) if not $self->author();
	push( @ret , "no summary\n" ) if not $self->summary();
	push( @ret , "no explicit setting\n" ) if not $self->explicit();
	push( @ret , "no publication date\n" ) if not $self->pubdate();
	# check explicit setting
	if ( $self->explicit() ) {
		if ( not $self->valid_explicit() ) {
			push( @ret , "invalid explicit seting '" . $self->explicit() . "'\n" );
		}
	}
	# check mime type
	if ( $self->type() ) {
		if ( not $self->audio_mime_type() ) {
			push( @ret , "invalid mime type '" . $self->type() . "'\n" );
		}
	}
	# check publication date
	if ( $self->pubdate() ) {
		if ( not $self->valid_pubdate() ) {
			push( @ret , "invalid publication date '" . $self->pubdate() . "'\n" );
		}
	}
	# return result
	\@ret;
}

=head4 clear()

Clear all values from item.

Parameters: [ 0 = class ].

Return type: N/A.

=cut

sub clear {
	my ( $self ) = ( shift );
	# check that all elements are present
	$self->set_filepath( undef );  # also clears guid, duration, size and type
	$self->set_title( undef );
	$self->set_author( undef );
	$self->set_summary( undef );
	$self->set_explicit( 'no' );
	$self->set_pubdate( undef );
}


=head1 PACKAGE: DnRss

An internal package encapsulating methods and data for manipulating an rss feed.  Incorporates rss feed and its consituent channel.

=cut

package DnRss;

use strict;
use warnings;
use parent qw/ Dn::PodcastsRss /;

our $VERSION = '0.1';

use constant TRUE => 1;
use constant FALSE => 0;

# file used to store object state between invocations
use constant STORE_state => '@stored_state@';
use constant STORE_initial => '@initial_state@';

=head2 Dependencies

The following perl modules are required:

=head3 XML::Dumper

Used to save object state to xml file.

Debian: provided by package 'libxml-dumper-perl'.

=cut

use XML::Dumper;
my $dump = new XML::Dumper;

=head2 Methods

=head3 Data Members

%self = (

	'attributes'  =>  (
	
		'base_url'        =>  (

			'value'     =>  "<basename>" ,

			'options'   =>  [ "<option1>" , "<option2>" , ... ] ,

			'required'  =>  <Boolean> ,

			'help'      =>  [ "<line1>" , "<line2>" , ... ] ,

		) ,

		'title'           =>  ( ATTRIBUTE ) ,

		'author'          =>  ( ATTRIBUTE ) ,

		'summary'         =>  ( ATTRIBUTE ) ,

		'image'           =>  ( ATTRIBUTE ) ,

		'pubdate_method'  =>  ( ATTRIBUTE ) ,

		'sequence'        =>  ( ATTRIBUTE ) ,

		'exclude'         =>  ( ATTRIBUTE ) ,
			
	) ,

	'items'  =>  (
	
		'file_attributes'  =>  (
		
			'series'      =>  ( ATTRIBUTE ) ,

			'episode'     =>  ( ATTRIBUTE ) ,
	
			'disc'        =>  ( ATTRIBUTE ) ,
	
			'part'        =>  ( ATTRIBUTE ) ,
	
			'track'       =>  ( ATTRIBUTE ) ,
	
			'file_mask'   =>  ( ATTRIBUTE ) ,
	
			'title_mask'  =>  ( ATTRIBUTE ) ,
	
			'performer'   =>  ( ATTRIBUTE ) ,

			'author'      =>  ( ATTRIBUTE ) ,
	
			'description' =>  ( ATTRIBUTE ) ,
	
			'genre'       =>  ( ATTRIBUTE ) ,

			'album'       =>  ( ATTRIBUTE ) ,
	
			'year'        =>  ( ATTRIBUTE ) ,
	
			'increment'   =>  ( ATTRIBUTE ) ,

			'sequence'    =>  ( ATTRIBUTE ) ,

			'exclude'     =>  ( ATTRIBUTE ) ,
			
		) ,
	
		'other_attributes'  =>  (

			$filename1  =>  (
			
				'pubdate'  =>  "<iso_date>" ,

			) ,

			... ,

		) ,

	) ,

	'flags'  =>  (
	
		'all_podcasts'  =>  "<boolean>" ,
	
	) ,

)

=cut

sub new {
	my $proto = shift;
	my $class = ref($proto) || $proto;
	my $self  = {};
	if ( -e STORE_state ) {  # load current state
		$self = $dump->xml2perl( STORE_state );
	} elsif ( -e STORE_initial ) {  # load default initial state
		$self-> $dump->xml2perl( STORE_initial );
	} else {
		print "could not locate initial state storage file\n";
		printf "  '%s'\n" , STORE_initial;
		die "aborting\n";
	}

=over

=item

B<attributes>

Attributes of rss feed and channel required to create output files.

=over

=item

B<attributes>-E<gt>B<base_url>

Base url to prepend to all file paths, including items and channel image.

=item

B<attributes>-E<gt>B<title>

Channel title.

=item

B<attributes>-E<gt>B<author>

Channel author.

=item

B<attributes>-E<gt>B<summary>

Channel summary.

=item

B<attributes>-E<gt>B<image>

Filepath of channel image.  The Apple specification requires the image to be of type jpg or png.  Base url will be prepended to this filepath when outputting.

=item

B<attributes>-E<gt>B<pubdate-method>

Method by which publication date is assigned to channel items (podcast files).  Options are 'descend' (used for discrete set of podcasts such as an audiobook), 'ascend' (used for ongoing podcasts), and 'provide' (where users manually assign pubdates).

=item

B<attributes>-E<gt>B<sequence>

The order in which attributes are listed when editing.  A space-delimited list.  Attributes not included are listed after specified attributes.

=item

B<attributes>-E<gt>B<exclude>

Attributes not to include for editing.  A space-delimited list.  The script will let you add 'exclude' to the list but will always display it for editing, otherwise the user could never again change the exlusion list!

=back

=item

B<items>

Information pertaining explicitly to the channel items, i.e., podcast files.

=over

=item

B<items>-E<gt>B<file_attributes>

Channel item, i.e., podcast, attributes that are stored in the audio file itself.  These attributes are stored either in the file name or in audio file tags.  Some attributes (increment, sequence and exclude) control how other attributes are displayed.  Some attributes (album and year) enable alteration of audio file tags but are not actually used in generating rss feeds -- they are included here only as a convenience.

=over

=item

B<items>-E<gt>B<file_attributes>-E<gt>B<series>

Series number.  Value may be used in file name or audio file title tag.

=item

B<items>-E<gt>B<file_attributes>-E<gt>B<episode>

Episode number.  Value may be used in file name or audio file title tag.

=item

B<items>-E<gt>B<file_attributes>-E<gt>B<disc>

Disc number.  Value may be used in file name or audio file title tag.  Also used to set ID3 frame 'disk number'.

=item

B<items>-E<gt>B<file_attributes>-E<gt>B<part>

Part number.  Value may be used in file name or audio file title tag.

=item

B<items>-E<gt>B<file_attributes>-E<gt>B<track>

Track number.  Value may be used in file name or audio file title tag.  Also used to set audio file track number tag.

=item

B<items>-E<gt>B<file_attributes>-E<gt>B<file_mask>

Mask for audio file name.  Must be in lowercase.  Can use the following tokens:

	%S = series number,
	%E = episode number,
	%D = disc number,
	%P = part number, and
	%T = track number.

=item

B<items>-E<gt>B<file_attributes>-E<gt>B<title_mask>

Mask for file name.  Can contain any characters.  Can use same tokens available to the file mask.  Corresponds to ID3 tag 'title'.

=item

B<items>-E<gt>B<file_attributes>-E<gt>B<performer>

Podcast artist.  Used to set ID3 tag 'artist'.

=item

B<items>-E<gt>B<file_attributes>-E<gt>B<author>

Podcast author.  Used to set ID3 frame 'TCOM'.

=item

B<items>-E<gt>B<file_attributes>-E<gt>B<description>

Summary of individual podcast.  Corresponds to ID3 tag 'comment'.

=item

B<items>-E<gt>B<file_attributes>-E<gt>B<genre>

Podcast genre.  Corresponds to ID3 tag 'genre'.  Is set to 'Podcast' by default -- this helps some mp3 devices to treat these podcasts correctly, even though this value is not one of the genres defined in the ID3 specification.

=item

B<items>-E<gt>B<file_attributes>-E<gt>B<album>

Podcast album title.  Corresponds to ID3 tag 'album'.  Not used in creating rss feed but included as a convenience feature.

=item

B<items>-E<gt>B<file_attributes>-E<gt>B<year>

Podcast year of publication.  Corresponds to ID3 tag 'year'.  Not used in creating rss feed but included as a convenience feature.

=item

B<items>-E<gt>B<file_attributes>-E<gt>B<increment>

Those values to incremented by one between edits.  Is useful only with numeric values.  It has no effect on non-numeric values.  An empty/undefined value is *not* incremented to one.  Most commonly used with series, episode, disc, part, and track.

=item

B<items>-E<gt>B<file_attributes>-E<gt>B<sequence>

As described for attributes-E<gt>sequence.

=item

B<items>-E<gt>B<file_attributes>-E<gt>B<exclude>

As described for attributes-E<gt>exclude.

=back

=item

B<items>-E<gt>B<other_attributes>

Other attributes for channel items, i.e., podcast files, that are not stored as attributes of the file itself.  This is currently only publication date (pubdate).  The data item consists of a hash of podcast filenames.  Each filename key points to another hash, currently containing one key: pubdate.

=back

=item

B<flags>

Various flags that are set by user options or internal script events.  Each has a boolean value.

=over

=item

B<flags>-E<gt>B<all_podcasts>

Whether to process all podcast files (true) or only new podcast files (false, default).

=back

=back

=cut

}

=head3 Constructors

There is a single method signature that does not accept any arguments:

	my $ojb = new DnChannel;  OR  my $ojb = DnChannel->new();

User entered data is stored by the script between invocations.  Some data is stored in podcast file mp3 tags.  The remaining user-entered information is stored in a persistent file called '@stored_state@'.  While this file is in human readable xml, edit it manually with greate care and at your own risk.  It is far safer to let the script manipulate it.  If the file is deleted or renamed the script will require the data to be re-entered.

The constructor will look in the current directory for '@stored_state@'.  If found it will take the file's stored object and use it to populate this object.

If no stored data file is found in the current directory the constructor initialises the object with default data loaded from /usr/share/@pkg@/@initial_state@.

=cut

	bless ( $self , $class );
	return $self;
}

=head3 Setters

There are no setters for attributes as they are set by other methods that act generically upon attribute hash structures.

	$c->set_all_podcasts( '<boolean>' );

=cut

sub set_all_podcasts { $_[0]->{'flags'}->{'all_podcasts'} = $_[1]; }

=head3 Getters

There are no getters for individual item attributes.

	$c->attributes();  # hashref
	$c->base_url();
	$c->title();
	$c->author();
	$c->summary();
	$c->image();
	$c->pubdate_method();
	$c->item_attributes();  # hashref

=cut

sub attributes      { $_[0]->{'attributes'};                     }
sub base_url        { $_[0]->{'attributes'}->{'base_url'};       }
sub title           { $_[0]->{'attributes'}->{'title'};          }
sub author          { $_[0]->{'attributes'}->{'author'};         }
sub summary         { $_[0]->{'attributes'}->{'summary'};        }
sub image           { $_[0]->{'attributes'}->{'image'};          }
sub pubdate_method  { $_[0]->{'attributes'}->{'pubdate_method'}; }
sub item_attributes { $_[0]->{'items'};                          }
sub all_podcasts    { $_[0]->{'flags'}->{'all_podcasts'};        }

=head3 Other

=head4 set_channel_attributes()

Set channel attributes.

Parameters: [ 0 = class ].

Return type: N/A.

=cut

sub set_channel_attributes {
	my ( $self ) = ( shift );
	$self->set_attributes( $self->attributes() );
}

=head4 list_input_files()

Lists the filenames used for the following input files:

	channel metadata input file,
	podcasts metadata input file, and
	published podcasts input file.	

Parameters: [ 0 = class ].

Return type: N/A.

=cut

sub list_input_files {
	my ( $self ) = ( shift );
	printf "Channel metadata input file is '%s'\n" , $self->metadata_file();
	printf "Podcasts metadata input file is '%s'\n" , $self->podcasts_file();
	printf "Published podcasts input file is '%s'\n" , $self->published_file();
	exit TRUE;
}

=head4 xml()

Prints xml tree for feed.  Here is example output:

	<channel>
		<title><![CDATA[Political Incorrections]]></title>
		<language>en</language>
		<itunes:author>Bill Maher</itunes:author>
		<itunes:summary><![CDATA[Compilation of highlights from "Politically Incorrect", a late-night, half-hour political talk show hosted by Bill Maher that ran from 1993 to 2002. The show aired on Comedy Central from 1993 to 1996 and on ABC from 1997 to 2002.]]></itunes:summary>
		<description><![CDATA[Compilation of highlights from "Politically Incorrect", a late-night, half-hour political talk show hosted by Bill Maher that ran from 1993 to 2002. The show aired on Comedy Central from 1993 to 1996 and on ABC from 1997 to 2002.]]></description>
		<itunes:image href="http://localhost/podcasts/pol-inc/bill-maher.jpg"/>
		<itunes:category text="Comedy"/>
		<item>
			<title><![CDATA[01 Political Incorrections]]></title>
			<SNIP/>
			<itunes:keywords><![CDATA[politics satire]]></itunes:keywords>
		</item>
	</channel>

The base url is prepended to all urls in channel and subsidiary items.

Parameters: [ 0 = class ] , 1 = tabs.

Return type: List reference (one line per element).

=cut

sub xml {
	my ( $self , $tab_count , @xml , $tabs ) = ( shift , shift , () , "" );
	$tab_count = 0 if not $tab_count;
	$tabs .= "\t" foreach ( 1..$tab_count );
	# need to entitise (sub)categories
	my $cat = $self->entitise( $self->category() );
	my $subcat = $self->entitise( $self->subcategory() );
	# time to output
	push @xml , "$tabs<channel>\n";
	push @xml , sprintf( "$tabs\t<title>%s</title>\n" ,
		                 $self->title() );
	push @xml , sprintf( "$tabs\t<language>%s</language>\n" , 
		                 $self->language() );
	push @xml , sprintf( "$tabs\t<itunes:author>%s</itunes:author>\n" ,
	                     $self->author() );
	push @xml , sprintf( "$tabs\t<itunes:summary>%s</itunes:summary>\n" ,
	                     $self->summary() );
	push @xml , sprintf( "$tabs\t<description>%s</description>\n" ,
	                     $self->summary() );
	push @xml , sprintf( "$tabs\t<itunes:image href=\"%s/%s\"/>\n" ,
	                     $self->base_url() , $self->image() );
	if ( $subcat ) {
		push @xml , sprintf( "$tabs\t<itunes:category text=\"%s\">\n" ,
			                 $cat );
		push @xml , sprintf( "$tabs\t\t<itunes:category text=\"%s\"/>\n" ,
			                 $subcat );
		push @xml , "$tabs\t</itunes:category>\n";
	} else {
		push @xml , sprintf( "$tabs\t<itunes:category text=\"%s\"/>\n" ,
			                 $cat );
	}
	push @xml , sprintf( "$tabs\t<itunes:explicit>%s</itunes:explicit>\n" ,
	                     $self->explicit() );
	# print out all the items
	my @items = @{ $self->items() };
	for my $item ( @items ) {
		push @xml , @{ $item->xml( $self->base_url() , $tab_count + 1 ) };
	}
	# finish off the channel and return it
	push @xml , "$tabs</channel>\n";
	\@xml;
}

=head4 unpublished_podcasts()

Gets list of unpublished podcasts in the current directory.  To do this a list of podcasts in the current directory is obtained -- these are files of type mp3.  Then a list of already published files is obtained from the published podcasts file.  Those podcasts not listed as already published are deemed to be unpublished.

A podcast listed in the published podcasts file but not present in the directory triggers a warning but does not halt processing.

Parameters: [ 0 = class ].

Return type: List reference.

=cut

sub unpublished_podcasts {
	my ( $self , %published , %podcasts ) = ( shift );
	# first get all podcasts in directory
	$podcasts{$_} = 1 foreach @{ $self->podcast_files() };
	# now get all published podcasts
	my $publish_file = $self->published_file();
	$self->write_input_published;  # only if not found
	my @file_content = @{ $self->extract_file_data( $publish_file ) };
	$published{$_->{'key'}} = 1 foreach @file_content;
	# issue warning for each podcast listed as published
	# but not present in directory, i.e., "lost"
	my @published_lost = grep { not $podcasts{$_} } keys %published;
	if ( @published_lost ) {
		@published_lost = sort @published_lost;
		print "WARNING: listed as published but not found in directory:\n";
		print "  $_\n" foreach @published_lost;
		my $prep = ( $#published_lost > 1 ) ? 'them' : 'it';
		my $prompt = "remove $prep from published podcasts file?";
		if ( DnLib->new()->input_confirm( $prompt ) ) {
			# rewrite published input file without lost files
			delete $published{$_} foreach keys %published;
			$published{$_->{'key'}} = $_->{'value'} foreach @file_content;
			delete $published{$_} foreach @published_lost;
			my @output = @{ $self->published_input_template() };
			while ( my ( $file , $pubdate ) = each %published ) {
				push @output , sprintf( "%s %s\n" , $file , $pubdate );
			}
			$self->write_file( $publish_file , \@output );
			print "rewrote published podcast file without lost files\n";
		}
	}
	# get unpublished podcasts
	my @unpublished = grep { not $published{$_} } keys %podcasts;
	@unpublished = sort @unpublished;
	\@unpublished;
}

=head4 process_inputs()

Processes podcasts in current directory.  All podcasts in the directory not yet published are processed.

Whether a podcasts has been published or not is determined by whether the filename is or is not in the published podcasts input file.

Parameters: [ 0 = class ].

Return type: N/A.

=cut

sub process_inputs {
	my ( $self ) = ( shift );
	# first, get list of unpublished podcasts
	my @unpublished = @{ $self->unpublished_podcasts() };
	if ( not @unpublished ) {
		print "all podcast files have been published\n";
		return;
	}
	# extract values from podcasts input file
	# call sub that: creates file if none present
	#                extracts values and set self podcasts hash
	# call another sub that checks and sets podcast hash values
	#my $file_mask = 
	foreach my $file ( @unpublished ) {
		# start with file mask
	}
}

=head4 valid_categorisation()

Checks whether categorisation is valid.  The method will work with category only set, or with both category and subcategory set.

Any non-entitised ampersands are entitised before checking, i.e., '&' converted to '&amp;'.

Parameters: [ 0 = class ].

Return type: Boolean.

=cut

sub valid_categorisation {
	my ( $self ) = ( shift );
	# obtain (sub)category and categorisation scheme
	my $category = $self->entitise( $self->category() );
	return undef unless $category;
	my $subcategory = $self->entitise( $self->subcategory() );
	my %scheme = %{ $self->scheme() };
	# test category first
	return 0 unless exists $scheme{$category};  # fail if category invalid
	return 1 unless $subcategory;  # succeeded now if testing category only
	# then test subcategory (if supplied)
	exists $scheme{$category}{$subcategory};
}

=head4 valid_image_type()

Determines whether image mime type is valid.  Valid mime types are 'image/jpeg' and 'image/png'.

Parameters: [ 0 = class ].

Return type: Boolean.

=cut

sub valid_image_type {
	my $mime_type = $_[0]->mime_type( $_[0]->image() );
	grep /^$mime_type$/ , qw( image/jpeg image/png );
}

=head4 valid_language()

Determines whether language code is a valid ISO639 language identification code.

Parameters: [ 0 = class ].

Return type: Boolean.

=cut

sub valid_language { $_[0]->valid_iso639_code( $_[0]->language() ); }

=head4 valid_explicit()

Determines whether explicit setting is valid.  Valid settings are 'yes', 'clean' and 'no'.  This method accepts only these values although some systems will interpret any value other than 'yes' and 'clean' as 'no'.

Parameters: [ 0 = class ].

Return type: Boolean.

=cut

sub valid_explicit {
	my $explicit = $_[0]->explicit();
	grep /^$explicit$/ , qw( yes clean no );
}

=head4 empty()

Determines whether channel is empty.  This requires the following items to be undefined/empty: title, base url, author, summary, image, category, and no items.

Parameters: [ 0 = class ].

Return type: Boolean.

=cut

sub empty {
	my ( $self ) = ( shift );
	# check that all elements are present
	return undef if $self->title();
	return undef if $self->base_url();
	return undef if $self->author();
	return undef if $self->summary();
	return undef if $self->image();
	return undef if $self->category();
	return undef if @{ $self->items() };
	1;  # return success if still here
}

=head4 complete()

Determines whether channel is complete.  This requires:

	- all of the following items: title, base url, language, author, summary, image, category, optional subcategory, explicit setting and at least one item,
	- language is a complete ISO639 code,
	- complete explicit setting, 
	- image mime type is either 'image/jpeg' or 'image/png', and
	- complete categorisation.

Parameters: [ 0 = class ].

Return type: Boolean.

=cut

sub complete {
	my ( $self ) = ( shift );
	# check that all elements are present
	return undef if not $self->title();
	return undef if not $self->base_url();
	return undef if not $self->language();
	return undef if not $self->author();
	return undef if not $self->summary();
	return undef if not $self->image();
	return undef if not $self->category();
	return undef if not $self->explicit();
	return undef if not @{ $self->items() };
	# check image mime type
	return undef if not $self->valid_image_type();
	# check explicit setting
	return undef if not $self->valid_explicit();
	# check language
	return undef if not $self->valid_language();
	# check categorisation
	return undef if not $self->valid_categorisation();
	1;  # return success if still here
}

=head4 why_incomplete()

Returns list of why_incomplete, i.e., reasons why channel is not complete.

Does not check whether channel is complete -- it is presumed 'complete' method has already determined this.  It is therefore possible for this function, if improperly called on a complete channel, to return an empty list.

See 'complete' method for the requirements of a complete channel.

Parameters: [ 0 = class ].

Return type: List (one line per element, newline end each line).

=cut

sub why_incomplete {
	my ( $self , @ret ) = ( shift );
	# check that all elements are present
	push( @ret , "no title\n" ) if not $self->title();
	push( @ret , "no base_url\n" ) if not $self->base_url();
	push( @ret , "no language\n" ) if not $self->language();
	push( @ret , "no author\n" ) if not $self->author();
	push( @ret , "no summary\n" ) if not $self->summary();
	push( @ret , "no image\n" ) if not $self->image();
	push( @ret , "no category\n" ) if not $self->category();
	push( @ret , "no explicit\n" ) if not $self->explicit();
	push( @ret , "no items\n" ) if not @{ $self->items() };
	# check explicit setting
	if ( $self->explicit() ) {
		if ( not $self->valid_explicit() ) {
			push( @ret , "invalid explicit seting '" . $self->explicit() . "'\n" );
		}
	}
	# check image mime type
	if ( $self->image() ) {
		if ( not $self->valid_image_type() ) {
			push( @ret , "invalid image mime type\n" );
		}
	}
	# check language
	if ( $self->language() ) {
		if ( not $self->valid_language() ) {
			push( @ret , "invalid language '" . $self->language() . "'\n" );
		}
	}
	# check categorisation
	my $cat = $self->category();
	my $subcat = $self->subcategory();
	if ( $cat ) {
		if ( not $self->valid_categorisation() ) {
			push( @ret , "invalid categorisation (cat='" .
				  $cat . "', subcat = '" . $subcat . "')\n" );
		}
	}
	# return result
	\@ret;
}

=head4 clear()

Clear all values from item.

Parameters: [ 0 = class ].

Return type: N/A.

=cut

sub clear {
	my ( $self ) = ( shift );
	# check that all elements are present
	$self->set_title( undef );
	$self->set_base_url( undef );
	$self->set_language( 'en' );
	$self->set_author( undef );
	$self->set_summary( undef );
	$self->set_image( undef );
	$self->set_category( undef );
	$self->set_subcategory( undef );
	$self->set_explicit( 'no' );
	$self->set_items( () );
}

=head4 output_scheme()

Outputs the scheme in format suitable for printing.  Output is sorted (case-insensitive).  Ampersand entities are de-entitised, i.e., '&amp;' to '&'.

Output is in the form of a List.  There is one (sub)category per line with subcategories indented one tab.  All lines end with newlines.  The easiest way to use the output is something like:

	print $_ foreach $cat->output_scheme();

Parameters: [ 0 = class ].

Return type: List reference (one line per element, newlines end each line, categories are flush left and subcategories are indented one tab space).

=cut

sub output_scheme {
	# header
	print "RSS feed categorisation scheme\n";
	print "[categories and subcategories]\n";
	print "------------------------------\n";
	print "                              \n";
	# note both sorts are case insensitive
	my ( $self , @output ) = ( shift , () );
	my %scheme = %{ $self->scheme() };
	my @categories = sort { "\L$a" cmp "\L$b" } keys %scheme;
	foreach my $category ( @categories ) {
		$category =~ s/&amp;/&/g;
		push @output , $category . "\n";
		eval { my $throwaway = %{ $scheme{$category} } };  # error if this does not return hash
		if ( not $@ ) {  # '$@' holds error if eval failed
			my @subcategories = sort { "\L$a" cmp "\L$b" }
			                    keys %{ $scheme{$category} };
			foreach my $subcategory ( @subcategories ) {
				$subcategory =~ s/&amp;/&/g;
				push @output , "\t" . $subcategory . "\n";
			}
		}
	}
	\@output;
}

=head4 enter_metadata()

Prompts user to enter metadata values.  Accepts a simple key-value hash with existing or default values which the user has the option of changing or adding to.

Returns results in a hash compatible with method 'insert_values' (see that method for more information).

Because this method uses the 'datum' data members, you can obtain a result with:

	DnChannel->new( \%key_values )->enter_metadata();

Parameters: [ 0 = class ].

Uses data mambers: datum = key-value hash reference.

Return type: Hash reference.

=cut

sub enter_metadata {
	# set up variables
	my ( $self, %data , $msg , $key , @opts , $val , $default , @pubdates )
		= ( shift );
	my %supplied = ( $self->datum() ) ? %{ $self->datum() } : ();
	foreach ( keys %supplied ) {
		delete $supplied{$_} if not $supplied{$_};
	}
	$self->read_config_files( 'dn-podcasts-rss' );
	my $base_dir = $self->config_param( 'base-directory' );
	if ( $base_dir ) {
		if ( not -e $base_dir or not -d $base_dir ) {
			warn "Base directory '$base_dir' set in config file " .
				 "does not exist or is not a directory\n";
			$base_dir = undef;
		}
		$base_dir .= "/" if substr( $base_dir , -1 ) ne '/';
	}
	my $base_url = $self->config_param( 'base-url' );
	if ( $base_url ) {
		$base_url .= "/" if substr( $base_url , -1 ) ne '/';
	}

	# feed output base
	( $key , $default , $val ) = ( 'feed-output-base' , 'rss-feed' , undef );
	print <<END;
Feed output base
----------------
This is the basename of feed xml and opml files.  It should
not contain spaces.  An example is 'my-podcast-channel'.
The default is '$default'.
END
	if ( exists $supplied{$key} ) {
		$default = $supplied{$key};
		print "Existing feed output base: '$default'\n";
	}
	$val = $self->input_ask( 'Enter feed output base:' , $default );
	if ( $val ) {
		$data{$key}{'value'} = $val;
		print "Feed output base set to '$val'\n";
	} else {
		$data{$key}{'key'} = "#$key";
		warn "No feed output base set -- using default:\n  '$default'\n";
	}

	# channel title
	( $key , $default , $val ) = ( 'channel-title' , '' , undef );
	print <<END;

Channel title
-------------
Title of podcast, e.g., 'My Podcast Channel'.
END
	if ( exists $supplied{$key} ) {
		$default = $supplied{$key};
		print "Existing channel title: '$default'\n";
	}
	$val = $self->input_ask( 'Enter channel title:' , $default );
	if ( $val ) {
		$data{$key}{'value'} = $val;
		print "Channel title set to '$val'\n";
	} else {
		warn "No channel title set\n";
	}

	# channel-base-url
	( $key , $default , $val )
		= ( 'channel-base-url' , 'http://localhost/podcasts' , undef );
	my $url_dir;
	print <<END;

Channel base url
----------------
A url that will be prepended to all audio, image and xml
file urls in generated xml feed and opml files.
END
	if ( exists $supplied{$key} ) {
		$default = $supplied{$key};
		print "Existing channel base url: '$default'\n";
		if ( $self->input_confirm( "Keep existing channel base url?" ) ) {
			$val = $default;
		}
	}
	if ( not $val ) {
		if ( $base_dir ) {
			my @dirs = glob "$base_dir*";
			if ( @dirs ) {
				print "Displaying the contents of the configured " .
					  "podcast\ndirectory '$base_dir'\n";
				unshift @dirs ,
						substr( pop @dirs , length $base_dir )
							for 0..$#dirs;
				$url_dir = $self->input_choose(
					'Select the podcast directory:' ,
					@dirs
				);
				if ( $url_dir and $base_url ) {
					print "Combining selected directory with configured\n" .
						  "url base '$base_url'\n" .
						  "to obtain default channel base url\n";
					$default = $base_url . $url_dir;
				}
			}  # if ( @dirs )
		}  # if ( $base_dir )
		$val = $self->input_ask( 'Enter channel base url:' , $default );
	}  # if ( not $val )
	if ( $val ) {
		$data{$key}{'value'} = $val;
		print "Channel base url set to:\n  '$val'\n";
	} else {
		$data{$key}{'value'} = $default;
		warn "No url entered -- using default:\n  '$default'\n";
	}

	# channel language
	( $key , $default , $val ) = ( 'channel-language' , 'en' , undef );
	print <<END;

Channel language
----------------
The language used in the podcast.  More specifically, it is
a two-letter code as specified in ISO 639.
The default is '$default' (English).
END
	if ( exists $supplied{$key} ) {  # can use existing if supplied
		print "Existing channel language: '$supplied{$key}'\n";
		$val = $supplied{$key}
			if $self->input_confirm( 'Keep existing channel language?' );
	}
	if ( not $val ) {  # next step, try for default English
		$val = $default 
			if $self->input_confirm( 'Is the podcast language English?' );
	}
	if ( not $val ) {  # okay then, now must pick from whole list
		my $code = $self->codify_iso639_lang(
			$self->input_choose( 'Select language:' ,
			                     @{ $self->all_iso639_langs() }
			)
		);
		if ( $code ) {
			$val = $code;
			print "Using channel language code '$code'\n";
		} else {
			$val = $default;
			print "No language selected -- using default code '$default'\n";
		}
	}
	$data{$key}{'value'} = $val;

	# channel author
	( $key , $default , $val ) = ( 'channel-author' , '' , undef );
	print <<END;

Channel author
--------------
The author, artist or performer of channel content.
END
	if ( exists $supplied{$key} ) {
		$default = $supplied{$key};
		print "Existing channel author: '$default'\n";
	}
	$val = $self->input_ask( 'Enter channel author:' , $default );
	if ( $val ) {
		$data{$key}{'value'} = $val;
		print "Channel author set to '$val'\n";
	} else {
		warn "No channel author set\n";
	}

	# channel summary
	( $key , $default , $val ) = ( 'channel-summary' , '' , undef );
	print <<END;

Channel summary
--------------
A description of the channel's contents.  While an importer
will take the entire value, the specification limits this
value to 4000 characters and some aggregators may truncate
beyond this limit or reject the channel entirely.
This value is also used as a channel description tag.
END
	if ( exists $supplied{$key} ) {
		$default = $supplied{$key};
		print "There is an existing channel summary\n";
	}
	$msg = 'Enter channel summary:';
	$val = join " " , split( "\n" , $self->input_large( $msg , $default ) );
	if ( $val ) {
		$data{$key}{'value'} = $val;
		print "Channel summary set to:\n  '$val'\n";
	} else {
		warn "No channel summary set\n";
	}

	# channel image
	( $key , $val ) = ( 'channel-image' , undef );
	print <<END;

Channel image
-------------
The file path of an image file.  It is used by aggregators
when displaying the rss channel.  It must be the file path
from the working directory when the dn-podcasts-rss script is
run.  It must not include "pseudo-directories" such as './'
and '../'.
During rss feed and opml file output the base url will be
prepended to this path.
Only jpg and png image types are supported.
END
	if ( exists $supplied{$key} and -e $supplied{$key} ) {  # existing
		$default = $supplied{$key};
		print "Existing image file: '$default'\n";
		$val = $default if $self->input_confirm( 'Keep existing image file?' );
	}
	if ( not $val ) {  # pick from image files in directory
		my @all_files = glob "*";
		my @images;
		for ( @all_files ) {
			my $channel = DnChannel->new();
			$channel->set_image( $_ );
			push @images , $_ if $channel->valid_image_type();
		}
		if ( scalar( @images ) == 1 ) {
			$val = $images[0] 
				if $self->input_confirm( sprintf "Use '%s'?" , $images[0] );
		} elsif ( scalar( @images ) > 1 ) {
			$val = $self->input_choose( "Select image ['q' to quit]" , @images );
		}
	}
	if ( not $val ) {  # last chance: enter manually
		$val = $self->input_ask( 'Enter image filepath:' );
	}
	if ( $val ) {
		$data{$key}{'value'} = $val if $val;
		print "Channel image set to '$val'\n";
	} else {
		warn "No channel image set\n";
	}

	# channel category
	my ( $use_existing_cat , $category , $subcategory ) = ( FALSE );
	my %scheme = %{ DnChannel->new()->scheme() };
	print <<END;

Channel category
----------------
The RSS xml feed specification includes a two-level
classification scheme with category and sub-category.
Depending on the classification you may need to specify
category only, or both category and subcategory.
END
	if ( exists $supplied{'channel-category'} ) {
		my ( $def_cat , $def_subcat ) = ( $supplied{'channel-category'} ,
			$supplied{'channel-subcategory'} );
		$msg = $def_cat . ( ( $def_subcat ) ? " => $def_subcat" : '' );
		print "Existing categorisation: $msg\n";
		if ( $self->input_confirm( 'Keep existing categorisation?' ) ) {
			( $category , $subcategory ) = ( $def_cat , $def_subcat );
			$use_existing_cat = TRUE;
		}
	}
	if ( not $category ) {
		$category = $self->input_choose( 'Select category:' ,
		                                 sort( keys %scheme ) );
		warn "No category set\n" if not $category;
	}

	# channel subcategory
	( $key ) = ( 'channel-subcategory' );
	if ( $category and not $use_existing_cat ) {  # assume $category is valid
		if ( $scheme{$category} ) {
			$subcategory = $self->input_choose(
				'Select subcategory:' ,
				sort( keys %{ $scheme{$category} } )
			);
			if ( not $subcategory ) {
				warn "Channel not categorised\n";
				$category = undef;
			}
		} else {
			$data{$key}{'key'} = "#$key";
			printf "No subcategory needed for category '%s'\n" ,
			       $self->deentitise( $category );
		}  # if ( $scheme{$category} )
	}  # if ( $category )
	if ( $category ) {
		$data{'channel-category'}{'value'} 
			= $self->deentitise( $category );
		printf "Category set to '%s'\n" ,
		      $self->deentitise( $category );
		if ( $subcategory ) {
			$data{'channel-subcategory'}{'value'} 
				= $self->deentitise( $subcategory );
			printf "Subcategory set to '%s'\n" ,
				  $self->deentitise( $subcategory );
		}
	}

	# channel explicit
	( $key , $default , $val ) = ( 'channel-explicit' , 'no' , undef );
	print <<END;

Channel explicit
----------------
This value indicates to aggregators whether the podcast
channel contains explicit content.
There are three values.
 yes:   indicates explicit content,
 clean: no explicit content and aggregators may declare so,
 no:    no explicit content but aggregators will not
        declare so.
The default is '$default'.
END
	if ( exists $supplied{$key} ) {  # can keep existing
		print "Existing explicitness: '$supplied{$key}'\n";
		$val = $supplied{$key} 
			if $self->input_confirm( 'Keep existing explicitness?' );
	}
	if ( not $val ) {  # alright, then choose new one
		@opts = qw/ no clean yes /;
		$val = $self->input_choose( 'Select channel explicit:' , @opts );
	}
	if ( $val ) {
		$data{$key}{'value'} = $val;
		print "Channel explicit set to '$val'\n";
	} else {
		warn "No channel explicit set\n";
	}

	# pubdate method
	( $key , $default , $val ) = ( 'pubdate-method' , '' , undef );
	my ( $method ) = ( undef );
	print <<END;

Pubdate method
--------------
Indicates how podcast publication dates will be selected.
There are three values:
 descend: use for discrete set of podcasts, i.e., an audiobook,
 ascend: for ongoing titles,
 provide: means pubdates are supplied in this metadata file
          using 'pubdate' keys.
END
	if ( exists $supplied{$key} ) {
		$default = $supplied{$key};
		print "Existing pubdate method: '$default'\n";
		$val = $default 
			if $self->input_confirm( 'Keep existing pubdate method?' );
	}
	if ( not $val ) {
		@opts = qw/ descend ascend provide /;
		$val = $self->input_choose( 'Select pubdate method' , @opts );
	}
	if ( $val ) {
		$data{$key}{'value'} = $val;
		print "Pubdate method set to '$val'\n";
		$method = $val;
	} else {
		warn "No pubdate method set\n";
	}

##	# pubdate
##	if ( $method eq 'provide' ) {
##		( $key , $val ) = ( 'pubdate' , undef );
##		print <<END;
##
##Pubdates
##--------
##Provide podcast dates in the same order as podcast files
##are listed by the perl 'glob' function.  Each publication
##date you supply is a value for the key 'pubdate'.
##Enter each date in ISO format 'yyy-mm-dd'.
##Dates will be converted to the RFC 2822 format required by
##aggregators.
##Enter an empty pubdate to finish entering pubdates.
##END
##		while ( 1 ) {
##			$val = $self->input_ask( 'Enter pubdate:' );
##			last if not $val;
##			if ( $self->valid_date( $val ) ) {
##				my $rfc_date = DnLib->new( $val )->iso_to_rfc2822();
##				if ( grep $rfc_date eq $_ , @pubdates ) {
##					warn "Pubdate '$val' already added\n";
##				} else {
##					push @pubdates , $rfc_date;
##				}
##			} else {
##				warn "Invalid iso-format date '$val'\n";
##			}
##		}
##		if ( @pubdates ) {
##			print "Set the following pubdates:\n";
##			print "  $_\n" foreach @pubdates;
##		} else {
##			warn "No pubdates set\n";
##		}
##	}  # if ( $method eq 'provide' )
	print "\n";
	# return results
	\%data;
}

=head4 validate_metadata()

Takes (reference to) data extracted by method 'extract_file_data' and checks whether it is a valid set of metadata, as supplied by a input metadata file.  See method 'extract_file_data' for the data structure it supplies.

The metadata set must be complete -- all required keys must be provided and no provided key can have an empty value.

The following checks are performed: 

	sanity checks on constrained keys
		that all constrained key names are valid
		that all constrained keys have associated allowed values
	no invalid keys
	all required keys are present
	all provided keys have a non-empty value
	no singular keys are duplicated
	all constrained keys have a valid value
	no pubdates provided unless 'pubdate-method' is 'provide'
	language, image and category/subcategory are valid
	dates are valid

The script dies if a check fails.

Because this method uses the 'datum' data members, you can obtain a result with:

	DnChannel->new( \@metadata )->validate_metadata();

Parameters: [ 0 = class ].

Uses data mambers: datum = metadata array reference.

Return type: N/A.

=cut

sub validate_metadata {
	# set up variables
	my ( @keys , @valid_keys, $msg  );
	my @data = @{ $_[0]->datum() };
	die "No metadata supplied for verification\n" if not @data;
	push @keys , $_->{'key'} foreach @data;
	my @required_keys = qw/ channel-title channel-base-url
	                        channel-author channel-summary 
	                        channel-image channel-category 
	                        pubdate-method /;
	my @optional_keys = qw/ feed-output-base channel-language
	                        channel-subcategory channel-explicit
	                        pubdate /;
	my @singular_keys = qw/ feed-output-base channel-title 
	                        channel-base-url channel-language
	                        channel-author channel-summary
	                        channel-image channel-category
	                        channel-subcategory channel-explicit
	                        pubdate-method /;
	push @valid_keys , @required_keys , @optional_keys;
	die "No valid keys supplied to validator\n" if not @valid_keys;
	my %constrained_values = ( 
		'channel-explicit' => [ 'yes' , 'no' , 'clean' ] ,
		'pubdate-method'   => [ 'descend' , 'ascend' , 'provide' ] ,
	);
	foreach ( keys %constrained_values ) {
		my $key = $_;
		$msg = "List of constrained keys includes '$key' " .
		       "which is not a valid key";
		die "$msg\n" if not grep /^$key$/ , @valid_keys;
		my @allowed_values = @{ $constrained_values{$key} };
		if ( not @allowed_values ) {
			$msg = "No allowed values defined for constrained " .
				   "metadata key '$key'";
			die "$msg\n";
		}
	}
	my @valueless_keys = qw/ item-start /;
	# now for validity checks
	# check: ensure no invalid keys
	foreach ( @data ) {
		my ( $key , $line ) = ( $_->{'key'} , $_->{'line'} );
		if ( not grep /^$key$/ , @valid_keys ) {
			$msg = sprintf "Invalid metadata key '%s' at line %s" ,
			               $key , $line;
			die "$msg\n" if not grep /^$key$/ , @valid_keys;
		}
	}
	# check: ensure all required keys are supplied
	foreach ( @required_keys ) {
		my $key = $_;
		die "Missing required metadata key '$key'\n"
			if not grep /^$key$/ , @keys;
	}
	# check: ensure all provided keys have non-empty value
	foreach ( @data ) {
		my ( $key , $value , $line ) =
			( $_->{'key'} , $_->{'value'} , $_->{'line'} );
		if ( not $value ) {
			if ( not grep $key eq $_ , @valueless_keys ) {
				$msg = sprintf "No value provided for metadata key " .
				               "'%s' at line %s" , $key , $line;
				die "$msg\n";
			}
		}
	}
	# check: constrained keys have valid values
	foreach ( @data ) {
		my ( $key , $value , $line ) =
			( $_->{'key'} , $_->{'value'} , $_->{'line'} );
		if ( grep /^$key$/ , keys %constrained_values ) {
			my @allowed_values = @{ $constrained_values{$key} };
			if ( not grep /^$value$/ , @allowed_values ) {
				$msg = "Illegal value '$value' for constrained " .
				       "metadata key '$key' at line $line";
				die "$msg\n";
			}
		}
	}
	# check: no pubdates unless pubdate-method is 'provide'
	my ( $method , $method_line );
	foreach ( @data ) {
		( $method , $method_line ) = ( $_->{'value'} , $_->{'line'} )
			if $_->{'key'} eq 'pubdate-method';
	}
	my %key_count;  # will reuse this hash in duplication check
	$key_count{$_->{'key'}}++ foreach @data;
	if ( $method && $method ne 'provide' ) {
		$msg = sprintf( "Pubdates provided despite metadata" .
		                "pubdate-method\n  being set to '%s' at line %s" ,
		                $method , $method_line );
		die "$msg\n" if exists $key_count{'pubdate'};
	}
	# check: no duplication of singular keys
	foreach ( keys %key_count ) {
		delete $key_count{$_} if $key_count{$_} == 1;
	}
	foreach ( keys %key_count ) {
		my $key = $_;
		delete $key_count{$_} if not grep /^$key$/ , @singular_keys;
	}
	if ( %key_count ) {
		foreach ( keys %key_count ) {
			my ( $key , $first ) = ( $_ , TRUE );
			print "The metadata key '$key' should be singular but occurs\n";
			print "  on lines ";
			foreach ( @data ) {
				if ( $_->{'key'} eq $key ) {
					print ", " if not $first;
					$first = FALSE;
					print $_->{'line'};
				}
			}
			print "\n";
		}
		die "Illegal duplicate metadata key(s) present\n";
	}
	# check: channel values for language, image and category/subcategory
	#        note that channel value explicit is tested as constrained key
	my ( $category , $cat_line , $subcategory , $subcat_line );
	my ( $language , $lang_line , $image , $img_line );
	foreach ( @data ) {
		my $key = $_->{'key'};
		# switch: $key
		# case: 'channel-language'
		( grep $key eq $_ , qw/ channel-language / ) and do {
			( $language , $lang_line ) = ( $_->{'value'} , $_->{'line'} );
		};
		# case: 'channel-image'
		( grep $key eq $_ , qw/ channel-image / ) and do {
			( $image , $img_line ) = ( $_->{'value'} , $_->{'line'} );
		};
		# case: 'channel-category'
		( grep $key eq $_ , qw/ channel-category / ) and do {
			( $category , $cat_line ) = ( $_->{'value'} , $_->{'line'} );
		};
		# case: 'channel-subcategory'
		( grep $key eq $_ , qw/ channel-subcategory / ) and do {
			( $subcategory , $subcat_line ) = ( $_->{'value'} , $_->{'line'} );
		};
		# no default case because non-matching values ignored
		# endswitch
	}
	my $channel = DnChannel->new();
	if ( $language ) {  # optional
		$channel->set_language( $language );
		die "Invalid metadata language '$language'\n  at line $lang_line\n"
			unless $channel->valid_language();
	}
	$channel->set_image( $image );  # required
	$msg = "Invalid metadata image '$image' (not jpg or png)\n"
	     . "  at line $img_line";
	die "$msg\n" unless $channel->valid_image_type();
	$channel->set_category( $category );  # required
	$channel->set_subcategory( $subcategory ) if $subcategory;  # optional
	$msg = sprintf( "Invalid metadata categorisation '%s" ,
	                $self->deentitise( $category ) )
	     . ( ( $subcategory )
	         ? sprintf( "->%s" , $self->deentitise( $subcategory ) )
	         : "" )
	     . "'\n  at line"
	     . ( ( $subcategory ) ? "s" : "" )
	     . " $cat_line"
	     . ( ( $subcategory ) ? " and $subcat_line" : "" );
	die "$msg\n" unless $channel->valid_categorisation();
	# check: dates are valid
	foreach ( @data ) {
		my ( $key , $value , $line )
			= ( $_->{'key'} , $_->{'value'} , $_->{'line'} );
		if ( grep $key eq $_ , qw/ pubdate item-pubdate / ) {
			my $item = DnItem->new();
			$item->set_pubdate( $value );
			die "Invalid metadata date '$value' at line $line\n"
				unless $item->valid_pubdate();
		}
	}
}

=head4 pubdates()

Derives list of publication dates from metadata.

Assumes metadata has been validated, i.e., 'pubdate-method' key is present with a valid value, and any pubdates are in valid format.

Takes an array of mp3 files to be added to skeleton input file in order to know how many pubdates to return.  If 'pubdate-method' is 'descend or 'ascend' the pubdates are generated using the arbitrary start date of 2008-07-01.

If 'pubdate-method' is 'provide' then pubdates are harvested from 'pubdate' key-value pairs.  Excess pubdates are ignored.  Processing will halt with an error if there are fewer provided pubdates than mp3 files.

Note that metadata array contains anonymous hashes in a format specified in method 'extract_file_data'.

Because this method uses the 'datum' data members, you can obtain a result with:

	DnChannel->new( \@mp3_files , \@metadata )->pubdates();

Parameters: [ 0 = class ].

Uses data mambers: datum   = mp3 files array reference,
                   datum_1 = metadata array reference.

Return type: List reference.

=cut

sub pubdates {
	# set up variables
	my ( $self , @pubdates , %key_values , @provided , $method ) = ( shift );
	my $pubdate = join "-" , 2008 , 7 , 1;
	my @mp3s = @{ $self->datum() };
	my @data = @{ $self->datum_1() };
	die "No mp3files provided for pubdate derivation\n" if not @mp3s;
	die "No metadata supplied for pubdate derivation\n" if not @data;
	foreach ( @data ) {
		my ( $key , $value ) = ( $_->{'key'} , $_->{'value'} );
		$method = $value if $key eq 'pubdate-method';
		push( @provided , $value ) if $key eq 'pubdate';
	}
	die "No pubdate method" if not $method;
	# switch: $method
	# case: 'descend'
	( grep $method eq $_ , qw/ descend / ) and do {
		foreach ( @mp3s ) {
			push @pubdates , $self->assemble_iso_date( @pubdate );
			$pubdate = $self->previous_iso_day( $pubdate );
		}
	};
	# case: 'ascend'
	( grep $method eq $_ , qw/ ascend / ) and do {
		foreach ( @mp3s ) {
			push @pubdates , $self->assemble_iso_date( @pubdate );
			$pubdate = $self->next_iso_day( $pubdate );
		}
	};
	# case: 'provide'
	( grep $method eq $_ , qw/ provide / ) and do {
		push @pubdates , $_ foreach @provided;
		my $num_dates = scalar( @pubdates );
		my $num_mp3s = scalar( @mp3s );
		# not enough
		if ( $num_dates < $num_mp3s ) {
			print "Metadata file configures pubdates to be provided " .
			      "as metadata\n";
			print "Found $num_mp3s mp3 files so need $num_mp3s pubdates\n";
			die "Metadata file provides $num_dates pubdate(s)\n";
		}
		# too many
		if ( $num_dates > $num_mp3s ) {
			my $diff = $num_dates - $num_mp3s;
			warn "Have $num_dates pubdates for $num_mp3s mp3 files --\n" .
			     "  ignoring excess pubdate(s):\n";
			printf( "  %s\n" , pop @provided ) foreach 1..$diff;
		}
	};
	# case: default
	( not grep $method eq $_ , qw/ descend ascend provide / ) and do {
		die "Invalid pubdate-method '$method'";
	};
	# endswitch
	\@pubdates;
}

=head4 podcast_files()

Gets list of podcast files in directory.

Possible usage:

	my @mp3s = @{ DnChannel->new()->podcast_files() };

Parameters: [ 0 = class ].

Return type: List reference.

=cut

sub podcast_files {
	my @audio;
	for ( glob "*" ) {
		push @audio , $_ if DnItem->new( $_ )->audio_mime_type();
	}
	\@audio;
}

=head4 published_input_template()

Provides template for published podcasts input file as a List.

Parameters: [ 0 = class ].

Return type: List reference (each element is a line, each line terminated by newline).

=cut

sub published_input_template {
	[ (
		"# Published podcasts input file for dn-podcasts-rss\n" ,
		"\n" ,
		"# ********************************************************\n" ,
		"# This file contains a list of published podcast files and\n" ,
		"# their publication dates.\n" ,
		"# \n" ,
		"# You should not ever need to edit this file manually.\n" ,
		"# The script dn-podcasts-rss will maintain this file\n" ,
		"# automatically.\n" ,
		"# \n" ,
		"# Each line is a space-separated key-value pair:\n" ,
		"#   key   = file name\n" ,
		"#   value = publication date\n" ,
		"# \n" ,
		"# Note that the key -- the podcast filename -- cannot\n" ,
		"# contain a space since anything after the first space\n" ,
		"# is part of the value -- the publication date.\n" ,
		"# \n" ,
		"# The publication date is in iso format: 'yyyy-mm-dd'.\n" ,
		"# ********************************************************\n" ,
		"\n" ,
	) ];
}

=head4 write_input_published()

Creates published podcasts input file template in current directory if the file does not already exist.

A published podcasts input file lists all published podcasts and their publication dates.

Parameters: [ 0 = class ].

Return type: N/A.

=cut

sub write_input_published {
	my ( $self , %extracted , %existing ) = ( shift );
	my ( $filename ) = ( $self->published_file() );
	# get data if file already exists
	if ( not -e $filename ) {
		my @output = @{ $self->published_input_template() };
		$self->write_file( $filename , \@output );
	}
}
=head1 PACKAGE: DnChannel

An internal package encapsulating methods and data for manipulating an rss channel.

=cut

package DnChannel;

use strict;
use warnings;
use parent qw/ Dn::PodcastsRss /;

our $VERSION = '0.1';

use constant TRUE => 1;
use constant FALSE => 0;

=head2 Methods

=head3 Data Members

%self = (

	$title        =>  "<title>" ,

	$base_url     =>  "<url>" ,

	$language     =>  "<language>" ,

	$author       =>  "<author>" ,

	$summary      =>  "<summary>" ,

	$image        =>  "<filepath>" ,

	$category     =>  "<category>" ,

	$subcategory  =>  "<subcategory>" ,

	$explicit     =>  "'yes'|'clean'|'no'" ,

	@items        =>  [ %item , %item , ... ] ,

	%scheme       =>  (

		%category1  =>  (
		
			%subcategory1  =>  "" ,

			%subcategory2  =>  "" ,

			... ,
		
		) ,

		%category2  =>  (
		
			%subcategory3  =>  "" ,

			%subcategory4  =>  "" ,

			... ,
		
		) ,

	... ,

	) ,

	%podcasts     =>  (
	
		$file_mask  =>  "<filename_mask>" ,

		$title_mask =>  "<title_mask>" ,

		$series     =>  <series_number> ,

		$episode    =>  <episode_numbner> ,

		$disc       =>  <disc_numbner> ,

		$artist     =>  "<artist>" ,

		$composer   =>  "<composer>" ,

		$album      =>  "<album_title>" ,

		$year       =>  <year> ,

		$comment    =>  "<comment>" ,

		$genres     =>  "<genre_list>" ,
	
		$genre      =>  "<genre>" ,
	
	) ,

	%input_files  =>  (
	
		$metadata   =>  "<filename>" ,

		$podcasts   =>  "<filename>" ,

		$published  =>  "<filename>" ,

	) ,

)

Note: The unusual data structure for '%scheme' is due to the hashes having only keys and no values.  Not all categories have subcategories.

=cut

sub new {
	my $proto = shift;
	my $class = ref($proto) || $proto;
	my $self  = {};

=over

=item

B<title>

Channel title.

=cut

	$self->{'title'} = undef;

=item

B<base_url>

Base url to prepend to all file paths, including items and channel image.

=cut

	$self->{'base_url'} = undef;

=item

B<language>

Channel language.  The Apple RSS specification requires values from the ISO 639-1 Alpha-2 list (two-letter language codes, some with possible modifiers, such as "en-us").  Default language = 'en'.

=cut

	$self->{'language'} = 'en';

=item

B<author>

Channel author.

=cut

	$self->{'author'} = undef;

=item

B<summary>

Channel summary.

=cut

	$self->{'summary'} = undef;

=item

B<image>

Filepath of channel image.  The Apple specification requires the image to be of type jpg or png.  Base url will be prepended to this filepath when outputting.

=cut

	$self->{'image'} = undef;

=item

B<category>

Category of channel content.  The Apple specification defines a two-level category scheme.  See '%scheme' data member and 'valid_categorisation' method for further details.

=cut

	$self->{'category'} = undef;

=item

B<subcategory>

Subcategory of channel content.  Optional.  The Apple specification defines a two-level category scheme.  See '%scheme' data member and 'valid_categorisation' method for further details.

=cut

	$self->{'subcategory'} = undef;

=item

B<explicit>

Whether channel contains explicit content.  Values: 'yes'|'clean'|'no'.  Default = 'no'.

=cut

	$self->{'explicit'} = 'no';

=item

B<items>

The items, i.e., audio tracks, contained in the channel.  Presumed to be mp3/mpeg.

=cut

	$self->{'items'} = ();

=item

B<scheme>

Two-level categorical classification scheme given in Apple specification.  Here are the allowed categories:

=over

=item Arts

=over

=item Design

=item Fashion & Beauty

=item Food

=item Literature

=item Performing Arts

=item Visual Arts

=back

=item Business

=over

=item Business News

=item Careers

=item Investing

=item Management & Marketing

=item Shopping

=back

=item Comedy

=item Education

=over

=item Education Technology

=item Higher Education

=item K-12

=item Language Courses

=item Training

=back

=item Games & Hobbies

=over

=item Automotive

=item Aviation

=item Hobbies

=item Other Games

=item Video Games

=back

=item Government & Organizations

=over

=item Local

=item National

=item Non-Profit

=item Regional

=back

=item Health

=over

=item Alternative Health

=item Fitness & Nutrition

=item Self-Help

=item Sexuality

=back

=item Kids & Family

=item Music

=item News & Politics

=item Religion & Spirituality

=over

=item Buddhism

=item Christianity

=item Hinduism

=item Islam

=item Judaism

=item Other

=item Spirituality

=back

=item Science & Medicine

=over

=item Medicine

=item Natural Sciences

=item Social Sciences

=back

=item Society & Culture

=over

=item History

=item Personal Journals

=item Philosophy

=item Places & Travel

=back

=item Sports & Recreation

=over

=item Amateur

=item College & High School

=item Outdoor

=item Professional

=back

=item Technology

=over

=item Gadgets

=item Tech News

=item Podcasting

=item Software How-To

=back

=item TV & Film

=back

=cut

	$self->{'scheme'} = {
		"Arts" => {
			"Design" => "" ,
			"Fashion &amp; Beauty" => "" ,
			"Food" => "" ,
			"Literature" => "" ,
			"Performing Arts" => "" ,
			"Visual Arts" => "" ,
		} ,
		"Business" => {
			"Business News" => "" ,
			"Careers" => "" ,
			"Investing" => "" ,
			"Management &amp; Marketing" => "" ,
			"Shopping" => "" ,
		} ,
		"Comedy" => "" ,
		"Education" => {
			"Education Technology" => "" ,
			"Higher Education" => "" ,
			"K-12" => "" ,
			"Language Courses" => "" ,
			"Training" => "" ,
		} ,
		"Games &amp; Hobbies" => {
			"Automotive" => "" ,
			"Aviation" => "" ,
			"Hobbies" => "" ,
			"Other Games" => "" ,
			"Video Games" => "" ,
		} ,
		"Government &amp; Organizations" => {
			"Local" => "" ,
			"National" => "" ,
			"Non-Profit" => "" ,
			"Regional" => "" ,
		} ,
		"Health" => {
			"Alternative Health" => "" ,
			"Fitness &amp; Nutrition" => "" ,
			"Self-Help" => "" ,
			"Sexuality" => "" ,
		} ,
		"Kids &amp; Family" => "" ,
		"Music" => "" ,
		"News &amp; Politics" => "" ,
		"Religion &amp; Spirituality" => {
			"Buddhism" => "" ,
			"Christianity" => "" ,
			"Hinduism" => "" ,
			"Islam" => "" ,
			"Judaism" => "" ,
			"Other" => "" ,
			"Spirituality" => "" ,
		} ,
		"Science &amp; Medicine" => {
			"Medicine" => "" ,
			"Natural Sciences" => "" ,
			"Social Sciences" => "" ,
		} ,
		"Society &amp; Culture" => {
			"History" => "" ,
			"Personal Journals" => "" ,
			"Philosophy" => "" ,
			"Places &amp; Travel" => "" ,
		} ,
		"Sports &amp; Recreation" => {
			"Amateur" => "" ,
			"College &amp; High School" => "" ,
			"Outdoor" => "" ,
			"Professional" => "" ,
		} ,
		"Technology" => {
			"Gadgets" => "" ,
			"Tech News" => "" ,
			"Podcasting" => "" ,
			"Software How-To" => "" ,
		} ,
		"TV &amp; Film" => "" ,
	};

# the following bit of pod wizardry is a workaround, necessary because otherwise the 'podcasts' heading follow on from the scheme list without a blank line -- the reason for this strange follow on is unknown

=pod

Z<>

=item

B<podcasts>

Encpasulates information about podcasts in a directory and is intended to be used for standardising file names and mp3 tags.

=cut

	$self->{'podcasts'} = {};

=over

=item

B<podcasts>-E<gt>B<file_mask>

Mask for file name.  Must be in lowercase.  Can use the following tokens:

	%S = series number,
	
	%E = episode number, and
	
	%D = disc number.
	
=cut

	$self->{'podcasts'}->{'file_mask'} = undef;

=item

B<podcasts>-E<gt>B<title_mask>

Mask for file name.  Can contain any characters.  Can use same tokens available to the file mask.  Corresponds to mp3 tag 'title'.

=cut

	$self->{'podcasts'}->{'title_mask'} = undef;

=item

B<podcasts>-E<gt>B<series>

Current series number of podcast.

=cut

	$self->{'podcasts'}->{'series'} = undef;

=item

B<podcasts>-E<gt>B<episode>

Current episode number of podcast.

=cut

	$self->{'podcasts'}->{'episode'} = undef;

=item

B<podcasts>-E<gt>B<disc>

Current disc number of podcast.  Corresponds to ID3 frame 'disk number'.

=cut

	$self->{'podcasts'}->{'disc'} = undef;

=item

B<podcasts>-E<gt>B<artist>

Podcast artist.  Corresponds to ID3 tag 'artist'.

=cut

	$self->{'podcasts'}->{'artist'} = undef;

=item

B<podcasts>-E<gt>B<composer>

Current composer number of podcast.  Corresponds to ID3 frame 'TCOM'.

=cut

	$self->{'podcasts'}->{'composer'} = undef;

=item

B<podcasts>-E<gt>B<album>

Podcast album title.  Corresponds to ID3 tag 'album'.

=cut

	$self->{'podcasts'}->{'album'} = undef;

=item

B<podcasts>-E<gt>B<year>

Podcast year of publication.  Corresponds to ID3 tag 'year'.

=cut

	$self->{'podcasts'}->{'year'} = undef;

=item

B<podcasts>-E<gt>B<comment>

Podcast comment.  Corresponds to ID3 tag 'comment'.

=cut

	$self->{'podcasts'}->{'comment'} = undef;

=item

B<podcasts>-E<gt>B<genres>

List of ID3 genres.  [Source: id3.org].

=cut

	$self->{'podcasts'}->{'genres'} = [ (
		"Blues ", "Classic Rock", "Country", "Dance", "Disco", "Funk", "Grunge",
		"Hip-Hop", "Jazz", "Metal", "New Age", "Oldies", "Other", "Pop", "R&B",
		"Rap", "Reggae", "Rock", "Techno", "Industrial", "Alternative", "Ska",
		"Death Metal", "Pranks", "Soundtrack", "Euro-Techno", "Ambient",
		"Trip-Hop", "Vocal", "Jazz+Funk", "Fusion", "Trance", "Classical",
		"Instrumental", "Acid", "House", "Game", "Sound Clip", "Gospel",
		"Noise", "AlternRock", "Bass", "Soul", "Punk", "Space", "Meditative",
		"Instrumental Pop", "Instrumental Rock", "Ethnic", "Gothic", "Darkwave",
		"Techno-Industrial", "Electronic", "Pop-Folk", "Eurodance", "Dream",
		"Southern Rock", "Comedy", "Cult", "Gangsta", "Top 40", "Christian Rap",
		"Pop/Funk", "Jungle", "Native American", "Cabaret", "New Wave",
		"Psychadelic", "Rave", "Showtunes", "Trailer", "Lo-Fi", "Tribal",
		"Acid Punk", "Acid Jazz", "Polka", "Retro", "Musical", "Rock & Roll",
		"Hard Rock",
	) ];

=item

B<podcasts>-E<gt>B<genre>

Podcast genre.  Corresponds to ID3 tag 'genre'.

=cut

	$self->{'podcasts'}->{'genre'} = undef;

=back

=item

B<input_files>

Names of input files used throughout package.

=cut

	$self->{'input_files'} = {};

=over

=item

B<input_files>-E<gt>B<metadata>

Name of file containing metadata.  Run script with '-i' option to see the names used for input files.
	
=cut

	$self->{'input_files'}->{'metadata'} = 'INPUT.metadata';

=item

B<input_files>-E<gt>B<podcasts>

Name of file containing podcast information.  Run script with '-i' option to see the names used for input files.
	
=cut

	$self->{'input_files'}->{'podcasts'} = 'INPUT.podcasts';

=item

B<input_files>-E<gt>B<published>

Name of file containing pubdates.  Run script with '-i' option to see the names used for input files.
	
=cut

	$self->{'input_files'}->{'published'} = 'INPUT.published';

=back

=back

=head3 Constructors

There is a single method signature that does not accept any arguments:

	my $ojb = new DnChannel;  OR  my $ojb = DnChannel->new();

=cut

	bless ( $self , $class );
	return $self;
	}

=head3 Setters

	$c->set_title( '<title>' );
	$c->set_base_url( '<base_url>' );
	$c->set_language( '<language>' );
	$c->set_author( '<author>' );
	$c->set_summary( '<summary>' );
	$c->set_image( '<image>' );
	$c->set_category( '<category>' );
	$c->set_subcategory( '<subcategory>' );
	$c->set_explicit( '<explicit>' );
	$c->set_items( @items );
	$c->add_item( %items );
	$c->set_file_mask( '<file_mask>' );
	$c->set_title_mask( '<title_mask>' );
	$c->set_series( '<series_number>' );
	$c->set_episode( '<episode_number>' );
	$c->set_disc( '<disc_number>' );
	$c->set_artist( '<artist>' );
	$c->set_composer( '<composer>' );
	$c->set_album( '<album_title>' );
	$c->set_year( '<year>' );
	$c->set_comment( '<comment>' );
	$c->set_genre( '<genre>' );

There are no setters for scheme, genres or input filenames as they are set at object construction time.

=cut

	sub set_title { $_[0]->{'title'} = $_[1]; }
	sub set_base_url { $_[0]->{'base_url'} = $_[1]; }
	sub set_language { $_[0]->{'language'} = $_[1]; }
	sub set_author { $_[0]->{'author'} = $_[1]; }
	sub set_summary { $_[0]->{'summary'} = $_[1]; }
	sub set_image { $_[0]->{'image'} = $_[1]; }
	sub set_category { $_[0]->{'category'} = $_[1]; }
	sub set_subcategory { $_[0]->{'subcategory'} = $_[1]; }
	sub set_explicit { $_[0]->{'explicit'} = $_[1]; }
	sub set_items { $_[0]->{'title'} = $_[1]; }
	sub add_item { push @{ $_[0]->{'items'} } , @_[1..$#_]; } 
	sub set_file_mask { $_[0]->{'podcasts'}->{'file_mask'} = $_[1]; }
	sub set_title_mask { $_[0]->{'podcasts'}->{'title_mask'} = $_[1]; }
	sub set_series { $_[0]->{'podcasts'}->{'series'} = $_[1]; }
	sub set_episode { $_[0]->{'podcasts'}->{'episode'} = $_[1]; }
	sub set_disc { $_[0]->{'podcasts'}->{'disc'} = $_[1]; }
	sub set_artist { $_[0]->{'podcasts'}->{'artist'} = $_[1]; }
	sub set_composer { $_[0]->{'podcasts'}->{'composer'} = $_[1]; }
	sub set_album { $_[0]->{'podcasts'}->{'album'} = $_[1]; }
	sub set_year { $_[0]->{'podcasts'}->{'year'} = $_[1]; }
	sub set_comment { $_[0]->{'podcasts'}->{'comment'} = $_[1]; }
	sub set_genre { $_[0]->{'podcasts'}->{'genre'} = $_[1]; }

=head3 Getters

	$c->title();
	$c->base_url();
	$c->language();
	$c->author();
	$c->summary();
	$c->image();
	$c->category();
	$c->subcategory();
	$c->explicit();
	$c->items();   # returns list reference
	$c->scheme();  # returns hash reference
	$c->file_mask();
	$c->title_mask();
	$c->series();
	$c->episode();
	$c->disc();
	$c->artist();
	$c->composer();
	$c->album();
	$c->year();
	$c->comment();
	$c->genres();  # returns list reference
	$c->genre();
	$c->metadata_file();
	$c->podcasts_file();
	$c->published_file();
	$c->input_files();  # returns list reference

=cut

	sub title         { $_[0]->{'title'};                       }
	sub base_url      { $_[0]->{'base_url'};                    }
	sub language      { $_[0]->{'language'};                    }
	sub author        { $_[0]->{'author'};                      }
	sub summary       { $_[0]->{'summary'};                     }
	sub image         { $_[0]->{'image'};                       }
	sub category      { $_[0]->{'category'};                    }
	sub subcategory   { $_[0]->{'subcategory'};                 }
	sub explicit      { $_[0]->{'explicit'};                    }
	sub items         {
		defined( $_[0]->{'items'} ) ? $_[0]->{'items'} : undef;
	}
	sub scheme        { $_[0]->{'scheme'};                      }
	sub file_mask     { $_[0]->{'podcasts'}->{'file_mask'};     }
	sub title_mask    { $_[0]->{'podcasts'}->{'title_mask'};    }
	sub series        { $_[0]->{'podcasts'}->{'series'};        }
	sub episode       { $_[0]->{'podcasts'}->{'episode'};       }
	sub disc          { $_[0]->{'podcasts'}->{'disc'};          }
	sub artist        { $_[0]->{'podcasts'}->{'artist'};        }
	sub composer      { $_[0]->{'podcasts'}->{'composer'};      }
	sub album         { $_[0]->{'podcasts'}->{'album'};         }
	sub year          { $_[0]->{'podcasts'}->{'year'};          }
	sub comment       { $_[0]->{'podcasts'}->{'comment'};       }
	sub genres        {
		defined( $_[0]->{'genres'} ) ? $_[0]->{'genres'} : undef;
	}
	sub genre          { $_[0]->{'podcasts'}->{'genre'};        }
	sub metadata_file  { $_[0]->{'input_files'}->{'metadata'};  }
	sub podcasts_file  { $_[0]->{'input_files'}->{'podcasts'};  }
	sub published_file { $_[0]->{'input_files'}->{'published'}; }
	sub input_files    {
		[ (
			$_[0]->{'input_files'}->{'metadata'} ,
			$_[0]->{'input_files'}->{'podcasts'} ,
			$_[0]->{'input_files'}->{'published'}
		) ];
	}

=head3 Other

=head4 list_input_files()

Lists the filenames used for the following input files:

	channel metadata input file,
	podcasts metadata input file, and
	published podcasts input file.	

Note this channel method has the same name as the feed method calling it.  This can confuse ctags and other indexing utilities.
Parameters: [ 0 = class ].

Return type: N/A.

=cut

sub list_input_files {
	my ( $self ) = ( shift );
	printf "Channel metadata input file is '%s'\n" , $self->metadata_file();
	printf "Podcasts metadata input file is '%s'\n" , $self->podcasts_file();
	printf "Published podcasts input file is '%s'\n" , $self->published_file();
	exit TRUE;
}

=head4 xml()

Prints xml tree for channel.  It is intended to be included in the final rss feed file.  Here is example output:

	<channel>
		<title><![CDATA[Political Incorrections]]></title>
		<language>en</language>
		<itunes:author>Bill Maher</itunes:author>
		<itunes:summary><![CDATA[Compilation of highlights from "Politically Incorrect", a late-night, half-hour political talk show hosted by Bill Maher that ran from 1993 to 2002. The show aired on Comedy Central from 1993 to 1996 and on ABC from 1997 to 2002.]]></itunes:summary>
		<description><![CDATA[Compilation of highlights from "Politically Incorrect", a late-night, half-hour political talk show hosted by Bill Maher that ran from 1993 to 2002. The show aired on Comedy Central from 1993 to 1996 and on ABC from 1997 to 2002.]]></description>
		<itunes:image href="http://localhost/podcasts/pol-inc/bill-maher.jpg"/>
		<itunes:category text="Comedy"/>
		<item>
			<title><![CDATA[01 Political Incorrections]]></title>
			<SNIP/>
			<itunes:keywords><![CDATA[politics satire]]></itunes:keywords>
		</item>
	</channel>

The base url is prepended to all urls in channel and subsidiary items.

By default the 'channel' element is flush left with all subsidiary elements indented normally.  You can increase the left indent of all output by supplying the number of additional tab indents in an argument.

Parameters: [ 0 = class ] , 1 = tabs.

Return type: List reference (one line per element, newline ends each line).

=cut

sub xml {
	my ( $self , $tab_count , @xml , $tabs ) = ( shift , shift , () , "" );
	$tab_count = 0 if not $tab_count;
	$tabs .= "\t" foreach ( 1..$tab_count );
	# need to entitise (sub)categories
	my $cat = $self->entitise( $self->category() );
	my $subcat = $self->entitise( $self->subcategory() );
	# time to output
	push @xml , "$tabs<channel>\n";
	push @xml , sprintf( "$tabs\t<title>%s</title>\n" ,
		                 $self->title() );
	push @xml , sprintf( "$tabs\t<language>%s</language>\n" , 
		                 $self->language() );
	push @xml , sprintf( "$tabs\t<itunes:author>%s</itunes:author>\n" ,
	                     $self->author() );
	push @xml , sprintf( "$tabs\t<itunes:summary>%s</itunes:summary>\n" ,
	                     $self->summary() );
	push @xml , sprintf( "$tabs\t<description>%s</description>\n" ,
	                     $self->summary() );
	push @xml , sprintf( "$tabs\t<itunes:image href=\"%s/%s\"/>\n" ,
	                     $self->base_url() , $self->image() );
	if ( $subcat ) {
		push @xml , sprintf( "$tabs\t<itunes:category text=\"%s\">\n" ,
			                 $cat );
		push @xml , sprintf( "$tabs\t\t<itunes:category text=\"%s\"/>\n" ,
			                 $subcat );
		push @xml , "$tabs\t</itunes:category>\n";
	} else {
		push @xml , sprintf( "$tabs\t<itunes:category text=\"%s\"/>\n" ,
			                 $cat );
	}
	push @xml , sprintf( "$tabs\t<itunes:explicit>%s</itunes:explicit>\n" ,
	                     $self->explicit() );
	# print out all the items
	my @items = @{ $self->items() };
	for my $item ( @items ) {
		push @xml , @{ $item->xml( $self->base_url() , $tab_count + 1 ) };
	}
	# finish off the channel and return it
	push @xml , "$tabs</channel>\n";
	\@xml;
}

=head4 unpublished_podcasts()

Gets list of unpublished podcasts in the current directory.  To do this a list of podcasts in the current directory is obtained -- these are files of type mp3.  Then a list of already published files is obtained from the published podcasts file.  Those podcasts not listed as already published are deemed to be unpublished.

A podcast listed in the published podcasts file but not present in the directory triggers a warning but does not halt processing.

Parameters: [ 0 = class ].

Return type: List reference.

=cut

sub unpublished_podcasts {
	my ( $self , %published , %podcasts ) = ( shift );
	# first get all podcasts in directory
	$podcasts{$_} = 1 foreach @{ $self->podcast_files() };
	# now get all published podcasts
	my $publish_file = $self->published_file();
	$self->write_input_published;  # only if not found
	my @file_content = @{ $self->extract_file_data( $publish_file ) };
	$published{$_->{'key'}} = 1 foreach @file_content;
	# issue warning for each podcast listed as published
	# but not present in directory, i.e., "lost"
	my @published_lost = grep { not $podcasts{$_} } keys %published;
	if ( @published_lost ) {
		@published_lost = sort @published_lost;
		print "WARNING: listed as published but not found in directory:\n";
		print "  $_\n" foreach @published_lost;
		my $prep = ( $#published_lost > 1 ) ? 'them' : 'it';
		my $prompt = "remove $prep from published podcasts file?";
		if ( DnLib->new()->input_confirm( $prompt ) ) {
			# rewrite published input file without lost files
			delete $published{$_} foreach keys %published;
			$published{$_->{'key'}} = $_->{'value'} foreach @file_content;
			delete $published{$_} foreach @published_lost;
			my @output = @{ $self->published_input_template() };
			while ( my ( $file , $pubdate ) = each %published ) {
				push @output , sprintf( "%s %s\n" , $file , $pubdate );
			}
			$self->write_file( $publish_file , \@output );
			print "rewrote published podcast file without lost files\n";
		}
	}
	# get unpublished podcasts
	my @unpublished = grep { not $published{$_} } keys %podcasts;
	@unpublished = sort @unpublished;
	\@unpublished;
}

=head4 process_inputs()

Processes podcasts in current directory.  All podcasts in the directory not yet published are processed.

Whether a podcasts has been published or not is determined by whether the filename is or is not in the published podcasts input file.

Parameters: [ 0 = class ].

Return type: N/A.

=cut

sub process_inputs {
	my ( $self ) = ( shift );
	# first, get list of unpublished podcasts
	my @unpublished = @{ $self->unpublished_podcasts() };
	if ( not @unpublished ) {
		print "all podcast files have been published\n";
		return;
	}
	# extract values from podcasts input file
	# call sub that: creates file if none present
	#                extracts values and set self podcasts hash
	# call another sub that checks and sets podcast hash values
	#my $file_mask = 
	foreach my $file ( @unpublished ) {
		# start with file mask
	}
}

=head4 valid_categorisation()

Checks whether categorisation is valid.  The method will work with category only set, or with both category and subcategory set.

Any non-entitised ampersands are entitised before checking, i.e., '&' converted to '&amp;'.

Parameters: [ 0 = class ].

Return type: Boolean.

=cut

sub valid_categorisation {
	my ( $self ) = ( shift );
	# obtain (sub)category and categorisation scheme
	my $category = $self->entitise( $self->category() );
	return undef unless $category;
	my $subcategory = $self->entitise( $self->subcategory() );
	my %scheme = %{ $self->scheme() };
	# test category first
	return 0 unless exists $scheme{$category};  # fail if category invalid
	return 1 unless $subcategory;  # succeeded now if testing category only
	# then test subcategory (if supplied)
	exists $scheme{$category}{$subcategory};
}

=head4 valid_image_type()

Determines whether image mime type is valid.  Valid mime types are 'image/jpeg' and 'image/png'.

Parameters: [ 0 = class ].

Return type: Boolean.

=cut

sub valid_image_type {
	my $mime_type = $_[0]->mime_type( $_[0]->image() );
	grep /^$mime_type$/ , qw( image/jpeg image/png );
}

=head4 valid_language()

Determines whether language code is a valid ISO639 language identification code.

Parameters: [ 0 = class ].

Return type: Boolean.

=cut

sub valid_language { $_[0]->valid_iso639_code( $_[0]->language() ); }

=head4 valid_explicit()

Determines whether explicit setting is valid.  Valid settings are 'yes', 'clean' and 'no'.  This method accepts only these values although some systems will interpret any value other than 'yes' and 'clean' as 'no'.

Parameters: [ 0 = class ].

Return type: Boolean.

=cut

sub valid_explicit {
	my $explicit = $_[0]->explicit();
	grep /^$explicit$/ , qw( yes clean no );
}

=head4 empty()

Determines whether channel is empty.  This requires the following items to be undefined/empty: title, base url, author, summary, image, category, and no items.

Parameters: [ 0 = class ].

Return type: Boolean.

=cut

sub empty {
	my ( $self ) = ( shift );
	# check that all elements are present
	return undef if $self->title();
	return undef if $self->base_url();
	return undef if $self->author();
	return undef if $self->summary();
	return undef if $self->image();
	return undef if $self->category();
	return undef if @{ $self->items() };
	1;  # return success if still here
}

=head4 complete()

Determines whether channel is complete.  This requires:

	- all of the following items: title, base url, language, author, summary, image, category, optional subcategory, explicit setting and at least one item,
	- language is a complete ISO639 code,
	- complete explicit setting, 
	- image mime type is either 'image/jpeg' or 'image/png', and
	- complete categorisation.

Parameters: [ 0 = class ].

Return type: Boolean.

=cut

sub complete {
	my ( $self ) = ( shift );
	# check that all elements are present
	return undef if not $self->title();
	return undef if not $self->base_url();
	return undef if not $self->language();
	return undef if not $self->author();
	return undef if not $self->summary();
	return undef if not $self->image();
	return undef if not $self->category();
	return undef if not $self->explicit();
	return undef if not @{ $self->items() };
	# check image mime type
	return undef if not $self->valid_image_type();
	# check explicit setting
	return undef if not $self->valid_explicit();
	# check language
	return undef if not $self->valid_language();
	# check categorisation
	return undef if not $self->valid_categorisation();
	1;  # return success if still here
}

=head4 why_incomplete()

Returns list of why_incomplete, i.e., reasons why channel is not complete.

Does not check whether channel is complete -- it is presumed 'complete' method has already determined this.  It is therefore possible for this function, if improperly called on a complete channel, to return an empty list.

See 'complete' method for the requirements of a complete channel.

Parameters: [ 0 = class ].

Return type: List (one line per element, newline end each line).

=cut

sub why_incomplete {
	my ( $self , @ret ) = ( shift );
	# check that all elements are present
	push( @ret , "no title\n" ) if not $self->title();
	push( @ret , "no base_url\n" ) if not $self->base_url();
	push( @ret , "no language\n" ) if not $self->language();
	push( @ret , "no author\n" ) if not $self->author();
	push( @ret , "no summary\n" ) if not $self->summary();
	push( @ret , "no image\n" ) if not $self->image();
	push( @ret , "no category\n" ) if not $self->category();
	push( @ret , "no explicit\n" ) if not $self->explicit();
	push( @ret , "no items\n" ) if not @{ $self->items() };
	# check explicit setting
	if ( $self->explicit() ) {
		if ( not $self->valid_explicit() ) {
			push( @ret , "invalid explicit seting '" . $self->explicit() . "'\n" );
		}
	}
	# check image mime type
	if ( $self->image() ) {
		if ( not $self->valid_image_type() ) {
			push( @ret , "invalid image mime type\n" );
		}
	}
	# check language
	if ( $self->language() ) {
		if ( not $self->valid_language() ) {
			push( @ret , "invalid language '" . $self->language() . "'\n" );
		}
	}
	# check categorisation
	my $cat = $self->category();
	my $subcat = $self->subcategory();
	if ( $cat ) {
		if ( not $self->valid_categorisation() ) {
			push( @ret , "invalid categorisation (cat='" .
				  $cat . "', subcat = '" . $subcat . "')\n" );
		}
	}
	# return result
	\@ret;
}

=head4 clear()

Clear all values from item.

Parameters: [ 0 = class ].

Return type: N/A.

=cut

sub clear {
	my ( $self ) = ( shift );
	# check that all elements are present
	$self->set_title( undef );
	$self->set_base_url( undef );
	$self->set_language( 'en' );
	$self->set_author( undef );
	$self->set_summary( undef );
	$self->set_image( undef );
	$self->set_category( undef );
	$self->set_subcategory( undef );
	$self->set_explicit( 'no' );
	$self->set_items( () );
}

=head4 output_scheme()

Outputs the scheme in format suitable for printing.  Output is sorted (case-insensitive).  Ampersand entities are de-entitised, i.e., '&amp;' to '&'.

Output is in the form of a List.  There is one (sub)category per line with subcategories indented one tab.  All lines end with newlines.  The easiest way to use the output is something like:

	print $_ foreach $cat->output_scheme();

Parameters: [ 0 = class ].

Return type: List reference (one line per element, newlines end each line, categories are flush left and subcategories are indented one tab space).

=cut

sub output_scheme {
	# header
	print "RSS feed categorisation scheme\n";
	print "[categories and subcategories]\n";
	print "------------------------------\n";
	print "                              \n";
	# note both sorts are case insensitive
	my ( $self , @output ) = ( shift , () );
	my %scheme = %{ $self->scheme() };
	my @categories = sort { "\L$a" cmp "\L$b" } keys %scheme;
	foreach my $category ( @categories ) {
		$category =~ s/&amp;/&/g;
		push @output , $category . "\n";
		eval { my $throwaway = %{ $scheme{$category} } };  # error if this does not return hash
		if ( not $@ ) {  # '$@' holds error if eval failed
			my @subcategories = sort { "\L$a" cmp "\L$b" }
			                    keys %{ $scheme{$category} };
			foreach my $subcategory ( @subcategories ) {
				$subcategory =~ s/&amp;/&/g;
				push @output , "\t" . $subcategory . "\n";
			}
		}
	}
	\@output;
}

=head4 enter_metadata()

Prompts user to enter metadata values.  Accepts a simple key-value hash with existing or default values which the user has the option of changing or adding to.

Returns results in a hash compatible with method 'insert_values' (see that method for more information).

Because this method uses the 'datum' data members, you can obtain a result with:

	DnChannel->new( \%key_values )->enter_metadata();

Parameters: [ 0 = class ].

Uses data mambers: datum = key-value hash reference.

Return type: Hash reference.

=cut

sub enter_metadata {
	# set up variables
	my ( $self, %data , $msg , $key , @opts , $val , $default , @pubdates )
		= ( shift );
	my %supplied = ( $self->datum() ) ? %{ $self->datum() } : ();
	foreach ( keys %supplied ) {
		delete $supplied{$_} if not $supplied{$_};
	}
	$self->read_config_files( 'dn-podcasts-rss' );
	my $base_dir = $self->config_param( 'base-directory' );
	if ( $base_dir ) {
		if ( not -e $base_dir or not -d $base_dir ) {
			warn "Base directory '$base_dir' set in config file " .
				 "does not exist or is not a directory\n";
			$base_dir = undef;
		}
		$base_dir .= "/" if substr( $base_dir , -1 ) ne '/';
	}
	my $base_url = $self->config_param( 'base-url' );
	if ( $base_url ) {
		$base_url .= "/" if substr( $base_url , -1 ) ne '/';
	}

	# feed output base
	( $key , $default , $val ) = ( 'feed-output-base' , 'rss-feed' , undef );
	print <<END;
Feed output base
----------------
This is the basename of feed xml and opml files.  It should
not contain spaces.  An example is 'my-podcast-channel'.
The default is '$default'.
END
	if ( exists $supplied{$key} ) {
		$default = $supplied{$key};
		print "Existing feed output base: '$default'\n";
	}
	$val = $self->input_ask( 'Enter feed output base:' , $default );
	if ( $val ) {
		$data{$key}{'value'} = $val;
		print "Feed output base set to '$val'\n";
	} else {
		$data{$key}{'key'} = "#$key";
		warn "No feed output base set -- using default:\n  '$default'\n";
	}

	# channel title
	( $key , $default , $val ) = ( 'channel-title' , '' , undef );
	print <<END;

Channel title
-------------
Title of podcast, e.g., 'My Podcast Channel'.
END
	if ( exists $supplied{$key} ) {
		$default = $supplied{$key};
		print "Existing channel title: '$default'\n";
	}
	$val = $self->input_ask( 'Enter channel title:' , $default );
	if ( $val ) {
		$data{$key}{'value'} = $val;
		print "Channel title set to '$val'\n";
	} else {
		warn "No channel title set\n";
	}

	# channel-base-url
	( $key , $default , $val )
		= ( 'channel-base-url' , 'http://localhost/podcasts' , undef );
	my $url_dir;
	print <<END;

Channel base url
----------------
A url that will be prepended to all audio, image and xml
file urls in generated xml feed and opml files.
END
	if ( exists $supplied{$key} ) {
		$default = $supplied{$key};
		print "Existing channel base url: '$default'\n";
		if ( $self->input_confirm( "Keep existing channel base url?" ) ) {
			$val = $default;
		}
	}
	if ( not $val ) {
		if ( $base_dir ) {
			my @dirs = glob "$base_dir*";
			if ( @dirs ) {
				print "Displaying the contents of the configured " .
					  "podcast\ndirectory '$base_dir'\n";
				unshift @dirs ,
						substr( pop @dirs , length $base_dir )
							for 0..$#dirs;
				$url_dir = $self->input_choose(
					'Select the podcast directory:' ,
					@dirs
				);
				if ( $url_dir and $base_url ) {
					print "Combining selected directory with configured\n" .
						  "url base '$base_url'\n" .
						  "to obtain default channel base url\n";
					$default = $base_url . $url_dir;
				}
			}  # if ( @dirs )
		}  # if ( $base_dir )
		$val = $self->input_ask( 'Enter channel base url:' , $default );
	}  # if ( not $val )
	if ( $val ) {
		$data{$key}{'value'} = $val;
		print "Channel base url set to:\n  '$val'\n";
	} else {
		$data{$key}{'value'} = $default;
		warn "No url entered -- using default:\n  '$default'\n";
	}

	# channel language
	( $key , $default , $val ) = ( 'channel-language' , 'en' , undef );
	print <<END;

Channel language
----------------
The language used in the podcast.  More specifically, it is
a two-letter code as specified in ISO 639.
The default is '$default' (English).
END
	if ( exists $supplied{$key} ) {  # can use existing if supplied
		print "Existing channel language: '$supplied{$key}'\n";
		$val = $supplied{$key}
			if $self->input_confirm( 'Keep existing channel language?' );
	}
	if ( not $val ) {  # next step, try for default English
		$val = $default 
			if $self->input_confirm( 'Is the podcast language English?' );
	}
	if ( not $val ) {  # okay then, now must pick from whole list
		my $code = $self->codify_iso639_lang(
			$self->input_choose( 'Select language:' ,
			                     @{ $self->all_iso639_langs() }
			)
		);
		if ( $code ) {
			$val = $code;
			print "Using channel language code '$code'\n";
		} else {
			$val = $default;
			print "No language selected -- using default code '$default'\n";
		}
	}
	$data{$key}{'value'} = $val;

	# channel author
	( $key , $default , $val ) = ( 'channel-author' , '' , undef );
	print <<END;

Channel author
--------------
The author, artist or performer of channel content.
END
	if ( exists $supplied{$key} ) {
		$default = $supplied{$key};
		print "Existing channel author: '$default'\n";
	}
	$val = $self->input_ask( 'Enter channel author:' , $default );
	if ( $val ) {
		$data{$key}{'value'} = $val;
		print "Channel author set to '$val'\n";
	} else {
		warn "No channel author set\n";
	}

	# channel summary
	( $key , $default , $val ) = ( 'channel-summary' , '' , undef );
	print <<END;

Channel summary
--------------
A description of the channel's contents.  While an importer
will take the entire value, the specification limits this
value to 4000 characters and some aggregators may truncate
beyond this limit or reject the channel entirely.
This value is also used as a channel description tag.
END
	if ( exists $supplied{$key} ) {
		$default = $supplied{$key};
		print "There is an existing channel summary\n";
	}
	$msg = 'Enter channel summary:';
	$val = join " " , split( "\n" , $self->input_large( $msg , $default ) );
	if ( $val ) {
		$data{$key}{'value'} = $val;
		print "Channel summary set to:\n  '$val'\n";
	} else {
		warn "No channel summary set\n";
	}

	# channel image
	( $key , $val ) = ( 'channel-image' , undef );
	print <<END;

Channel image
-------------
The file path of an image file.  It is used by aggregators
when displaying the rss channel.  It must be the file path
from the working directory when the dn-podcasts-rss script is
run.  It must not include "pseudo-directories" such as './'
and '../'.
During rss feed and opml file output the base url will be
prepended to this path.
Only jpg and png image types are supported.
END
	if ( exists $supplied{$key} and -e $supplied{$key} ) {  # existing
		$default = $supplied{$key};
		print "Existing image file: '$default'\n";
		$val = $default if $self->input_confirm( 'Keep existing image file?' );
	}
	if ( not $val ) {  # pick from image files in directory
		my @all_files = glob "*";
		my @images;
		for ( @all_files ) {
			my $channel = DnChannel->new();
			$channel->set_image( $_ );
			push @images , $_ if $channel->valid_image_type();
		}
		if ( scalar( @images ) == 1 ) {
			$val = $images[0] 
				if $self->input_confirm( sprintf "Use '%s'?" , $images[0] );
		} elsif ( scalar( @images ) > 1 ) {
			$val = $self->input_choose( "Select image ['q' to quit]" , @images );
		}
	}
	if ( not $val ) {  # last chance: enter manually
		$val = $self->input_ask( 'Enter image filepath:' );
	}
	if ( $val ) {
		$data{$key}{'value'} = $val if $val;
		print "Channel image set to '$val'\n";
	} else {
		warn "No channel image set\n";
	}

	# channel category
	my ( $use_existing_cat , $category , $subcategory ) = ( FALSE );
	my %scheme = %{ DnChannel->new()->scheme() };
	print <<END;

Channel category
----------------
The RSS xml feed specification includes a two-level
classification scheme with category and sub-category.
Depending on the classification you may need to specify
category only, or both category and subcategory.
END
	if ( exists $supplied{'channel-category'} ) {
		my ( $def_cat , $def_subcat ) = ( $supplied{'channel-category'} ,
			$supplied{'channel-subcategory'} );
		$msg = $def_cat . ( ( $def_subcat ) ? " => $def_subcat" : '' );
		print "Existing categorisation: $msg\n";
		if ( $self->input_confirm( 'Keep existing categorisation?' ) ) {
			( $category , $subcategory ) = ( $def_cat , $def_subcat );
			$use_existing_cat = TRUE;
		}
	}
	if ( not $category ) {
		$category = $self->input_choose( 'Select category:' ,
		                                 sort( keys %scheme ) );
		warn "No category set\n" if not $category;
	}

	# channel subcategory
	( $key ) = ( 'channel-subcategory' );
	if ( $category and not $use_existing_cat ) {  # assume $category is valid
		if ( $scheme{$category} ) {
			$subcategory = $self->input_choose(
				'Select subcategory:' ,
				sort( keys %{ $scheme{$category} } )
			);
			if ( not $subcategory ) {
				warn "Channel not categorised\n";
				$category = undef;
			}
		} else {
			$data{$key}{'key'} = "#$key";
			printf "No subcategory needed for category '%s'\n" ,
			       $self->deentitise( $category );
		}  # if ( $scheme{$category} )
	}  # if ( $category )
	if ( $category ) {
		$data{'channel-category'}{'value'} 
			= $self->deentitise( $category );
		printf "Category set to '%s'\n" ,
		      $self->deentitise( $category );
		if ( $subcategory ) {
			$data{'channel-subcategory'}{'value'} 
				= $self->deentitise( $subcategory );
			printf "Subcategory set to '%s'\n" ,
				  $self->deentitise( $subcategory );
		}
	}

	# channel explicit
	( $key , $default , $val ) = ( 'channel-explicit' , 'no' , undef );
	print <<END;

Channel explicit
----------------
This value indicates to aggregators whether the podcast
channel contains explicit content.
There are three values.
 yes:   indicates explicit content,
 clean: no explicit content and aggregators may declare so,
 no:    no explicit content but aggregators will not
        declare so.
The default is '$default'.
END
	if ( exists $supplied{$key} ) {  # can keep existing
		print "Existing explicitness: '$supplied{$key}'\n";
		$val = $supplied{$key} 
			if $self->input_confirm( 'Keep existing explicitness?' );
	}
	if ( not $val ) {  # alright, then choose new one
		@opts = qw/ no clean yes /;
		$val = $self->input_choose( 'Select channel explicit:' , @opts );
	}
	if ( $val ) {
		$data{$key}{'value'} = $val;
		print "Channel explicit set to '$val'\n";
	} else {
		warn "No channel explicit set\n";
	}

	# pubdate method
	( $key , $default , $val ) = ( 'pubdate-method' , '' , undef );
	my ( $method ) = ( undef );
	print <<END;

Pubdate method
--------------
Indicates how podcast publication dates will be selected.
There are three values:
 descend: use for discrete set of podcasts, i.e., an audiobook,
 ascend: for ongoing titles,
 provide: means pubdates are supplied in this metadata file
          using 'pubdate' keys.
END
	if ( exists $supplied{$key} ) {
		$default = $supplied{$key};
		print "Existing pubdate method: '$default'\n";
		$val = $default 
			if $self->input_confirm( 'Keep existing pubdate method?' );
	}
	if ( not $val ) {
		@opts = qw/ descend ascend provide /;
		$val = $self->input_choose( 'Select pubdate method' , @opts );
	}
	if ( $val ) {
		$data{$key}{'value'} = $val;
		print "Pubdate method set to '$val'\n";
		$method = $val;
	} else {
		warn "No pubdate method set\n";
	}

##	# pubdate
##	if ( $method eq 'provide' ) {
##		( $key , $val ) = ( 'pubdate' , undef );
##		print <<END;
##
##Pubdates
##--------
##Provide podcast dates in the same order as podcast files
##are listed by the perl 'glob' function.  Each publication
##date you supply is a value for the key 'pubdate'.
##Enter each date in ISO format 'yyy-mm-dd'.
##Dates will be converted to the RFC 2822 format required by
##aggregators.
##Enter an empty pubdate to finish entering pubdates.
##END
##		while ( 1 ) {
##			$val = $self->input_ask( 'Enter pubdate:' );
##			last if not $val;
##			if ( $self->valid_date( $val ) ) {
##				my $rfc_date = DnLib->new( $val )->iso_to_rfc2822();
##				if ( grep $rfc_date eq $_ , @pubdates ) {
##					warn "Pubdate '$val' already added\n";
##				} else {
##					push @pubdates , $rfc_date;
##				}
##			} else {
##				warn "Invalid iso-format date '$val'\n";
##			}
##		}
##		if ( @pubdates ) {
##			print "Set the following pubdates:\n";
##			print "  $_\n" foreach @pubdates;
##		} else {
##			warn "No pubdates set\n";
##		}
##	}  # if ( $method eq 'provide' )
	print "\n";
	# return results
	\%data;
}

=head4 validate_metadata()

Takes (reference to) data extracted by method 'extract_file_data' and checks whether it is a valid set of metadata, as supplied by a input metadata file.  See method 'extract_file_data' for the data structure it supplies.

The metadata set must be complete -- all required keys must be provided and no provided key can have an empty value.

The following checks are performed: 

	sanity checks on constrained keys
		that all constrained key names are valid
		that all constrained keys have associated allowed values
	no invalid keys
	all required keys are present
	all provided keys have a non-empty value
	no singular keys are duplicated
	all constrained keys have a valid value
	no pubdates provided unless 'pubdate-method' is 'provide'
	language, image and category/subcategory are valid
	dates are valid

The script dies if a check fails.

Because this method uses the 'datum' data members, you can obtain a result with:

	DnChannel->new( \@metadata )->validate_metadata();

Parameters: [ 0 = class ].

Uses data mambers: datum = metadata array reference.

Return type: N/A.

=cut

sub validate_metadata {
	# set up variables
	my ( @keys , @valid_keys, $msg  );
	my @data = @{ $_[0]->datum() };
	die "No metadata supplied for verification\n" if not @data;
	push @keys , $_->{'key'} foreach @data;
	my @required_keys = qw/ channel-title channel-base-url
	                        channel-author channel-summary 
	                        channel-image channel-category 
	                        pubdate-method /;
	my @optional_keys = qw/ feed-output-base channel-language
	                        channel-subcategory channel-explicit
	                        pubdate /;
	my @singular_keys = qw/ feed-output-base channel-title 
	                        channel-base-url channel-language
	                        channel-author channel-summary
	                        channel-image channel-category
	                        channel-subcategory channel-explicit
	                        pubdate-method /;
	push @valid_keys , @required_keys , @optional_keys;
	die "No valid keys supplied to validator\n" if not @valid_keys;
	my %constrained_values = ( 
		'channel-explicit' => [ 'yes' , 'no' , 'clean' ] ,
		'pubdate-method'   => [ 'descend' , 'ascend' , 'provide' ] ,
	);
	foreach ( keys %constrained_values ) {
		my $key = $_;
		$msg = "List of constrained keys includes '$key' " .
		       "which is not a valid key";
		die "$msg\n" if not grep /^$key$/ , @valid_keys;
		my @allowed_values = @{ $constrained_values{$key} };
		if ( not @allowed_values ) {
			$msg = "No allowed values defined for constrained " .
				   "metadata key '$key'";
			die "$msg\n";
		}
	}
	my @valueless_keys = qw/ item-start /;
	# now for validity checks
	# check: ensure no invalid keys
	foreach ( @data ) {
		my ( $key , $line ) = ( $_->{'key'} , $_->{'line'} );
		if ( not grep /^$key$/ , @valid_keys ) {
			$msg = sprintf "Invalid metadata key '%s' at line %s" ,
			               $key , $line;
			die "$msg\n" if not grep /^$key$/ , @valid_keys;
		}
	}
	# check: ensure all required keys are supplied
	foreach ( @required_keys ) {
		my $key = $_;
		die "Missing required metadata key '$key'\n"
			if not grep /^$key$/ , @keys;
	}
	# check: ensure all provided keys have non-empty value
	foreach ( @data ) {
		my ( $key , $value , $line ) =
			( $_->{'key'} , $_->{'value'} , $_->{'line'} );
		if ( not $value ) {
			if ( not grep $key eq $_ , @valueless_keys ) {
				$msg = sprintf "No value provided for metadata key " .
				               "'%s' at line %s" , $key , $line;
				die "$msg\n";
			}
		}
	}
	# check: constrained keys have valid values
	foreach ( @data ) {
		my ( $key , $value , $line ) =
			( $_->{'key'} , $_->{'value'} , $_->{'line'} );
		if ( grep /^$key$/ , keys %constrained_values ) {
			my @allowed_values = @{ $constrained_values{$key} };
			if ( not grep /^$value$/ , @allowed_values ) {
				$msg = "Illegal value '$value' for constrained " .
				       "metadata key '$key' at line $line";
				die "$msg\n";
			}
		}
	}
	# check: no pubdates unless pubdate-method is 'provide'
	my ( $method , $method_line );
	foreach ( @data ) {
		( $method , $method_line ) = ( $_->{'value'} , $_->{'line'} )
			if $_->{'key'} eq 'pubdate-method';
	}
	my %key_count;  # will reuse this hash in duplication check
	$key_count{$_->{'key'}}++ foreach @data;
	if ( $method && $method ne 'provide' ) {
		$msg = sprintf( "Pubdates provided despite metadata" .
		                "pubdate-method\n  being set to '%s' at line %s" ,
		                $method , $method_line );
		die "$msg\n" if exists $key_count{'pubdate'};
	}
	# check: no duplication of singular keys
	foreach ( keys %key_count ) {
		delete $key_count{$_} if $key_count{$_} == 1;
	}
	foreach ( keys %key_count ) {
		my $key = $_;
		delete $key_count{$_} if not grep /^$key$/ , @singular_keys;
	}
	if ( %key_count ) {
		foreach ( keys %key_count ) {
			my ( $key , $first ) = ( $_ , TRUE );
			print "The metadata key '$key' should be singular but occurs\n";
			print "  on lines ";
			foreach ( @data ) {
				if ( $_->{'key'} eq $key ) {
					print ", " if not $first;
					$first = FALSE;
					print $_->{'line'};
				}
			}
			print "\n";
		}
		die "Illegal duplicate metadata key(s) present\n";
	}
	# check: channel values for language, image and category/subcategory
	#        note that channel value explicit is tested as constrained key
	my ( $category , $cat_line , $subcategory , $subcat_line );
	my ( $language , $lang_line , $image , $img_line );
	foreach ( @data ) {
		my $key = $_->{'key'};
		# switch: $key
		# case: 'channel-language'
		( grep $key eq $_ , qw/ channel-language / ) and do {
			( $language , $lang_line ) = ( $_->{'value'} , $_->{'line'} );
		};
		# case: 'channel-image'
		( grep $key eq $_ , qw/ channel-image / ) and do {
			( $image , $img_line ) = ( $_->{'value'} , $_->{'line'} );
		};
		# case: 'channel-category'
		( grep $key eq $_ , qw/ channel-category / ) and do {
			( $category , $cat_line ) = ( $_->{'value'} , $_->{'line'} );
		};
		# case: 'channel-subcategory'
		( grep $key eq $_ , qw/ channel-subcategory / ) and do {
			( $subcategory , $subcat_line ) = ( $_->{'value'} , $_->{'line'} );
		};
		# no default case because non-matching values ignored
		# endswitch
	}
	my $channel = DnChannel->new();
	if ( $language ) {  # optional
		$channel->set_language( $language );
		die "Invalid metadata language '$language'\n  at line $lang_line\n"
			unless $channel->valid_language();
	}
	$channel->set_image( $image );  # required
	$msg = "Invalid metadata image '$image' (not jpg or png)\n"
	     . "  at line $img_line";
	die "$msg\n" unless $channel->valid_image_type();
	$channel->set_category( $category );  # required
	$channel->set_subcategory( $subcategory ) if $subcategory;  # optional
	$msg = sprintf( "Invalid metadata categorisation '%s" ,
	                $self->deentitise( $category ) )
	     . ( ( $subcategory )
	         ? sprintf( "->%s" , $self->deentitise( $subcategory ) )
	         : "" )
	     . "'\n  at line"
	     . ( ( $subcategory ) ? "s" : "" )
	     . " $cat_line"
	     . ( ( $subcategory ) ? " and $subcat_line" : "" );
	die "$msg\n" unless $channel->valid_categorisation();
	# check: dates are valid
	foreach ( @data ) {
		my ( $key , $value , $line )
			= ( $_->{'key'} , $_->{'value'} , $_->{'line'} );
		if ( grep $key eq $_ , qw/ pubdate item-pubdate / ) {
			my $item = DnItem->new();
			$item->set_pubdate( $value );
			die "Invalid metadata date '$value' at line $line\n"
				unless $item->valid_pubdate();
		}
	}
}

=head4 pubdates()

Derives list of publication dates from metadata.

Assumes metadata has been validated, i.e., 'pubdate-method' key is present with a valid value, and any pubdates are in valid format.

Takes an array of mp3 files to be added to skeleton input file in order to know how many pubdates to return.  If 'pubdate-method' is 'descend or 'ascend' the pubdates are generated using the arbitrary start date of 2008-07-01.

If 'pubdate-method' is 'provide' then pubdates are harvested from 'pubdate' key-value pairs.  Excess pubdates are ignored.  Processing will halt with an error if there are fewer provided pubdates than mp3 files.

Note that metadata array contains anonymous hashes in a format specified in method 'extract_file_data'.

Because this method uses the 'datum' data members, you can obtain a result with:

	DnChannel->new( \@mp3_files , \@metadata )->pubdates();

Parameters: [ 0 = class ].

Uses data mambers: datum   = mp3 files array reference,
                   datum_1 = metadata array reference.

Return type: List reference.

=cut

sub pubdates {
	# set up variables
	my ( $self , @pubdates , %key_values , @provided , $method ) = ( shift );
	my $pubdate = join "-" , 2008 , 7 , 1;
	my @mp3s = @{ $self->datum() };
	my @data = @{ $self->datum_1() };
	die "No mp3files provided for pubdate derivation\n" if not @mp3s;
	die "No metadata supplied for pubdate derivation\n" if not @data;
	foreach ( @data ) {
		my ( $key , $value ) = ( $_->{'key'} , $_->{'value'} );
		$method = $value if $key eq 'pubdate-method';
		push( @provided , $value ) if $key eq 'pubdate';
	}
	die "No pubdate method" if not $method;
	# switch: $method
	# case: 'descend'
	( grep $method eq $_ , qw/ descend / ) and do {
		foreach ( @mp3s ) {
			push @pubdates , $self->assemble_iso_date( @pubdate );
			$pubdate = $self->previous_iso_day( $pubdate );
		}
	};
	# case: 'ascend'
	( grep $method eq $_ , qw/ ascend / ) and do {
		foreach ( @mp3s ) {
			push @pubdates , $self->assemble_iso_date( @pubdate );
			$pubdate = $self->next_iso_day( $pubdate );
		}
	};
	# case: 'provide'
	( grep $method eq $_ , qw/ provide / ) and do {
		push @pubdates , $_ foreach @provided;
		my $num_dates = scalar( @pubdates );
		my $num_mp3s = scalar( @mp3s );
		# not enough
		if ( $num_dates < $num_mp3s ) {
			print "Metadata file configures pubdates to be provided " .
			      "as metadata\n";
			print "Found $num_mp3s mp3 files so need $num_mp3s pubdates\n";
			die "Metadata file provides $num_dates pubdate(s)\n";
		}
		# too many
		if ( $num_dates > $num_mp3s ) {
			my $diff = $num_dates - $num_mp3s;
			warn "Have $num_dates pubdates for $num_mp3s mp3 files --\n" .
			     "  ignoring excess pubdate(s):\n";
			printf( "  %s\n" , pop @provided ) foreach 1..$diff;
		}
	};
	# case: default
	( not grep $method eq $_ , qw/ descend ascend provide / ) and do {
		die "Invalid pubdate-method '$method'";
	};
	# endswitch
	\@pubdates;
}

=head4 podcast_files()

Gets list of podcast files in directory.

Possible usage:

	my @mp3s = @{ DnChannel->new()->podcast_files() };

Parameters: [ 0 = class ].

Return type: List reference.

=cut

sub podcast_files {
	my @audio;
	for ( glob "*" ) {
		push @audio , $_ if DnItem->new( $_ )->audio_mime_type();
	}
	\@audio;
}

=head4 published_input_template()

Provides template for published podcasts input file as a List.

Parameters: [ 0 = class ].

Return type: List reference (each element is a line, each line terminated by newline).

=cut

sub published_input_template {
	[ (
		"# Published podcasts input file for dn-podcasts-rss\n" ,
		"\n" ,
		"# ********************************************************\n" ,
		"# This file contains a list of published podcast files and\n" ,
		"# their publication dates.\n" ,
		"# \n" ,
		"# You should not ever need to edit this file manually.\n" ,
		"# The script dn-podcasts-rss will maintain this file\n" ,
		"# automatically.\n" ,
		"# \n" ,
		"# Each line is a space-separated key-value pair:\n" ,
		"#   key   = file name\n" ,
		"#   value = publication date\n" ,
		"# \n" ,
		"# Note that the key -- the podcast filename -- cannot\n" ,
		"# contain a space since anything after the first space\n" ,
		"# is part of the value -- the publication date.\n" ,
		"# \n" ,
		"# The publication date is in iso format: 'yyyy-mm-dd'.\n" ,
		"# ********************************************************\n" ,
		"\n" ,
	) ];
}

=head4 write_input_published()

Creates published podcasts input file template in current directory if the file does not already exist.

A published podcasts input file lists all published podcasts and their publication dates.

Parameters: [ 0 = class ].

Return type: N/A.

=cut

sub write_input_published {
	my ( $self , %extracted , %existing ) = ( shift );
	my ( $filename ) = ( $self->published_file() );
	# get data if file already exists
	if ( not -e $filename ) {
		my @output = @{ $self->published_input_template() };
		$self->write_file( $filename , \@output );
	}
}

=head1 PACKAGE: DnFeed

An internal package encapsulating methods and data for manipulating an rss feed.

=cut

package DnFeed;

use strict;
use warnings;
use parent qw/ Dn::PodcastsRss /;

our $VERSION = '0.1';

use constant TRUE => 1;
use constant FALSE => 0;

use Data::Dumper;  ## DELETE

=head2 Methods

=head3 Data Members

%self = (

	$import_filename  =>  "<filepath>" ,

	@imported_lines   =>  [ $line , ... ] ,

	@line_numbers     =>  [ $number , ... ] ,

	$output_base      =>  "<basename>" ,

	$channel          =>  %channel ,

)

=cut

sub new {
	my $proto = shift;
	my $class = ref($proto) || $proto;
	my $self  = {};

=over

=item

B<import_filename>

File path of import file.  May be set at object construction from passed parameter.

=cut

	$self->{'import_filename'} = shift;  # undef if no parameter

=item

B<imported_lines>

Lines imported from import file.  Only imports data lines.

=cut

	$self->{'imported_lines'} = ();

=item

B<line_numbers>

This List is built along with 'imported_lines'.  For each imported data line this List holds that line's line number in the import file.

=cut

	$self->{'line_numbers'} = ();

=item

B<output_base>

Basename of rss xml feed and subscription opml filenames.  Default: 'rss-feed'.

=cut

	$self->{'output_base'} = 'rss-feed';

=item

B<channel>

RSS channel comprising the feed.  While the specification allows for multiple channels per feed, this utility supports only one channel per feed.

=cut

	$self->{'channel'} = DnChannel->new();

=back

=head3 Constructors

There are two method signatures.  One accepts the import file as a parameter and the other accepts no arguments:

	my $ojb = new DnFeed;  OR  my $ojb = DnFeed->new();
	my $ojb = DnFeed->new( "<import_filename>" );

=cut

	bless ( $self , $class );
	return $self;
	}

=head3 Setters

	$r->set_import_filename( "<import_filename>" );
	$r->add_imported_lines( \@lines );
	$r->add_line_numbers( \@numbers );
	$r->set_output_base( "<basename>" );
	#$r->set_channel( \%channel );

=cut

	sub set_import_filename { $_[0]->{'import_filename'} = $_[1]; }
	sub add_imported_lines { push @{ $_[0]->{'imported_lines'} } , @{ $_[1] }; }
	sub add_line_numbers { push @{ $_[0]->{'line_numbers'} } , @{ $_[1] }; } 
	sub set_output_base { $_[0]->{'output_base'} = $_[1]; }
	#sub set_channel { $_[0]->{'channel'} = $_[1]; }

=head3 Getters

	$r->import_filename();
	$r->imported_lines();  # list reference
	$r->line_numbers();  # list reference
	$r->output_base();
	$r->channel();  # hash reference

=cut

	sub import_filename { $_[0]->{'import_filename'}; }
	sub imported_lines {
		defined( $_[0]->{'imported_lines'} )
			? $_[0]->{'imported_lines'}
			: undef;
	}
	sub line_numbers {
		defined( $_[0]->{'line_numbers'} )
			? $_[0]->{'line_numbers'}
			: undef;
	}
	sub output_base { $_[0]->{'output_base'}; }
	sub channel { $_[0]->{'channel'}; }

=head3 Other

=head4 print_categories()

Prints category scheme and exits.

Parameters: [ 0 = class ].

Return type: N/A.

=cut

sub print_categories {
	print @{ $_[0]->channel()->output_scheme() };
	exit;
}

=head4 print_input_files()

Calls channel method to list input files.  Note that channel method has same name as this feed method calling it.  This can confuse ctags and other indexing utilities.

Parameters: [ 0 = class ].

Return type: N/A.

=cut

sub print_input_files { $_[0]->channel()->list_input_files(); }

=head4 process_channel_inputs()

Calls channel method to process inputs.

Parameters: [ 0 = class ].

Return type: N/A.

=cut

sub process_channel_inputs { $_[0]->channel()->process_inputs(); }

=head4 feed_input_template()

Provides feed-related portion of input template as a List.

Parameters: [ 0 = class ].

Return type: List reference (each element is a line, each line terminated by newline).

=cut

sub feed_input_template {
	[ (
		"# Input file for dn-podcasts-rss\n" ,
		"\n" ,
		"# ********************************************************\n" ,
		"# This file provides all the information necessary for\n" ,
		"# dn-podcasts-rss to generate an RSS xml feed file as well\n" ,
		"# as an opml file that can be used to add the xml file\n" ,
		"# to an aggregator's subscription list.\n" ,
		"#\n" ,
		"# Obtaining Template\n" ,
		"# - you can write a copy to the current directory with\n" ,
		"#   the command 'dn-podcasts-rss -t'\n" ,
		"#\n" ,
		"# Assumptions\n" ,
		"# - the one directory holds all audio tracks, image\n" ,
		"#   files and the input file\n" ,
		"# - all audio files are mp3 format\n" ,
		"# - the rss feed contains only one channel\n" ,
		"#\n" ,
		"# Keys and Values\n" ,
		"# - this file consists of key-value pairs\n" ,
		"# - each key and value must be separated by a space --\n" ,
		"#   other whitespace such as tabs are NOT acceptable\n" ,
		"#   as a separator\n" ,
		"# - keys cannot contain whitespace\n" ,
		"# - values can contain whitespace\n" ,
		"# - neither key nor value needs to be enclosed in\n" ,
		"#   parentheses, even values containing whitespace\n" ,
		"# - some keys do not have an associated value -- these\n" ,
		"#   are keys instructing the import routine to take an\n" ,
		"#   action rather than accept data\n" ,
		"#\n" ,
		"# Values\n" ,
		"# - the content of values will form part of an xml\n" ,
		"#   file\n" ,
		"# - they will be part either of attribute or tag\n" ,
		"#   content\n" ,
		"# - you can use any of the five named character\n" ,
		"#   entities (&,<,>,',\") as they will be converted\n" ,
		"#   to their corresponding entities (&amp;,&lt;,\n" ,
		"#   &gt;,&apos;,&quot;) during import\n" ,
		"# - values cannot contain newlines\n" ,
		"# - as noted above in 'Keys and Values' some keys\n" ,
		"#   do not have an associated value\n" ,
		"# \n" ,
		"# Comments\n" ,
		"# - lines in this file beginning with a hash character\n" ,
		"#   (#) will be ignored during import\n" ,
		"# - lines consisting of nothing but whitespace will also\n" ,
		"#   be ignored\n" ,
		"# - some optional values are already commented out by\n" ,
		"#   default in this file\n" ,
		"#\n" ,
		"# Structure\n" ,
		"# - the RSS xml feed file specifies one channel\n" ,
		"# - the channel specifies one or more items, where an\n" ,
		"#   item is an audio file\n" ,
		"# - in this file, accordingly, there are feed-level,\n" ,
		"#   channel-level and item-level values\n" ,
		"#\n" ,
		"# Flags\n" ,
		"# - some flags are used in this file:\n" ,
		"#   [required] this key(-value) is required -- import\n" ,
		"#              will fail without it\n" ,
		"#   [optional] this key(-value) is not required\n" ,
		"#   [value]    a value is required for this key\n" ,
		"#   [key-only] this key takes no value -- any value\n" ,
		"#              present will be ignored\n" ,
		"#\n" ,
		"# Excluding Optional Values\n" ,
		"# - where a value is optional and you want to exclude it\n" ,
		"#   from import you can comment it out or delete it to\n" ,
		"#   make clear your intention\n" ,
		"# - if it requires a value (and this is always the case),\n" ,
		"#   you can cause it to be excluded simply by leaving it\n" ,
		"#   blank -- though this is not as clear an indication of\n" ,
		"#   your intentions as commenting it out or deleting it\n" ,
		"#   \n" ,
		"# ********************************************************\n" ,
		"\n" ,
		"# FEED\n" ,
		"\n" ,
		"# feed-output-base: basename of feed xml and opml files;\n" ,
		"#                   default if not specified is 'rss-feed';\n" ,
		"#                   an example is 'my-podcast-channel'\n" ,
		"#                   [optional][value]\n" ,
		"#feed-output-base \n" ,
		"\n" ,
		"\n" ,
	) ];
}

=head4 channel_input_template()

Provides channel-related portion of input template as a List.

Parameters: [ 0 = class ].

Return type: List reference (each element is a line, each line terminated by newline).

=cut

sub channel_input_template {
	[ (
		"# CHANNEL\n" ,
		"\n" ,
		"# channel-title: title of channel, e.g.,\n" ,
		"#                'My Podcast Channel'\n" ,
		"#                [required][value]\n" ,
		"channel-title \n" ,
		"\n" ,
		"# channel-base-url: this url will be prepended to all\n" ,
		"#                   audio, image and xml file urls in\n" ,
		"#                   generated xml feed and opml files;\n" ,
		"#                   a terminal slash is not required;\n" ,
		"#                   for example, if the mp3 files are\n" ,
		"#                   located in '/var/www/podcasts/mp3s/'\n" ,
		"#                   then the channel base url may be\n" ,
		"#                   'http://localhost/podcasts/mp3s'\n" ,
		"#                   [required][value]\n" ,
		"channel-base-url http://localhost/podcasts/\n" ,
		"\n" ,
		"# channel-language: language used in file; a two-letter\n" ,
		"#                   code as specified in ISO 639; if not\n" ,
		"#                   supplied the default of 'en' is used\n" ,
		"#                   [optional][value]\n" ,
		"#channel-language \n" ,
		"\n" ,
		"# channel-author: author/artist/performer of channel\n" ,
		"#                 content\n" ,
		"#                 [required][value]\n" ,
		"channel-author \n" ,
		"\n" ,
		"# channel-summary: description of channel contents; while\n" ,
		"#                  the importer will take the entire\n" ,
		"#                  value, the specification limits this\n" ,
		"#                  value to 4000 characters and some\n" ,
		"#                  aggregators may truncate beyond this\n" ,
		"#                  limit or reject the channel entirely;\n" ,
		"#                  this value is also used for a channel\n" ,
		"#                  description tag\n" ,
		"#                  [required][value]\n" ,
		"channel-summary \n" ,
		"\n" ,
		"# channel-image: file path of image file; this must be\n" ,
		"#                the file path from the working directory\n" ,
		"#                when the dn-podcasts-rss script is run; it\n" ,
		"#                must not include \"pseudo-directories\"\n" ,
		"#                such as './' and '../'; note that during\n" ,
		"#                rss feed and opml file output the base\n" ,
		"#                url will be prepended to this path;\n" ,
		"#                there is no provision in dn-podcasts-rss for\n" ,
		"#                item-level images (though according to\n" ,
		"#                the specification this is possible by\n" ,
		"#                using the audio file's metadata); only\n" ,
		"#                jpg and png image types are supported --\n" ,
		"#                other image formats will cause import to\n" ,
		"#                fail\n" ,
		"#                [required][value]\n" ,
		"channel-image \n" ,
		"\n" ,
		"# channel-category: the RSS xml feed specification\n" ,
		"#                   includes a two-level classification\n" ,
		"#                   scheme with category and sub-category;\n" ,
		"#                   depending on the classification you\n" ,
		"#                   may need to specify category only, or\n" ,
		"#                   both category and subcategory; to see\n" ,
		"#                   possible values view dn-podcasts-rss's man\n" ,
		"#                   page or execute the command\n" ,
		"#                   'dn-podcasts-rss -c'; an invalid\n" ,
		"#                   classification will cause import to\n" ,
		"#                   fail\n" ,
		"#                   [required][value]\n" ,
		"channel-category \n" ,
		"\n" ,
		"# channel-subcategory: see 'channel-category' for an\n" ,
		"#                      explanation of the classification\n" ,
		"#                      scheme; subcategory is not always\n" ,
		"#                      required\n" ,
		"#                      [optional][value]\n" ,
		"channel-subcategory \n" ,
		"\n" ,
		"# channel-explicit: indicates to aggregators whether\n" ,
		"#                   channel contains explicit content;\n" ,
		"#                   there are three values: 'yes'\n" ,
		"#                   indicates explicit content, 'clean'\n" ,
		"#                   indicates absence of explicit content\n" ,
		"#                   and aggregators may actively declare\n" ,
		"#                   the channel clean of explicit content,\n" ,
		"#                   and 'no' also signals absence of\n" ,
		"#                   explicit content although aggregators\n" ,
		"#                   will not actively signal this; the\n" ,
		"#                   default value of 'no' is used if this\n" ,
		"#                   is omitted\n" ,
		"#                   [optional][value]\n" ,
		"#channel-explicit yes\n" ,
		"#channel-explicit clean\n" ,
		"#channel-explicit no\n" ,
		"\n" ,
		"\n" ,
	) ];
}

=head4 item_input_template()

Provides item-related portion of input template as a List.

Parameters: [ 0 = class ].

Return type: List reference (each element is a line, each line terminated by newline).

=cut

sub item_input_template {
	[ (
		"# ITEM  (copy and paste this set of key-value pairs for\n" ,
		"#        each item)\n" ,
		"\n" ,
		"# item-start: instructs importer to begin new item\n" ,
		"#             [required][key-only]\n" ,
		"item-start\n" ,
		"\n" ,
		"# item-file: file path of audio file; this must be the\n" ,
		"#            file path from the working directory when the\n" ,
		"#            dn-podcasts-rss script is run; it must not\n" ,
		"#            include \"pseudo-directories\" such as './' and\n" ,
		"#            '../'; note that during rss feed and opml\n" ,
		"#            file output the base url will be prepended to\n" ,
		"#            this path; only mpeg/mp3 audio files are\n" ,
		"#            supported -- other audio formats will cause\n" ,
		"#            import to fail\n" ,
		"#            [required][value]\n" ,
		"item-file \n" ,
		"\n" ,
		"# item-title: title of audio track\n" ,
		"#              [required][value]\n" ,
		"item-title \n" ,
		"\n" ,
		"# item-author: track author/artist/performer\n" ,
		"#              [required][value]\n" ,
		"item-author \n" ,
		"\n" ,
		"# item-summary: description of audio track; while the\n" ,
		"#               importer will take the entire value, the\n" ,
		"#               specification limits this value to 4000\n" ,
		"#               characters and some aggregators may\n" ,
		"#               truncate beyond this limit or reject the\n" ,
		"#               item entirely\n" ,
		"#               [required][value]\n" ,
		"item-summary \n" ,
		"\n" ,
		"# item-explicit: indicates to aggregators whether audio\n" ,
		"#                file contains explicit content; there\n" ,
		"#                are three values: 'yes' indicates\n" ,
		"#                explicit content, 'clean' indicates\n" ,
		"#                absence of explicit content and\n" ,
		"#                aggregators may actively declare the item\n" ,
		"#                clean of explicit content, and 'no' also\n" ,
		"#                signals absence of explicit content\n" ,
		"#                although aggregators will not actively\n" ,
		"#                signal this; the default value of 'no' is\n" ,
		"#                used if this is omitted\n" ,
		"#                [optional][value]\n" ,
		"#item-explicit yes\n" ,
		"#item-explicit clean\n" ,
		"#item-explicit no\n" ,
		"\n" ,
		"# item-pubdate: publication date of audio track; must use\n" ,
		"#               RFC 2822 format such as this example date\n" ,
		"#               generated with the *nix command 'date\n" ,
		"#               --rfc-2822':\n" ,
		"#               Sun, 03 Jan 2010 14:13:33 +0930\n" ,
		"#               note time is in 24-hour format and the\n" ,
		"#               last element is the time zone offset; the\n" ,
		"#               offset must be in minutes (plus or minus)\n" ,
		"#               rather than time zone name such as GMT; a\n" ,
		"#               date not complying with this format will\n" ,
		"#               cause import to fail; the date validity is\n" ,
		"#               also checked -- an invalid date, or an\n" ,
		"#               incorrect day of the week for the date,\n" ,
		"#               will cause import to fail; podcasts will\n" ,
		"#               sort in reverse date order (most recent)\n" ,
		"#               first)\n" ,
		"#               [required][value]\n" ,
		"item-pubdate \n" ,
	) ];
}

=head4 metadata_input_template()

Provides template for metadata input file as a List.

Parameters: [ 0 = class ].

Return type: List reference (each element is a line, each line terminated by newline).

=cut

sub metadata_input_template {
	[ (
		"# Metadata input file for dn-podcasts-rss\n" ,
		"\n" ,
		"# ********************************************************\n" ,
		"# This file provides some of the information necessary for\n" ,
		"# dn-podcasts-rss to generate an input skeleton file.  The\n" ,
		"# input skeleton file is created by running dn-podcasts-rss\n" ,
		"# with the '-s' option.  If you run dn-podcasts-rss with only\n" ,
		"# the '-s' option it will include in the input skeleton\n" ,
		"# file values extracted from any audio mp3 files in the\n" ,
		"# current directory.  If you also pass the name of a\n" ,
		"# metadata file it will include, in addition to mp3-\n" ,
		"# derived values, values extracted from the metadata file.\n" ,
		"\n" ,
		"# It is possible to create a complete input skeleton file\n" ,
		"# with a properly configured metadata file and fully\n" ,
		"# tagged audio mp3 files.  When you have a complete input\n" ,
		"# file you can pass it as a parameter to dn-podcasts-rss to\n" ,
		"# create an xml rss feed and an opml file that can be used\n" ,
		"# to add the xml file to an aggregator's subscription\n" ,
		"# list.\n" ,
		"#\n" ,
		"# Obtaining Template\n" ,
		"# - you can write a copy to the current directory with\n" ,
		"#   the command 'dn-podcasts-rss -m'\n" ,
		"#\n" ,
		"# Keys and Values\n" ,
		"# - this file consists of key-value pairs\n" ,
		"# - each key and value must be separated by a space --\n" ,
		"#   other whitespace such as tabs are NOT acceptable\n" ,
		"#   as a separator\n" ,
		"# - keys cannot contain whitespace\n" ,
		"# - values can contain whitespace\n" ,
		"# - neither key nor value needs to be enclosed in\n" ,
		"#   parentheses, even values containing whitespace\n" ,
		"# - some keys do not have an associated value -- these\n" ,
		"#   are keys instructing the import routine to take an\n" ,
		"#   action rather than accept data\n" ,
		"#\n" ,
		"# Values\n" ,
		"# - the content of values will form part of an xml\n" ,
		"#   file\n" ,
		"# - they will be part either of attribute or tag\n" ,
		"#   content\n" ,
		"# - you can use any of the five named character\n" ,
		"#   entities (&,<,>,',\") as they will be converted\n" ,
		"#   to their corresponding entities (&amp;,&lt;,\n" ,
		"#   &gt;,&apos;,&quot;) during import\n" ,
		"# - values cannot contain newlines\n" ,
		"# - as noted above in 'Keys and Values' some keys\n" ,
		"#   do not have an associated value\n" ,
		"# \n" ,
		"# Comments\n" ,
		"# - lines in this file beginning with a hash character\n" ,
		"#   (#) will be ignored during import\n" ,
		"# - lines consisting of nothing but whitespace will also\n" ,
		"#   be ignored\n" ,
		"# - some optional values are already commented out by\n" ,
		"#   default in this file\n" ,
		"#\n" ,
		"# Structure\n" ,
		"# - the RSS xml feed file specifies one channel\n" ,
		"# - the channel specifies one or more items, where an\n" ,
		"#   item is an audio file\n" ,
		"# - in this file, accordingly, there are feed-level,\n" ,
		"#   channel-level and item-level values\n" ,
		"#\n" ,
		"# Flags\n" ,
		"# - some flags are used in this file:\n" ,
		"#   [required] this key(-value) is required -- import\n" ,
		"#              will fail without it\n" ,
		"#   [optional] this key(-value) is not required\n" ,
		"#   [value]    a value is required for this key\n" ,
		"#   [key-only] this key takes no value -- any value\n" ,
		"#              present will be ignored\n" ,
		"#\n" ,
		"# Excluding Optional Values\n" ,
		"# - where a value is optional and you want to exclude it\n" ,
		"#   from import you can comment it out or delete it to\n" ,
		"#   make clear your intention\n" ,
		"# - if it requires a value (and this is always the case),\n" ,
		"#   you can cause it to be excluded simply by leaving it\n" ,
		"#   blank -- though this is not as clear an indication of\n" ,
		"#   your intentions as commenting it out or deleting it\n" ,
		"#\n" ,
		"# Completeness\n" ,
		"# - all required keys must be provided by this file or\n" ,
		"#   input skeleton creation will fail\n" ,
		"# - all provided keys must have a non-empty value or\n" ,
		"#   input skeleton creation will fail\n" ,
		"# ********************************************************\n" ,
		"\n" ,
		"# FEED\n" ,
		"\n" ,
		"# feed-output-base: basename of feed xml and opml files;\n" ,
		"#                   default if not specified is 'rss-feed';\n" ,
		"#                   an example is 'my-podcast-channel'\n" ,
		"#                   [optional][value]\n" ,
		"feed-output-base \n" ,
		"\n" ,
		"\n" ,
		"# CHANNEL\n" ,
		"\n" ,
		"# channel-title: title of channel, e.g.,\n" ,
		"#                'My Podcast Channel'\n" ,
		"#                [required][value]\n" ,
		"channel-title \n" ,
		"\n" ,
		"# channel-base-url: this url will be prepended to all\n" ,
		"#                   audio, image and xml file urls in\n" ,
		"#                   generated xml feed and opml files;\n" ,
		"#                   a terminal slash is not required;\n" ,
		"#                   for example, if the mp3 files are\n" ,
		"#                   located in '/var/www/podcasts/mp3s/'\n" ,
		"#                   then the channel base url may be\n" ,
		"#                   'http://localhost/podcasts/mp3s'\n" ,
		"#                   [required][value]\n" ,
		"channel-base-url \n" ,
		"\n" ,
		"# channel-language: language used in podcast; a two-letter\n" ,
		"#                   code as specified in ISO 639; if not\n" ,
		"#                   supplied the default of 'en' is used\n" ,
		"#                   [optional][value]\n" ,
		"channel-language \n" ,
		"\n" ,
		"# channel-author: author/artist/performer of channel\n" ,
		"#                 content\n" ,
		"#                 [required][value]\n" ,
		"channel-author \n" ,
		"\n" ,
		"# channel-summary: description of channel contents; while\n" ,
		"#                  the importer will take the entire\n" ,
		"#                  value, the specification limits this\n" ,
		"#                  value to 4000 characters and some\n" ,
		"#                  aggregators may truncate beyond this\n" ,
		"#                  limit or reject the channel entirely;\n" ,
		"#                  this value is also used for a channel\n" ,
		"#                  description tag\n" ,
		"#                  [required][value]\n" ,
		"channel-summary \n" ,
		"\n" ,
		"# channel-image: file path of image file; this must be\n" ,
		"#                the file path from the working directory\n" ,
		"#                when the dn-podcasts-rss script is run; it\n" ,
		"#                must not include \"pseudo-directories\"\n" ,
		"#                such as './' and '../'; note that during\n" ,
		"#                rss feed and opml file output the base\n" ,
		"#                url will be prepended to this path;\n" ,
		"#                there is no provision in dn-podcasts-rss for\n" ,
		"#                item-level images (though according to\n" ,
		"#                the specification this is possible by\n" ,
		"#                using the audio file's metadata); only\n" ,
		"#                jpg and png image types are supported --\n" ,
		"#                other image formats will cause import to\n" ,
		"#                fail\n" ,
		"#                [required][value]\n" ,
		"channel-image \n" ,
		"\n" ,
		"# channel-category: the RSS xml feed specification\n" ,
		"#                   includes a two-level classification\n" ,
		"#                   scheme with category and sub-category;\n" ,
		"#                   depending on the classification you\n" ,
		"#                   may need to specify category only, or\n" ,
		"#                   both category and subcategory; to see\n" ,
		"#                   possible values view dn-podcasts-rss's man\n" ,
		"#                   page or execute the command\n" ,
		"#                   'dn-podcasts-rss -c'; an invalid\n" ,
		"#                   classification will cause import to\n" ,
		"#                   fail\n" ,
		"#                   [required][value]\n" ,
		"channel-category \n" ,
		"\n" ,
		"# channel-subcategory: see 'channel-category' for an\n" ,
		"#                      explanation of the classification\n" ,
		"#                      scheme; subcategory is not always\n" ,
		"#                      required\n" ,
		"#                      [optional][value]\n" ,
		"channel-subcategory \n" ,
		"\n" ,
		"# channel-explicit: indicates to aggregators whether\n" ,
		"#                   channel contains explicit content;\n" ,
		"#                   there are three values: 'yes'\n" ,
		"#                   indicates explicit content, 'clean'\n" ,
		"#                   indicates absence of explicit content\n" ,
		"#                   and aggregators may actively declare\n" ,
		"#                   the channel clean of explicit content,\n" ,
		"#                   and 'no' also signals absence of\n" ,
		"#                   explicit content although aggregators\n" ,
		"#                   will not actively signal this; the\n" ,
		"#                   default value of 'no' is used if this\n" ,
		"#                   is omitted\n" ,
		"#                   [optional][value]\n" ,
		"channel-explicit \n" ,
		"#channel-explicit yes\n" ,
		"#channel-explicit clean\n" ,
		"#channel-explicit no\n" ,
		"\n" ,
		"\n" ,
		"# ITEM\n" ,
		"\n" ,
		"# ********************************************************\n" ,
		"##########################################################\n" ,
		"# notes on publication date and podcasts:\n" ,
		"# - publication date is required for each item, i.e., each\n" ,
		"#   audio mp3 file\n" ,
		"# - publication date determines the order in which the mp3\n" ,
		"#   files (aka podcasts or tracks) are displayed in\n" ,
		"#   players\n" ,
		"# - podcasts sort in reverse date order, i.e., most recent\n" ,
		"#   first\n" ,
		"# - podcasts will be referenced in an input skeleton file\n" ,
		"#   in the default order used by the perl 'glob' function,\n" ,
		"#   i.e., in alphabetical order\n" ,
		"##########################################################\n" ,
		"\n" ,
		"# pubdate-method: indicates how podcast publication dates\n" ,
		"#                 will be selected; there are three\n" ,
		"#                 values: 'descend' means arbitrary\n" ,
		"#                 pubdates will be assigned to podcasts\n" ,
		"#                 descending order (most recent first and\n" ,
		"#                 then getting older) having the effect of\n" ,
		"#                 podcasts displaying in the same order as\n" ,
		"#                 they list with the perl glob function\n" ,
		"#                 (use for a discrete set of podcasts)\n" ,
		"#                 'ascend' means arbitrary pubdates will\n" ,
		"#                 be assigned to podcasts in ascending\n" ,
		"#                 order (oldest first and then getting\n" ,
		"#                 more recent) having the effect of\n" ,
		"#                 podcasts displaying in the reverse of\n" ,
		"#                 the order they list with the perl\n" ,
		"#                 glob function (use for ongoing\n" ,
		"#                 titles), and 'provide' means pubdates\n" ,
		"#                 are supplied in this metadata file using\n" ,
		"#                 'pubdate' keys (see below); select only\n" ,
		"#                 one pubdate method\n" ,
		"#                 [required][value]\n" ,
		"pubdate-method \n" ,
		"# pubdate-method descend\n" ,
		"# pubdate-method ascend\n" ,
		"# pubdate-method provide\n" ,
	) ];
}
=head4 write_input_template()

Write input file template to current directory.  If a file of that name already exists it will be renamed before writing the new file.

An input file template lists all input keys and is self-documented.

Parameters: [ 0 = class ].

Return type: N/A.

=cut

sub write_input_template {
	my ( $self ) = ( shift );
	my @output = ( @{ $self->feed_input_template() } ,
		           @{ $self->channel_input_template() } ,
		           @{ $self->item_input_template() }
	);
	$self->write_file( 'input.template' , \@output );
}

=head4 write_input_metadata()

Creates metadata input file template in current directory.  If a file of that name already exists the user can edit and add to file data.  If it does not exists one will be written and the user will have a chance to add data to it.

A metadata input file provides all values needed in an input skeleton file not extracted from audio mp3 files.

Parameters: [ 0 = class ].

Return type: N/A.

=cut

sub write_input_metadata {
	my ( $self , %extracted , %existing ) = ( shift );
	my ( $filename ) = ( $self->metadata_file() );
	# get data if file already exists
	my @output = @{ $self->metadata_input_template() };
	my $metadata = DnChannel->new()->enter_metadata();
	@output = @{ $self->insert_values( \@output , $metadata ) };
	$self->write_file( $filename , \@output );
}

=head4 write_input_skeleton()

Write input file skeleton to current directory.  If a file of that name already exists it will be renamed before writing the new file.

An input file skeleton is like an input file template except that it includes a set of item keys for each mp3 file in the current directory.  The 'item-file' key for each item has the file name already set.

Attempts to intelligently set author, title and summary keys for each item from mp3 tags.

Uses metadata input file if present in the working directory.  This file can provide feed and channel values.  Can also use publication date input file if present.  This file supplies mp3/podcast publication dates.

Parameters: [ 0 = class ].

Return type: N/A.

=cut

sub write_input_skeleton {
	my ( $self , $using_metadata , @mp3_files , @pubdates )
		= ( shift , FALSE );
	my ( $metadata_file ) = ( $self->metadata_file() );
	# import file checks
	if ( -e $metadata_file ) {
		printf "Using metadata file '%s'\n" , $metadata_file;
		$using_metadata = TRUE;
	} else {
		print "No metadata file '$metadata_file' found\n";
	}
	# add feed and channel skeleton
	my @output = ( @{ $self->feed_input_template() } ,
		           @{ $self->channel_input_template() }
	);
	# need mp3 files list for metadata substitution and items skeleton
	@mp3_files = @{ DnChannel->new()->podcast_files() };
##	my @all_files = glob "*";
##	for ( @all_files ) {
##		push @mp3_files , $_ if DnItem->new( $_ )->audio_mime_type();
##	}
	# process metadata file if available
	if ( $using_metadata ) {
		my @metadata = @{ $self->extract_file_data( $metadata_file ) };
		# exit if metadata invalid
		DnChannel->new( \@metadata )->validate_metadata();
		# insert metadata into skeleton array
		my %key_values;
		$key_values{$_->{'key'}}{'value'} = $_->{'value'} foreach @metadata;
		@output = @{ $self->insert_values( \@output , \%key_values ) };
		# get list of pubdates
		@pubdates 
			= @{ DnChannel->new( \@mp3_files , \@metadata )->pubdates(); }
	}
	# add items skeletons
	for ( @mp3_files ) {
		my @item = $self->item_input_template();
		shift @item ; shift @item; unshift @item , "# ITEMS\n";
		# construct substitution hash and perform substitution
		my %key_values;
		$key_values{'item-file'}{'value'} = $_;
		$key_values{'item-title'}{'value'} = $self->mp3_title( $_ );
		$key_values{'item-author'}{'value'} = $self->mp3_author( $_ );
		$key_values{'item-summary'}{'value'} = $self->mp3_comment( $_ );
		if ( $using_metadata ) {
			$key_values{'item-pubdate'}{'value'} =
				$self->iso_to_rfc2822( shift @pubdates );
		};
		foreach ( keys %key_values ) {
			delete $key_values{$_} if not $key_values{$_}{'value'};
		}
		@item = @{ $self->insert_values( \@item , \%key_values ) };
		# add item
		push @output , @item , "\n" , "\n";
	}
	# write file skeleton
	$self->write_file( 'input.skeleton' , \@output );
}

=head4 import_feed()

Reads RSS feed data from import file into List.  Only imports data lines, i.e., ignores blank and comments lines.  A second List of matching input file line numbers for each imported line is also built during import.

Gets import file name from 'import_filename' data member.

Adds terminal 'item_start' key to ensure last item is added to channel at end of import.

Assigns imported List of data lines to 'imported_lines' data member.  Assigns imported List of line lumbers to 'line_numbers' data member.

Parameters: [ 0 = class ].

Return type: Boolean (= success of import).

=cut

sub import_feed {
	my ( $self , $count , @lines , @numbers , $key ) = ( shift , 0 );
	my $file = $self->import_filename();
	# import file sanity checks
	die "No import file provided\n" if not $file;
	die "Invalid import file\n" if not -e $file;
	# read from file
	open IMPORT , "<$file"
		or die "Unable to read from $file\n ($!)\n";
	while ( <IMPORT> ) {
		chomp;
		$count++;
		# do not add blank or comment lines
		$key = ( split / / )[0];
		next if not $key;
		next if substr( $key , 0 , 1 ) eq '#';
		# add data lines and corresponding line numbers
		push @lines , $self->entitise( $_ );
		push @numbers , $count;
	}
	die "No lines imported\n" if not @lines;
	push @lines , "item-start";  # ensure last item processed
	# save
	$self->add_imported_lines( \@lines );
	$self->add_line_numbers( \@numbers );
}

=head4 process_feed()

Reads RSS feed data from import file.

Parameters: [ 0 = class ].

Return type: Boolean (= success of import).

=cut

sub process_feed {
	my ( $self , $index , $key , @values , $value ) = ( shift , -1 );
	my $channel = DnChannel->new();
	my $item = DnItem->new();
	my @lines = @{ $self->imported_lines() };
	my @numbers = @{ $self->line_numbers() };
	for ( @lines ) {
		$index++;
		# get key and value
		( $key , @values ) = split / /;
		$value = join ' ' , @values;
		# process key and value
		# switch: $key
		# case: 'feed-output-base'
		( grep $key eq $_ , qw/ feed-output-base / ) and do {
			$self->set_output_base( $value ) if $value;
		};
		# case: 'channel-title'
		( grep $key eq $_ , qw/ channel-title / ) and do {
			die "Error: value required in line $numbers[$index]\n" if not $value;
			$channel->set_title( $value );
		};
		# case: 'channel-base-url'
		( grep $key eq $_ , qw/ channel-base-url / ) and do {
			die "Error: value required in line $numbers[$index]\n" if not $value;
			$channel->set_base_url( $value );
		};
		# case: 'channel-language'
		( grep $key eq $_ , qw/ channel-language / ) and do {
			$channel->set_language( $value ) if $value;
		};
		# case: 'channel-author'
		( grep $key eq $_ , qw/ channel-author / ) and do {
			die "Error: value required in line $numbers[$index]\n" if not $value;
			$channel->set_author( $value );
		};
		# case: 'channel-summary'
		( grep $key eq $_ , qw/ channel-summary / ) and do {
			die "Error: value required in line $numbers[$index]\n" if not $value;
			$channel->set_summary( $value );
		};
		# case: 'channel-image'
		( grep $key eq $_ , qw/ channel-image / ) and do {
			die "Error: value required in line $numbers[$index]\n" if not $value;
			$channel->set_image( $value );
		};
		# case: 'channel-category'
		( grep $key eq $_ , qw/ channel-category / ) and do {
			die "Error: value required in line $numbers[$index]\n" if not $value;
			$channel->set_category( $value );
		};
		# case: 'channel-subcategory'
		( grep $key eq $_ , qw/ channel-subcategory / ) and do {
			$channel->set_subcategory( $value ) if $value;
		};
		# case: 'channel-explicit'
		( grep $key eq $_ , qw/ channel-explicit / ) and do {
			$channel->set_explicit( $value ) if $value;
		};
		# case: 'item-start'
		( grep $key eq $_ , qw/ item-start / ) and do {
			if ( not $item->empty() ) {  # do nothing if empty item
				if ( $item->complete() ) {
					my $copy_item = $self->copy_ref( $item );
					$channel->add_item( $copy_item );
				} else {
					die "Incomplete item ended at line $numbers[$index]\n";
				}
				$item->clear();
			}
		};
		# case: 'item-file'
		( grep $key eq $_ , qw/ item-file / ) and do {
			die "Error: value required in line $numbers[$index]\n" if not $value;
			# check file validity because deriving duration, size, mime type
			# during import
			die "Error: invalid file name '$value' at line $numbers[$index]\n"
				if not -e $value;
			$item->set_filepath( $value );
		};
		# case: 'item-title'
		( grep $key eq $_ , qw/ item-title / ) and do {
			die "Error: value required in line $numbers[$index]\n" if not $value;
			$item->set_title( $value );
		};
		# case: 'item-author'
		( grep $key eq $_ , qw/ item-author / ) and do {
			die "Error: value required in line $numbers[$index]\n" if not $value;
			$item->set_author( $value );
		};
		# case: 'item-summary'
		( grep $key eq $_ , qw/ item-summary / ) and do {
			die "Error: value required in line $numbers[$index]\n" if not $value;
			$item->set_summary( $value );
		};
		# case: 'item-explicit'
		( grep $key eq $_ , qw/ item-explicit / ) and do {
			$item->set_explicit( $value ) if $value;
		};
		# case: 'item-pubdate'
		( grep $key eq $_ , qw/ item-pubdate / ) and do {
			die "Error: value required in line $numbers[$index]\n" if not $value;
			$item->set_pubdate( $value );
		};
		# case: default
		( not grep $key eq $_ , qw/ feed-output-base channel-title
				channel-base-url channel-language channel-author
				channel-summary channel-image channel-category
				channel-subcategory channel-explicit item-start item-file
				item-title item-author item-summary item-explicit item-pubdate /
		) and do {
			die "Invalid key '$key' at line $numbers[$index]\n";
		};
	}
	close IMPORT;
	# now add channel
	if ( not $channel->empty() ) {
		if ( $channel->complete() ) {
			$self->set_channel( $channel );
		} else {
			die "Incomplete item ended at line $numbers[$index]\n";
		}
	} else {
		die "Empty channel after import\n";
	}
}

=head4 xml()

Generates RSS feed xml as a List.  The easiest way to display the content is with:

	print $_ foreach $rss->xml();

Parameters: [ 0 = class ].

Return type: List reference (one line per element, newline ends each line).

=cut

sub xml {
	my ( $self , @xml ) = ( shift , () );
	# write xml
	push @xml , "<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\n";
	push @xml , "<rss xmlns:itunes=\"http://www.itunes.com/dtds/podcast-1.0.dtd\" \n";
	push @xml , "     xmlns:media=\"http://search.yahoo.com/mrss/\" \n";
	push @xml , "     xmlns:creativeCommons=\"http://backend.userland.com/creativeCommonsRssModule\" \n";
	push @xml , "     version=\"2.0\">\n";
	# export channel
	push @xml , @{ $self->channel()->xml( 1 ) };
	# complete xml and return result
	push @xml , "</rss>\n";
	\@xml;
}

=head4 opml()

Generates content of an OPML file that can be used to add the RSS feed to an aggregator's subscription list.  The easiest way to display it is with:

	print $_ foreach $rss->opml();

Because the feed xml contains only one channel, the OPML file can use the channel title and summary for the feed title and outline, respectively.

Parameters: [ 0 = class ].

Return type: List reference (one line per element, newline ends each line).

=cut

sub opml {
	my ( $self , @opml ) = ( shift , () );
	my $channel = $self->channel();
	# write opml
	push @opml , "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n";
	push @opml , "<opml version=\"2.0\">\n";
	push @opml , "\t<head>\n";
	push @opml , sprintf( "\t\t<title>%s</title>\n" , $channel->title() );
	push @opml , sprintf( "\t\t<dateCreated>%s</dateCreated>\n" ,
		                  $self->now_rfc2822() );
	push @opml , "\t</head>\n";
	push @opml , "\t<body>\n";
	push @opml , sprintf( "\t\t<outline text=\"%s\" \n" ,
		                  $channel->summary() ); 
	push @opml , sprintf( "\t\t         title=\"%s\" \n" ,
						  $channel->title() ,); 
	push @opml , sprintf( "\t\t         type=\"rss\" \n" );
	push @opml , sprintf( "\t\t         xmlUrl=\"%s/%s.xml\"/>\n" ,
						  $channel->base_url() ,
						  $self->output_base() ); 
	push @opml , "\t</body>\n";
	push @opml , "</opml>\n";
	# return result
	\@opml;
}


=head1 PACKAGE: main

The main program.

=cut

package main;

=head2 Dependencies

The following perl modules are required:

=head3 Getopt::Declare

Used for parameter processing.

Debian: provided by package 'libgetopt-declare-perl'.

=cut

use Getopt::Declare;

our $VERSION = "0.1";

my $args = new Getopt::Declare (<<'EOPARAM');
DESCRIPTION

This script takes an input file describing podcast files
and generates an rss feed (xml) file along with a
subscription opml file that can be used to add the feed
to an aggregator.

This script can generate a template input file that is
self documenting.

It can also generate a skeleton input file based on mp3
audio files in the current directory.  The skeleton file
is like a template file except that it contains information
extracted from any mp3 files in the current directory.  The
skeleton input file will have a section for each mp3 file,
each including file name, track title, track author and
track summary inserted where they can be extracted from mp3
tags (title = mp3 title tag, track author = mp3 performer
tag, and track summary = mp3 comment tag).

When the skeleton input file is being written there are
channel and feed values that cannot be extracted from
existing mp3 files.  These values can be extracted from a
user-created metadata file.  A self-documented template
metadata file can be generated in the current directory. It
can be passed as a parameter when generating a skeleton
input file to ensure its contents are used.  This is
particularly useful when you will be repeatedly rebuilding
an rss feed file.  The combination of a proper metadata
file and fully tagged audio mp3 files ensures an rss feed
file can be quickly regenerated with just two commands:
'dn-podcasts-rss -s input.metadata' and
'dn-podcasts-rss input.skeleton'.

USAGE

	dn-podcasts-rss
	dn-podcasts-rss -c
	dn-podcasts-rss -i
	dn-podcasts-rss -h

OPTIONS

	-c	print the category scheme and exit
		\[overrides all other flags]
	-i	list input file names and exit
		\[overrides all flags but '-c']
EOPARAM

=head2 Description

First handles parameters.  If '-c' is passed then print category scheme and exit.  If '-i' is passed then list input files and exit.

=cut

my $feed = DnFeed->new();

$feed->print_categories()  if $args->{'-c'};
$feed->print_input_files() if $args->{'-i'};

=pod

First step is to process any new podcasts.  Any files already in the published podcasts input file ('INPUT.published') are ignored.  Remaining files are checked to ensure they are named according to the filename template and have appropriate audio file tags.

=cut

$feed->process_channel_inputs();

=pod

Then import and process input file.

=cut

#$feed->import_feed();
#$feed->process_feed();

=pod

Finally, output feed xml and subscription opml files.  Note that rather than overwrite an existing output file, the existing file is renamed.

=cut

#my @opml = @{ $feed->opml() };
#my $opml_filename = $feed->output_base() . '.opml';
#DnLib->new( $opml_filename , \@opml )->write_file();
#printf "Subscription opml file '%s' written\n" , $opml_filename;
#
#my @xml = @{ $feed->xml() };
#my $xml_filename = $feed->output_base() . '.xml';
#DnLib->new( $xml_filename , \@xml )->write_file();
#printf "Feed xml file '%s' written\n" , $xml_filename;

=head1 AUTHOR

David Nebauer, david E<lt>atE<gt> nebauer E<lt>dotE<gt> org
