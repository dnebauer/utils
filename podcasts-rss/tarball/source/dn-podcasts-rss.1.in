.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DN-PODCASTS-RSS.IN 1"
.TH DN-PODCASTS-RSS.IN 1 "2011-07-09" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
dn\-podcasts\-rss \- generates an rss feed (xml) file from an input file
.SH "SUMMARY"
.IX Header "SUMMARY"
Takes an input file describing podcast files and generates an rss feed (xml) file along with a subscription opml file that can be used to add the feed.
.PP
Can also generate self-documenting template, skeleton and metadata input files.
.SH "USAGE"
.IX Header "USAGE"
dn-podcasts-rss <input_file>
.Sp
.RS 4
This is the standard usage.  The input file is parsed and an rss feed (xml) file is generated.  A subscription opml file is also generated and can be used for adding the feed to an aggregator.
.Sp
The output files are called 'rss\-feed.xml' and 'rss\-feed.opml' by default but the file basename can be changed in the input file.
.RE
.PP
dn-podcasts-rss \-c
.Sp
.RS 4
Display categorisation scheme for rss channels.
.RE
.PP
dn-podcasts-rss \-t
.Sp
.RS 4
Write a template input file in the current directory.  This file is self-documenting.  It contains each rss feed, channel and item key.
.RE
.PP
dn-podcasts-rss \-m
.Sp
.RS 4
Write a self-documenting template metadata input file in the current directory.  The input skeleton file (see following option) includes information extracted from audio mp3 files in the current directory.  There are a number of feed\- and channel-related values which the input skeleton file requires but cannot be extracted from audio mp3 files.  These values can be extracted from a metadata file.  The name of this metadata file can be passed as a parameter when generating a skeleton input file to ensure its contents are used.
.Sp
During file creation the user is prompted to enter or select the metadata values stored in the file.  System-specific information about the channel url and base podcast directory are stored in the self-documented configuration file '/etc/dn\-podcasts\-rss/dn\-podcasts\-rssrc'.  This configuration file should be edited before creating a metadata file.
.Sp
A metadata input file is particularly useful when you will be repeatedly rebuilding an rss feed file.  The combination of a proper metadata file and fully tagged audio mp3 files ensures an rss feed file can be quickly regenerated with just two commands: 'dn\-podcasts\-rss \-s input.metadata' and 'dn\-podcasts\-rss input.skeleton'.
.RE
.PP
dn-podcasts-rss \-s [<metadata_file>]
.Sp
.RS 4
Write a skeleton input file in the current directory.  This file is self-documenting.  It is like a template file except that it includes an item section for each mp3/mpeg audio file in the current directory.  The following are, where possible, entered for each item: file name, track title, track author and track summary.  There is no \s-1MP3\s0 tag that neatly corresponds to author, so the 'composer' field and 'artist' tag are queried in that order and the first value found is used as author.  The 'comment' tag is used for track summary.
.Sp
Feed\- and channel-related values can be supplied by a properly configured metadata file.  As explained above, a properly configured metadata file and appropriately tagged audio mp3 files can result in this command creating a fully configured input skeleton file.
.RE
.PP
dn-podcasts-rss \-h
.Sp
.RS 4
Displays help text and exits.
.RE
.SH "STRUCTURE"
.IX Header "STRUCTURE"
\&\s-1RSS\s0 feed files consist of one or more channels, each of which contains one or more items.  Each item is a single audio track.  In this implementation there is only one channel per \s-1RSS\s0 feed.  If you have multiple channels you will have to create an \s-1RSS\s0 feed for each one.
.PP
This script, in corresponding design, defines 'DnFeed', 'DnChannel' and 'DnItem' classes (packages).
.PP
References are made to the Apple specification for \s-1RSS\s0 feeds.  This specification was accessed at \f(CW\*(C`http://www.apple.com/itunes/podcasts/specs.html\*(C'\fR on or about 2010\-01\-03.
.SH "PACKAGE: DnLib"
.IX Header "PACKAGE: DnLib"
An internal helper class providing a library of useful functions.
.PP
One aim of creating this class is to put all methods and functions from dependent modules in this class.  Other packages then do not need to utilise other modules.
.SS "Dependencies"
.IX Subsection "Dependencies"
The following perl modules are required:
.PP
\fIFile::Util\fR
.IX Subsection "File::Util"
.PP
Provides 'size' method for getting file size.
.PP
Debian: provided by package 'libfile\-util\-perl'.
.PP
\fIFile::Type\fR
.IX Subsection "File::Type"
.PP
Provides 'mime_type' method for getting mime-type information about mp3 files.
.PP
Debian: provided by package 'libfile\-type\-perl'.
.PP
\fIMP3::Info\fR
.IX Subsection "MP3::Info"
.PP
Provides methods for getting information about mp3 files.  Provides function 'get_mp3info' which, among other things, returns track duration.
.PP
Debian: provided by package 'libmp3\-info\-perl'.
.PP
\fIMP3::Tag\fR
.IX Subsection "MP3::Tag"
.PP
Enables querying of mp3 tags and fields.  Provides 'title', 'artist' and 'composer' methods to get track title, artist and composer.  The composer field often is not set: if so, the 'composer' method will use the 'artist' tag.
.PP
Debian: provided by package 'libmp3\-tag\-perl'.
.PP
\fIData::UUID\fR
.IX Subsection "Data::UUID"
.PP
Provides universally/globally unique identifiers (UUIDs and GUIDs).
.PP
Debian: provided by package 'libossp\-uuid\-perl'.
.PP
\fILocale::Language\fR
.IX Subsection "Locale::Language"
.PP
Used for determining valid language codes.  Provides the 'code2language' function.
.PP
Debian: provided by package 'perl\-modules'.
.PP
\fIDate::Calc\fR
.IX Subsection "Date::Calc"
.PP
Provides functions for manipulating date-times, including 'check_date', 'check_time', 'Day_of_Week', 'Decode_Day_of_Week', 'Decode_Month' and Add_Delta_days.
.PP
Debian: provided by package 'libdate\-calc\-perl'.
.PP
\fITime::ParseDate\fR
.IX Subsection "Time::ParseDate"
.PP
Convert date to seconds since epoch. Provides the 'parsedate' function.
.PP
Debian: provided by package 'libtime\-modules\-perl'.
.PP
\fIEmail::Date::Format\fR
.IX Subsection "Email::Date::Format"
.PP
Enable writing of current time in \s-1RFC\s0 2822 format.  Provides the 'email_date' function.
.PP
Debian: provided by package 'libemail\-date\-format\-perl'.
.PP
\fIFile::Copy\fR
.IX Subsection "File::Copy"
.PP
Used for file copying.  Provides the 'copy' and 'move' functions.
.PP
Debian: provided by package 'perl\-modules'.
.PP
\fIStorable\fR
.IX Subsection "Storable"
.PP
Handles storage for perl.  Provides the 'dclone' function.
.PP
Debian: provided by package 'perl'.
.PP
\fIFile::Basename\fR
.IX Subsection "File::Basename"
.PP
Parse file names.  Provides the 'fileparse' method.
.PP
Debian: provided by package 'perl'.
.PP
\fIData::Dumper\fR
.IX Subsection "Data::Dumper"
.PP
View content of variables.  Provides the 'Dumper' method.
.PP
Debian: provided by package 'perl\-modules'.
.SS "Methods"
.IX Subsection "Methods"
\fIData Members\fR
.IX Subsection "Data Members"
.PP
\&\f(CW%self\fR = (
.PP
.Vb 1
\&        $datum    =>  "<datum>" ,
\&
\&        $datum_1  =>  "<datum_1>" ,
\&
\&        $datum_2  =>  "<datum_2>" ,
.Ve
.PP
)
.IP "\(bu" 4
\&\fBdatum\fR
.Sp
Generic container for holding a (reference to a) variable.  The general design is that a datum is passed to the object at construction time and the operated upon by a method.  In this way a result can be obtained with a formulation such as:
.Sp
.Vb 1
\&        my $track_length = DnLib\->new( $audio_file_path )\->duration();
.Ve
.IP "\(bu" 4
\&\fBdatum_1\fR
.Sp
Second generic container for holding a (reference to a) variable.
.IP "\(bu" 4
\&\fBdatum_2\fR
.Sp
Third generic container for holding a (reference to a) variable.
.PP
\fIConstructors\fR
.IX Subsection "Constructors"
.PP
There are two method signatures.  One accepts no arguments while the other accepts one argument.
.PP
.Vb 2
\&        my $ojb = new DnItem;  OR  my $ojb = DnItem\->new();
\&        my $ojb = DnItem\->new( "<datum>" );
.Ve
.PP
\fISetters\fR
.IX Subsection "Setters"
.PP
.Vb 3
\&        $i\->set_datum( \*(Aq<datum>\*(Aq );
\&        $i\->set_datum_1( \*(Aq<datum_1>\*(Aq );
\&        $i\->set_datum_2( \*(Aq<datum_2>\*(Aq );
.Ve
.PP
\fIGetters\fR
.IX Subsection "Getters"
.PP
.Vb 3
\&        $i\->datum();
\&        $i\->datum_1();
\&        $i\->datum_2();
.Ve
.PP
\fIOther\fR
.IX Subsection "Other"
.PP
\fIfile_size()\fR
.IX Subsection "file_size()"
.PP
Get file size in bytes.
.PP
Uses File::Util module.
.PP
Because this method uses the 'datum' data member, you can obtain a result with:
.PP
.Vb 1
\&        my $duration = DnLib\->new( $mp3_file )\->file_size();
.Ve
.PP
Parameters: [ 0 = class ].
.PP
Uses data mambers: datum = mp3 file name.
.PP
Return type: Scalar [integer].
.PP
\fIguid()\fR
.IX Subsection "guid()"
.PP
Create \s-1GUID\s0.
.PP
Uses Data::UUID module.
.PP
You can obtain a result with:
.PP
.Vb 1
\&        my $guid = DnLib\->new()\->guid();
.Ve
.PP
Parameters: [ 0 = class ].
.PP
Uses data mambers: N/A.
.PP
Return type: Scalar [\s-1UUID\s0].
.PP
\fImp3_duration()\fR
.IX Subsection "mp3_duration()"
.PP
Get duration of audio mp3 file.
.PP
Uses 'get_mp3info' method from MP3::Info module.
.PP
Because this method uses the 'datum' data member, you can obtain a result with:
.PP
.Vb 1
\&        my $duration = DnLib\->new( $mp3_file )\->mp3_duration();
.Ve
.PP
Parameters: [ 0 = class ].
.PP
Uses data mambers: datum = mp3 file name.
.PP
Return type: Scalar ('\s-1HH:MM\s0').
.PP
\fImp3_title()\fR
.IX Subsection "mp3_title()"
.PP
Get title of audio mp3 file.
.PP
Uses 'title' method from MP3::Tag module.  Returns the 'title' tag.
.PP
Because this method uses the 'datum' data member, you can obtain a result with:
.PP
.Vb 1
\&        my $title = DnLib\->new( $mp3_file )\->mp3_title();
.Ve
.PP
Parameters: [ 0 = class ].
.PP
Uses data mambers: datum = mp3 file name.
.PP
Return type: Scalar (string).
.PP
\fImp3_author()\fR
.IX Subsection "mp3_author()"
.PP
Get author of audio mp3 file.  Attempts to return the 'composer' field.  If that fails, it returns the artist.
.PP
Uses 'composer' method from MP3::Tag module.
.PP
Because this method uses the 'datum' data member, you can obtain a result with:
.PP
.Vb 1
\&        my $author = DnLib\->new( $mp3_file )\->mp3_author();
.Ve
.PP
Parameters: [ 0 = class ].
.PP
Uses data mambers: datum = mp3 file name.
.PP
Return type: Scalar (string).
.PP
\fImp3_comment()\fR
.IX Subsection "mp3_comment()"
.PP
Get comment from audio mp3 file.
.PP
Uses 'comment' method from MP3::Tag module.  Returns the 'comment' tag.
.PP
Because this method uses the 'datum' data member, you can obtain a result with:
.PP
.Vb 1
\&        my $title = DnLib\->new( $mp3_file )\->mp3_comment();
.Ve
.PP
Parameters: [ 0 = class ].
.PP
Uses data mambers: datum = mp3 file name.
.PP
Return type: Scalar (string).
.PP
\fImime_type()\fR
.IX Subsection "mime_type()"
.PP
Get mime type of file.
.PP
Uses File::Type module.
.PP
Because this method uses the 'datum' data member, you can obtain a result with:
.PP
.Vb 1
\&        my $duration = DnLib\->new( $mp3_file )\->mime_type();
.Ve
.PP
Parameters: [ 0 = class ].
.PP
Uses data mambers: datum = mp3 file name.
.PP
Return type: Scalar.
.PP
\fIvalid_iso_date()\fR
.IX Subsection "valid_iso_date()"
.PP
Checks validity of a date.  All parameters are supplied as integers.  Year is all four digits.
.PP
Uses 'check_date' function from Date::Calc module.
.PP
Because this method uses the 'datum*' data members, you can obtain a result with:
.PP
.Vb 2
\&        if ( DnLib\->new( $y , $m , $d )\->valid_iso_date() ) {
\&                ...
.Ve
.PP
Parameters: [ 0 = class ].
.PP
Uses data mambers: datum = year (yyyy) , datum_1 = month (mm) , datum_2 = day (dd).
.PP
Return type: Boolean.
.PP
\fIvalid_time()\fR
.IX Subsection "valid_time()"
.PP
Check validity of a time.  All parameters are supplied as integers.  Time is 24\-hour time.
.PP
Uses 'check_time' function from Date::Calc module.
.PP
Because this method uses the 'datum*' data members, you can obtain a result with:
.PP
.Vb 2
\&        if ( DnLib\->new( $h , $m , $s )\->valid_time() ) {
\&                ...
.Ve
.PP
Parameters: [ 0 = class ].
.PP
Uses data mambers: datum = hour (hh) , datum_1 = minute (mm) , datum_2 = second (ss).
.PP
Return type: Boolean.
.PP
\fIday_of_week_index()\fR
.IX Subsection "day_of_week_index()"
.PP
Determines which day of the week a given date falls upon.  The return value is an integer ranging from 1 (Monday) to 7 (Sunday).
.PP
Uses 'Day_of_Week' function from Date::Calc module.
.PP
Because this method uses the 'datum*' data members, you can obtain a result with:
.PP
.Vb 2
\&        my $dow = DnLib\->new( $y , $m , $d )\->day_of_week_index() ) {
\&                ...
.Ve
.PP
Parameters: [ 0 = class ].
.PP
Uses data mambers: datum = year (yyyy) , datum_1 = month (mm) , datum_2 = day (dd).
.PP
Return type: Scalar (integer).
.PP
\fIdecode_day_of_week()\fR
.IX Subsection "decode_day_of_week()"
.PP
Takes a day name and converts it to an integer ranging from 1 (Monday) to 7 (Sunday).  Returns zero if unable to convert the input.
.PP
Uses 'Decode_Day_of_Week' function from Date::Calc module.
.PP
Because this method uses the 'datum' data member, you can obtain a result with:
.PP
.Vb 2
\&        my $dow = DnLib\->new( $day_string )\->decode_day_of_week() ) {
\&                ...
.Ve
.PP
Parameters: [ 0 = class ].
.PP
Uses data mambers: datum = day name.
.PP
Return type: Scalar (integer).
.PP
\fIdecode_month()\fR
.IX Subsection "decode_month()"
.PP
Takes a month name and converts it to an integer ranging from 1 (January) to 12 (December).  Returns zero if unable to convert the input.
.PP
Uses 'Decode_Month' function from Date::Calc module.
.PP
Because this method uses the 'datum' data member, you can obtain a result with:
.PP
.Vb 2
\&        my $month = DnLib\->new( $month_string )\->decode_month() ) {
\&                ...
.Ve
.PP
Parameters: [ 0 = class ].
.PP
Uses data mambers: datum = month name.
.PP
Return type: Scalar (integer).
.PP
\fInext_day()\fR
.IX Subsection "next_day()"
.PP
Takes a date and returns the date of the following day.
.PP
Note that the supplied date is \s-1NOT\s0 checked for validity.
.PP
Uses 'Add_Delta_Days' function from Date::Calc module.
.PP
Because this method uses the 'datum' data members, you can obtain a result with:
.PP
.Vb 2
\&        my ( $next_y , $next_m , $next_ d )
\&                = DnLib\->new( $y , $m , $d )\->next_day()
.Ve
.PP
Parameters: [ 0 = class ].
.PP
Uses data mambers: datum = year , datum_1 = month , datum_2 = day.
.PP
Return type: List ( yyyy , mm , dd ).
.PP
\fIprevious_day()\fR
.IX Subsection "previous_day()"
.PP
Takes a date and returns the date of the previous day.
.PP
Note that the supplied date is \s-1NOT\s0 checked for validity.
.PP
Uses 'Add_Delta_Days' function from Date::Calc module.
.PP
Because this method uses the 'datum' data members, you can obtain a result with:
.PP
.Vb 2
\&        my ( $prev_y , $prev_m , $prev_ d )
\&                = DnLib\->new( $y , $m , $d )\->previous_day()
.Ve
.PP
Parameters: [ 0 = class ].
.PP
Uses data mambers: datum = year , datum_1 = month , datum_2 = day.
.PP
Return type: List ( yyyy , mm , dd ).
.PP
\fIassemble_iso_date()\fR
.IX Subsection "assemble_iso_date()"
.PP
Takes date elements and returns an iso-format date.
.PP
Because this method uses the 'datum' data members, you can obtain a result with:
.PP
.Vb 1
\&        my $date = DnLib\->new( $y , $m , $d )\->assemble_iso_date()
.Ve
.PP
Parameters: [ 0 = class ].
.PP
Uses data mambers: datum = year , datum_1 = month , datum_2 = day.
.PP
Return type: Scalar (string).
.PP
\fIall_iso639_langs()\fR
.IX Subsection "all_iso639_langs()"
.PP
Lists all \s-1ISO\s0 639 language names in alphabetical order.
.PP
Parameters: [ 0 = class ].
.PP
Return type: List.
.PP
\fIall_iso639_codes()\fR
.IX Subsection "all_iso639_codes()"
.PP
Lists all \s-1ISO\s0 639 two-letter language codes in alphabetical order.
.PP
Parameters: [ 0 = class ].
.PP
Return type: List.
.PP
\fIvalid_iso639_code()\fR
.IX Subsection "valid_iso639_code()"
.PP
Determines whether a given code is a valid \s-1ISO\s0 639 two-letter language code.
.PP
Uses 'code2language' function from Locale::Language module.  This function takes a two letter language code and returns the name of the language it represents.  If the two letter code is not a valid \s-1ISO\s0 639 code it returns 'undef'.  In this way, the function acts as a boolean.
.PP
Because this method uses the 'datum' data member, you can obtain a result with:
.PP
.Vb 2
\&        if ( DnLib\->new( $lang_code )\->valid_iso639_code() ) {
\&                ...
.Ve
.PP
Parameters: [ 0 = class ].
.PP
Uses data mambers: datum = language code.
.PP
Return type: Boolean.
.PP
\fIcodify_iso639_lang()\fR
.IX Subsection "codify_iso639_lang()"
.PP
Converts an \s-1ISO\s0 639 language name to its corresponding two-letter language code.
.PP
Returns empty result (Boolean false) if the language is invalid or an empty string.
.PP
Because this method uses the 'datum' data member, you can obtain a result with:
.PP
.Vb 2
\&        if ( DnLib\->new( $lang_code )\->codify_iso639_lang() ) {
\&                ...
.Ve
.PP
Parameters: [ 0 = class ].
.PP
Uses data mambers: datum = language code.
.PP
Return type: Boolean.
.PP
\fInow_rfc2822()\fR
.IX Subsection "now_rfc2822()"
.PP
Gets the current datetime in \s-1RFC\s0 2822 format.
.PP
Uses 'email_date' function from Email::Date::Format module.
.PP
You can obtain a result with:
.PP
.Vb 1
\&        my $date = DnLib\->new()\->now_rfc2822();
.Ve
.PP
Parameters: [ 0 = class ].
.PP
Uses data mambers: N/A.
.PP
Return type: Boolean.
.PP
\fIdate_rfc2822()\fR
.IX Subsection "date_rfc2822()"
.PP
Converts date to \s-1RFC\s0 2822 format.
.PP
Uses 'email_date' function from Email::Date::Format module and 'parsedate' format from Time::ParseDate.
.PP
Uses data mamber: datum = yyyy-mm-dd.
.PP
You can obtain a result with:
.PP
.Vb 1
\&        my $rfc_date = DnLib\->new( $date )\->date_rfc2822();
.Ve
.PP
Parameters: [ 0 = class ].
.PP
Uses data mambers: N/A.
.PP
Return type: Scalar (string).
.PP
\fIentitise()\fR
.IX Subsection "entitise()"
.PP
Perform standard conversions of reserved characters to \s-1HTML\s0 entities:
.PP
.Vb 7
\&        Name             ASCII     Entity
\&        \-\-\-\-             \-\-\-\-\-     \-\-\-\-\-\-
\&        ampersand          &       &amp;
\&        less than          <       &lt;
\&        greater than       >       &gt;
\&        quotation mark     "       &quot;
\&        apostrophe         \*(Aq       &apos;
.Ve
.PP
Because this method uses the 'datum' data member, you can obtain a result with:
.PP
.Vb 1
\&        my $date = DnLib\->new( $html )\->entitise();
.Ve
.PP
Parameters: [ 0 = class ].
.PP
Uses data mambers: datum = html string.
.PP
Return type: Scalar (string).
.PP
\fIdeentitise()\fR
.IX Subsection "deentitise()"
.PP
Perform standard conversions of \s-1HTML\s0 entities to reserved characters:
.PP
.Vb 7
\&        Name             ASCII     Entity
\&        \-\-\-\-             \-\-\-\-\-     \-\-\-\-\-\-
\&        ampersand          &       &amp;
\&        less than          <       &lt;
\&        greater than       >       &gt;
\&        quotation mark     "       &quot;
\&        apostrophe         \*(Aq       &apos;
.Ve
.PP
Because this method uses the 'datum' data member, you can obtain a result with:
.PP
.Vb 1
\&        my $date = DnLib\->new( $html )\->deentitise();
.Ve
.PP
Parameters: [ 0 = class ].
.PP
Uses data mambers: datum = html string.
.PP
Return type: Scalar (string).
.PP
\fIcopy_ref()\fR
.IX Subsection "copy_ref()"
.PP
Perform deep copy on structure.  Works on a reference or blessed object and returns a reference or blessed object.
.PP
Uses 'dclone' function from the Storable module.  This function requires references or blessed objects of type scalar, array or hash.
.PP
Because this method uses the 'datum' data member, you can obtain a result with:
.PP
.Vb 1
\&        my $copy = DnLib\->new( $object )\->copy_ref();
.Ve
.PP
Parameters: [ 0 = class ].
.PP
Uses data mambers: datum = reference.
.PP
Return type: Reference or blessed object.
.PP
\fIvar_contents()\fR
.IX Subsection "var_contents()"
.PP
Display contents of scalars or reference variables (including objects).
.PP
Warning: The argument to this method \fBmust\fR be a scalar.  If passing lists, hashes or objects, do so by reference.  For example:
.PP
.Vb 2
\&        my $copy_list = $base\->var_contents( \e@list );
\&        my $copy_hash = $base\->var_contents( \e%hash );
.Ve
.PP
Uses 'Dumper' method from the Data::Dumper module.
.PP
Because this method uses the 'datum' data member, you can obtain a result with:
.PP
.Vb 1
\&        my $date = DnLib\->new( $var )\->var_contents();
.Ve
.PP
Parameters: [ 0 = class ].
.PP
Uses data mambers: datum = scalar variable (reference).
.PP
Return type: Object.
.PP
\fIbackup_file()\fR
.IX Subsection "backup_file()"
.PP
Backs up file by renaming it to a unique file name.  Will simply add integer to file basename.
.PP
Uses 'move' function from File::Copy.
.PP
Because this method uses the 'datum' data members, you can obtain a result with:
.PP
.Vb 1
\&        DnLib\->new( $file )\->backup_file();
.Ve
.PP
Parameters: [ 0 = class ].
.PP
Uses data mambers: datum = file name.
.PP
Return type: N/A.
.PP
\fIwrite_file()\fR
.IX Subsection "write_file()"
.PP
Write file.  File name and list of file contents is provided.  Note that the list is passed as a reference.
.PP
Will backup any existing file of the same name.
.PP
Because this method uses the 'datum' data members, you can obtain a result with:
.PP
.Vb 1
\&        DnLib\->new( $file , \e@content )\->write_file();
.Ve
.PP
Parameters: [ 0 = class ].
.PP
Uses data mambers: datum = file name , datum_1 = list reference.
.PP
Return type: N/A.
.PP
\fIimport_feed()\fR
.IX Subsection "import_feed()"
.PP
Reads \s-1RSS\s0 feed data from import file into List.  Only imports data lines, i.e., ignores blank and comments lines.  A second List of matching input file line numbers for each imported line is also built during import.
.PP
Gets import file name from 'import_filename' data member.
.PP
Adds terminal 'item_start' key to ensure last item is added to channel at end of import.
.PP
Assigns imported List of data lines to 'imported_lines' data member.  Assigns imported List of line lumbers to 'line_numbers' data member.
.PP
Parameters: [ 0 = class ].
.PP
Return type: Boolean (= success of import).
.PP
\fIextract_file_data()\fR
.IX Subsection "extract_file_data()"
.PP
Reads input file and extracts key-value pairs.  It imports only data lines, i.e., ignores blank and comments lines.  Comment lines begin with a hash ('#').  Note that comments at the end of a line are not stripped.
.PP
The first whitespace separated value in a data line is treated as a key.  Everything else on the line is the associated value.  An array of hashes is built sequentially as data lines are imported:
.PP
.Vb 1
\&        [
\&
\&                (
\&                
\&                        \*(Aqkey\*(Aq => $key_1 ,
\&                        
\&                        \*(Aqvalue\*(Aq => $value_1 ,
\&
\&                        \*(Aqline\*(Aq  => $line_1 ,
\&                        
\&                ) ,
\&                
\&                (
\&                
\&                        \*(Aqkey\*(Aq => $key_2 ,
\&                        
\&                        \*(Aqvalue\*(Aq => $value_2 ,
\&
\&                        \*(Aqline\*(Aq  => $line_2 ,
\&                        
\&                ) ,
\&                
\&        ]
.Ve
.PP
Each hash contains the extracted key-value pair and the input file line number from which they were read.
.PP
Because this method uses the 'datum' data members, you can obtain a result with:
.PP
.Vb 1
\&        DnLib\->new( $file )\->extract_file_data();
.Ve
.PP
Parameters: [ 0 = class ].
.PP
Uses data mambers: datum = file name.
.PP
A reference to the array is returned at the end of processing.
.PP
Return type: Array reference.
.PP
\fIinsert_values()\fR
.IX Subsection "insert_values()"
.PP
Takes a list of data lines which are either comments or key-value pairs (space-delimited).  Some keys may be missing their corresponding value.
.PP
Also takes a hash of key-value data used to insert missing key values in the data list.  This hash is of the following structure:
.PP
.Vb 7
\&        (
\&                $key_1 => (
\&                        \*(Aqkey\*(Aq   => $new_key_1 ,
\&                        \*(Aqvalue\*(Aq => $value_1 ,
\&                ) ,
\&                ...
\&        )
.Ve
.PP
The 'value' key can be omitted when there is no value.
.PP
This structure allows for the key itself to be replaced with a new key.  The only time this is envisaged to be useful is when a key is to be commented out because there is no matching value for it.  For example:
.PP
.Vb 5
\&        (
\&                \*(Aqsubcategory\*(Aq => (
\&                        \*(Aqkey\*(Aq   => \*(Aq#subcategory\*(Aq ,
\&                )
\&        )
.Ve
.PP
The key value can be omitted when the key is not changing.  For example:
.PP
.Vb 5
\&        (
\&                \*(Aqsubcategory\*(Aq => (
\&                        \*(Aqvalue\*(Aq => \*(AqLiterature\*(Aq ,
\&                )
\&        )
.Ve
.PP
The data list is examined item by item.  If the item is a key without value then the key-value hash is checked.  If there is a matching key the value, and possibly a changed key, are inserted into the data item.  This occurs only for the first match of each key.
.PP
Note that each data line is assumed to end with a newline.
.PP
Because this method uses the 'datum' data members, you can obtain a result with:
.PP
.Vb 1
\&        DnLib\->new( \e@data , \e%key_values )\->insert_values();
.Ve
.PP
Parameters: [ 0 = class ].
.PP
Uses data mambers: datum = data list reference, datum_1 = key-value hash reference.
.PP
Return type: List.
.SH "PACKAGE: DnItem"
.IX Header "PACKAGE: DnItem"
An internal package encapsulating methods and data for getting information about an mp3 file.
.SS "Methods"
.IX Subsection "Methods"
\fIData Members\fR
.IX Subsection "Data Members"
.PP
\&\f(CW%self\fR = (
.PP
.Vb 1
\&        $filepath  =>  "<filepath>" ,
\&
\&        $guid      =>  "<guid>" ,
\&
\&        $duration  =>  "HH:MM:SS" ,
\&
\&        $size      =>  <bytes> ,
\&
\&        $type      =>  "<type>" ,
\&
\&        $title     =>  "<title>" ,
\&
\&        $author    =>  "<author>" ,
\&
\&        $summary   =>  "<summary>" ,
\&
\&        $explicit  =>  "\*(Aqyes\*(Aq|\*(Aqclean\*(Aq|\*(Aqno\*(Aq" ,
\&
\&        $pubdate   =>  "<pubdate>" ,
.Ve
.PP
)
.IP "\(bu" 4
\&\fBfilepath\fR
.Sp
Filepath of mp3 pod.  If invocation argument is present, use it as filepath.  Base url will be prepended to this filepath when outputting.
.IP "\(bu" 4
\&\fBguid\fR
.Sp
Globally unique identifier used for pod mp3.  According to the Apple specification it should consist of 32 characters.  Set now if filepath known.
.IP "\(bu" 4
\&\fBduration\fR
.Sp
Duration of pod mp3.  Format = \*(L"[\s-1HH:\s0]MM:SS\*(R"/\*(L"[H:]M:S\*(R".  Set now if filepath known.
.IP "\(bu" 4
\&\fBsize\fR
.Sp
Size of pod mp3 file in bytes.  Set now if filepath known.
.IP "\(bu" 4
\&\fBtype\fR
.Sp
Mime type pod file in bytes.  Should be 'audio/mp3' or 'audio/mpeg'.  Set now if filepath known.
.IP "\(bu" 4
\&\fBtitle\fR
.Sp
Track title.
.IP "\(bu" 4
\&\fBauthor\fR
.Sp
Track author.
.IP "\(bu" 4
\&\fBsummary\fR
.Sp
Track summary.
.IP "\(bu" 4
\&\fBexplicit\fR
.Sp
Whether track contains explicit content.  Values: 'yes'|'clean'|'no'.  Default = 'no'.
.IP "\(bu" 4
\&\fBpubdate\fR
.Sp
Track publication date.  The Apple specification for rss feeds states:
.Sp
.Vb 1
\&        The date and time format in <pubDate> must conform to RFC 2822.
\&        
\&        The date must be "day\-of\-week, day month year". The time must be
\&        in 24 hour format (no AM or PM) and must include the time zone offset.
\&        
\&        <! a\*^XX date and time not in RFC 2822 format a\*^XX >
\&        <pubDate>7/6/2005 1:00:00 PM</pubDate>
\&        
\&        <! a\*^XX valid date and time format a\*^XX >
\&        <pubDate>Wed, 6 Jul 2005 13:00:00 PDT</pubDate>
\&        <pubDate>Wed, 6 Jul 2005 13:00:00 \-0700</pubDate>
.Ve
.PP
\fIConstructors\fR
.IX Subsection "Constructors"
.PP
There are two method signatures: one with filepath and one without:
.PP
.Vb 2
\&        my $ojb = new DnItem;  OR  my $ojb = DnItem\->new();
\&        my $ojb = DnItem\->new( <filepath> );
.Ve
.PP
\fISetters\fR
.IX Subsection "Setters"
.PP
\&\s-1GUID\s0, mp3 duration, size and type are set automatically when filepath is set or, if filepath set at object contruction, when any of those attribute getters are called.
.PP
.Vb 10
\&        $i\->set_filepath( \*(Aq<filepath>\*(Aq );
\&        $i\->set_guid( \*(Aq<guid>\*(Aq );
\&        $i\->set_duration( \*(Aq<duration>\*(Aq );
\&        $i\->set_size( \*(Aq<size>\*(Aq );
\&        $i\->set_type( \*(Aq<type>\*(Aq );
\&        $i\->set_title( \*(Aq<title>\*(Aq );
\&        $i\->set_author( \*(Aq<author>\*(Aq );
\&        $i\->set_summary( \*(Aq<summary>\*(Aq );
\&        $i\->set_explicit( \*(Aqyes|clean|no\*(Aq );
\&        $i\->set_pubdate( \*(Aq<date>\*(Aq );
.Ve
.PP
\fIGetters\fR
.IX Subsection "Getters"
.PP
.Vb 10
\&        $i\->filepath();
\&        $i\->guid();
\&        $i\->duration();
\&        $i\->size();
\&        $i\->type();
\&        $i\->title();
\&        $i\->author();
\&        $i\->summary();
\&        $i\->explicit();
\&        $i\->pubdate();
.Ve
.PP
\fIOther\fR
.IX Subsection "Other"
.PP
\fIset_file_attr()\fR
.IX Subsection "set_file_attr()"
.PP
Sets file attributes: guid, duration, size and type.
.PP
Uses data member 'filepath' for the file to analyse when setting duration, size and type.  If no filepath is set, those attributes are set to 'undef'.
.PP
Parameters: [ 0 = class ].
.PP
Return type: N/A.
.PP
\fIxml()\fR
.IX Subsection "xml()"
.PP
Prints xml fragment for item.  It is intended to be included in the final rss feed file.  Here is example output:
.PP
.Vb 10
\&        <item>
\&                <title><![CDATA[01 Political Incorrections]]></title>
\&                <itunes:author>Bill Maher</itunes:author>
\&                <itunes:summary><![CDATA[Track 01 of a compilation of selected extracts from Bill Maher\*(Aqs "Politically Incorrect"]]></itunes:summary>
\&                <enclosure url="http://localhost/podcasts/pol\-inc/bill\-maher_track\-01.mp3" type="audio/mpeg" length="23576367"/>
\&                <pubDate>Sun, 29 Nov 2009 00:00:00 +1000</pubDate>
\&                <itunes:duration>08:00</itunes:duration>
\&                <itunes:explicit/>
\&                <itunes:keywords><![CDATA[politics, satire]]></itunes:keywords>
\&        </item>
.Ve
.PP
By default the 'item' element is flush left with all subsidiary elements indented normally.  You can increase the left indent of all output by supplying the number of additional tab indents in an argument.
.PP
Requires the base url to prepend to track names.
.PP
Parameters: [ 0 = class ] , 1 = base_url , 2 = tabs.
.PP
Return type: List (one line per element, newline ends each line).
.PP
\fIvalid_explicit()\fR
.IX Subsection "valid_explicit()"
.PP
Determines whether explicit setting is valid.  Valid settings are 'yes', 'clean' and 'no'.  This method accepts only these values although some systems will interpret any value other than 'yes' and 'clean' as 'no'.
.PP
Parameters: [ 0 = class ].
.PP
Return type: Boolean.
.PP
\fIvalid_mime_type()\fR
.IX Subsection "valid_mime_type()"
.PP
Determines whether mime type is valid.  Valid mime types are 'audio/mp3' and 'audio/mpeg'.
.PP
Parameters: [ 0 = class ].
.PP
Return type: Boolean.
.PP
\fIvalid_pubdate_format()\fR
.IX Subsection "valid_pubdate_format()"
.PP
Note: This method is not intended to be called directly.  The method 'valid_pubdate' calls it before checking the date value itself is valid.
.PP
Determines whether publication date is in valid \s-1RFC\s0 2822 format.  This format requires:
.PP
.Vb 1
\&        day, DD MMM YYYY HH:MM:SS +/\-OFFSET
.Ve
.PP
where 'day' is Mon, Tue, etc.; \s-1MMM\s0 is Apr, May, etc.; time is 24\-hour time; and \s-1OFFSET\s0 is time zone offset such as +0930.
.PP
This is an example date:
.PP
.Vb 1
\&        Wed, 6 Jul 2005 13:00:00 \-0700
.Ve
.PP
The *nix date command outputs in \s-1RFC\s0 2822 format when the '\-R' or '\-\-rfc\-2822' flags are used.
.PP
Parameters: [ 0 = class ].
.PP
Return type: Boolean.
.PP
\fIvalid_pubdate()\fR
.IX Subsection "valid_pubdate()"
.PP
Determines whether publication date is valid.  It first calls 'valid_date_format' to ensure date is in valid \s-1RFC\s0 2822 format.
.PP
It then confirms the date itself is valid.  In particular, it performs three checks:
.IP "that date exists and is valid" 4
.IX Item "that date exists and is valid"
.PD 0
.IP "that time is valid" 4
.IX Item "that time is valid"
.IP "that day of the week is correct for the date" 4
.IX Item "that day of the week is correct for the date"
.PD
.PP
Parameters: [ 0 = class ].
.PP
Return type: Boolean.
.PP
\fIempty()\fR
.IX Subsection "empty()"
.PP
Determines whether item is empty.  This requires the following items to be undefined: filepath, duration, size, mime type, title, author, summary, explicit and publication date.
.PP
Parameters: [ 0 = class ].
.PP
Return type: Boolean.
.PP
\fIcomplete()\fR
.IX Subsection "complete()"
.PP
Determines whether item is complete.  This requires:
.PP
.Vb 4
\&        \- all of the following items: filepath, guid, duration, size, mime type, title, author, summary, explicit and publication date,
\&        \- explicit is set to \*(Aqyes\*(Aq, \*(Aqclean\*(Aq or \*(Aqno\*(Aq,
\&        \- mime type is either \*(Aqaudio/mp3\*(Aq or \*(Aqaudio/mpeg\*(Aq, and
\&        \- publication date is in RFC 2822 format.
.Ve
.PP
Parameters: [ 0 = class ].
.PP
Return type: Boolean.
.PP
\fIwhy_incomplete()\fR
.IX Subsection "why_incomplete()"
.PP
Returns list of reasons why item is incomplete.
.PP
Does not check whether item is complete \*(-- it is presumed the 'complete' method has already determined this.  It is therefore possible for this function, if improperly called on a complete item, to return an empty list.
.PP
See 'complete' method for the requirements of a complete item.
.PP
Parameters: [ 0 = class ].
.PP
Return type: List (one line per element, newline end each line).
.PP
\fIclear()\fR
.IX Subsection "clear()"
.PP
Clear all values from item.
.PP
Parameters: [ 0 = class ].
.PP
Return type: N/A.
.SH "PACKAGE: DnChannel"
.IX Header "PACKAGE: DnChannel"
An internal package encapsulating methods and data for manipulating an rss channel.
.SS "Methods"
.IX Subsection "Methods"
\fIData Members\fR
.IX Subsection "Data Members"
.PP
\&\f(CW%self\fR = (
.PP
.Vb 1
\&        $title        =>  "<title>" ,
\&
\&        $base_url     =>  "<url>" ,
\&
\&        $language     =>  "<language>" ,
\&
\&        $author       =>  "<author>" ,
\&
\&        $summary      =>  "<summary>" ,
\&
\&        $image        =>  "<filepath>" ,
\&
\&        $category     =>  "<category>" ,
\&
\&        $subcategory  =>  "<subcategory>" ,
\&
\&        $explicit     =>  "\*(Aqyes\*(Aq|\*(Aqclean\*(Aq|\*(Aqno\*(Aq" ,
\&
\&        @items        =>  [ %item , %item , ... ] ,
\&
\&        %scheme       =>  (
\&
\&                %category1  =>  (
\&                
\&                        %subcategory1  =>  "" ,
\&
\&                        %subcategory2  =>  "" ,
\&
\&                        ... ,
\&                
\&                ) ,
\&
\&                %category2  =>  (
\&                
\&                        %subcategory3  =>  "" ,
\&
\&                        %subcategory4  =>  "" ,
\&
\&                        ... ,
\&                
\&                ) ,
\&
\&        ... ,
\&
\&        ) ,
\&
\&        %podcasts     =>  (
\&        
\&                $file_mask  =>  "<filename_mask>" ,
\&
\&                $title_mask =>  "<title_mask>" ,
\&
\&                $series     =>  <series_number> ,
\&
\&                $episode    =>  <episode_numbner> ,
\&
\&                $disc       =>  <disc_numbner> ,
\&
\&                $artist     =>  "<artist>" ,
\&
\&                $composer   =>  "<composer>" ,
\&
\&                $album      =>  "<album_title>" ,
\&
\&                $year       =>  <year> ,
\&
\&                $comment    =>  "<comment>" ,
\&
\&                $genres     =>  "<genre_list>" ,
\&        
\&                $genre      =>  "<genre>" ,
\&        
\&        ) ,
\&
\&        %input_files  =>  (
\&        
\&                $metadata   =>  "<filename>" ,
\&
\&                $podcasts   =>  "<filename>" ,
\&
\&                $pubdates   =>  "<filename>" ,
\&
\&        ) ,
.Ve
.PP
)
.PP
Note: The unusual data structure for '%scheme' is due to the hashes having only keys and no values.  Not all categories have subcategories.
.IP "\(bu" 4
\&\fBtitle\fR
.Sp
Channel title.
.IP "\(bu" 4
\&\fBbase_url\fR
.Sp
Base url to prepend to all file paths, including items and channel image.
.IP "\(bu" 4
\&\fBlanguage\fR
.Sp
Channel language.  The Apple \s-1RSS\s0 specification requires values from the \s-1ISO\s0 639\-1 Alpha\-2 list (two-letter language codes, some with possible modifiers, such as \*(L"en-us\*(R").  Default language = 'en'.
.IP "\(bu" 4
\&\fBauthor\fR
.Sp
Channel author.
.IP "\(bu" 4
\&\fBsummary\fR
.Sp
Channel summary.
.IP "\(bu" 4
\&\fBimage\fR
.Sp
Filepath of channel image.  The Apple specification requires the image to be of type jpg or png.  Base url will be prepended to this filepath when outputting.
.IP "\(bu" 4
\&\fBcategory\fR
.Sp
Category of channel content.  The Apple specification defines a two-level category scheme.  See '%scheme' data member and 'valid_categorisation' method for further details.
.IP "\(bu" 4
\&\fBsubcategory\fR
.Sp
Subcategory of channel content.  Optional.  The Apple specification defines a two-level category scheme.  See '%scheme' data member and 'valid_categorisation' method for further details.
.IP "\(bu" 4
\&\fBexplicit\fR
.Sp
Whether channel contains explicit content.  Values: 'yes'|'clean'|'no'.  Default = 'no'.
.IP "\(bu" 4
\&\fBitems\fR
.Sp
The items, i.e., audio tracks, contained in the channel.  Presumed to be mp3/mpeg.
.IP "\(bu" 4
\&\fBscheme\fR
.Sp
Two-level categorical classification scheme given in Apple specification.  Here are the allowed categories:
.RS 4
.IP "Arts" 4
.IX Item "Arts"
.RS 4
.PD 0
.IP "Design" 4
.IX Item "Design"
.IP "Fashion & Beauty" 4
.IX Item "Fashion & Beauty"
.IP "Food" 4
.IX Item "Food"
.IP "Literature" 4
.IX Item "Literature"
.IP "Performing Arts" 4
.IX Item "Performing Arts"
.IP "Visual Arts" 4
.IX Item "Visual Arts"
.RE
.RS 4
.RE
.IP "Business" 4
.IX Item "Business"
.RS 4
.IP "Business News" 4
.IX Item "Business News"
.IP "Careers" 4
.IX Item "Careers"
.IP "Investing" 4
.IX Item "Investing"
.IP "Management & Marketing" 4
.IX Item "Management & Marketing"
.IP "Shopping" 4
.IX Item "Shopping"
.RE
.RS 4
.RE
.IP "Comedy" 4
.IX Item "Comedy"
.IP "Education" 4
.IX Item "Education"
.RS 4
.IP "Education Technology" 4
.IX Item "Education Technology"
.IP "Higher Education" 4
.IX Item "Higher Education"
.IP "K\-12" 4
.IX Item "K-12"
.IP "Language Courses" 4
.IX Item "Language Courses"
.IP "Training" 4
.IX Item "Training"
.RE
.RS 4
.RE
.IP "Games & Hobbies" 4
.IX Item "Games & Hobbies"
.RS 4
.IP "Automotive" 4
.IX Item "Automotive"
.IP "Aviation" 4
.IX Item "Aviation"
.IP "Hobbies" 4
.IX Item "Hobbies"
.IP "Other Games" 4
.IX Item "Other Games"
.IP "Video Games" 4
.IX Item "Video Games"
.RE
.RS 4
.RE
.IP "Government & Organizations" 4
.IX Item "Government & Organizations"
.RS 4
.IP "Local" 4
.IX Item "Local"
.IP "National" 4
.IX Item "National"
.IP "Non-Profit" 4
.IX Item "Non-Profit"
.IP "Regional" 4
.IX Item "Regional"
.RE
.RS 4
.RE
.IP "Health" 4
.IX Item "Health"
.RS 4
.IP "Alternative Health" 4
.IX Item "Alternative Health"
.IP "Fitness & Nutrition" 4
.IX Item "Fitness & Nutrition"
.IP "Self-Help" 4
.IX Item "Self-Help"
.IP "Sexuality" 4
.IX Item "Sexuality"
.RE
.RS 4
.RE
.IP "Kids & Family" 4
.IX Item "Kids & Family"
.IP "Music" 4
.IX Item "Music"
.IP "News & Politics" 4
.IX Item "News & Politics"
.IP "Religion & Spirituality" 4
.IX Item "Religion & Spirituality"
.RS 4
.IP "Buddhism" 4
.IX Item "Buddhism"
.IP "Christianity" 4
.IX Item "Christianity"
.IP "Hinduism" 4
.IX Item "Hinduism"
.IP "Islam" 4
.IX Item "Islam"
.IP "Judaism" 4
.IX Item "Judaism"
.IP "Other" 4
.IX Item "Other"
.IP "Spirituality" 4
.IX Item "Spirituality"
.RE
.RS 4
.RE
.IP "Science & Medicine" 4
.IX Item "Science & Medicine"
.RS 4
.IP "Medicine" 4
.IX Item "Medicine"
.IP "Natural Sciences" 4
.IX Item "Natural Sciences"
.IP "Social Sciences" 4
.IX Item "Social Sciences"
.RE
.RS 4
.RE
.IP "Society & Culture" 4
.IX Item "Society & Culture"
.RS 4
.IP "History" 4
.IX Item "History"
.IP "Personal Journals" 4
.IX Item "Personal Journals"
.IP "Philosophy" 4
.IX Item "Philosophy"
.IP "Places & Travel" 4
.IX Item "Places & Travel"
.RE
.RS 4
.RE
.IP "Sports & Recreation" 4
.IX Item "Sports & Recreation"
.RS 4
.IP "Amateur" 4
.IX Item "Amateur"
.IP "College & High School" 4
.IX Item "College & High School"
.IP "Outdoor" 4
.IX Item "Outdoor"
.IP "Professional" 4
.IX Item "Professional"
.RE
.RS 4
.RE
.IP "Technology" 4
.IX Item "Technology"
.RS 4
.IP "Gadgets" 4
.IX Item "Gadgets"
.IP "Tech News" 4
.IX Item "Tech News"
.IP "Podcasting" 4
.IX Item "Podcasting"
.IP "Software How-To" 4
.IX Item "Software How-To"
.RE
.RS 4
.RE
.IP "\s-1TV\s0 & Film" 4
.IX Item "TV & Film"
.RE
.RS 4
.PD
.Sp

.RE
.IP "\(bu" 4
\&\fBpodcasts\fR
.Sp
Encpasulates information about podcasts in a directory and is intended to be used for standardising file names and mp3 tags.
.RS 4
.IP "\(bu" 4
\&\fBpodcasts\fR\->\fBfile_mask\fR
.Sp
Mask for file name.  Must be in lowercase.  Can use the following tokens:
.Sp
.Vb 1
\&        %S = series number,
\&        
\&        %E = episode number, and
\&        
\&        %D = disc number.
.Ve
.IP "\(bu" 4
\&\fBpodcasts\fR\->\fBtitle_mask\fR
.Sp
Mask for file name.  Can contain any characters.  Can use same tokens available to the file mask.  Corresponds to mp3 tag 'title'.
.IP "\(bu" 4
\&\fBpodcasts\fR\->\fBseries\fR
.Sp
Current series number of podcast.
.IP "\(bu" 4
\&\fBpodcasts\fR\->\fBepisode\fR
.Sp
Current episode number of podcast.
.IP "\(bu" 4
\&\fBpodcasts\fR\->\fBdisc\fR
.Sp
Current disc number of podcast.  Corresponds to \s-1ID3\s0 frame 'disk number'.
.IP "\(bu" 4
\&\fBpodcasts\fR\->\fBartist\fR
.Sp
Podcast artist.  Corresponds to \s-1ID3\s0 tag 'artist'.
.IP "\(bu" 4
\&\fBpodcasts\fR\->\fBcomposer\fR
.Sp
Current composer number of podcast.  Corresponds to \s-1ID3\s0 frame '\s-1TCOM\s0'.
.IP "\(bu" 4
\&\fBpodcasts\fR\->\fBalbum\fR
.Sp
Podcast album title.  Corresponds to \s-1ID3\s0 tag 'album'.
.IP "\(bu" 4
\&\fBpodcasts\fR\->\fByear\fR
.Sp
Podcast year of publication.  Corresponds to \s-1ID3\s0 tag 'year'.
.IP "\(bu" 4
\&\fBpodcasts\fR\->\fBcomment\fR
.Sp
Podcast comment.  Corresponds to \s-1ID3\s0 tag 'comment'.
.IP "\(bu" 4
\&\fBpodcasts\fR\->\fBgenres\fR
.Sp
List of \s-1ID3\s0 genres.  [Source: id3.org].
.IP "\(bu" 4
\&\fBpodcasts\fR\->\fBgenre\fR
.Sp
Podcast genre.  Corresponds to \s-1ID3\s0 tag 'genre'.
.RE
.RS 4
.RE
.IP "\(bu" 4
\&\fBinput_files\fR
.Sp
Names of input files used throughout package.
.RS 4
.IP "\(bu" 4
\&\fBinput_files\fR\->\fBmetadata\fR
.Sp
Name of file containing metadata.  Is set to 'input.metadata'.
.IP "\(bu" 4
\&\fBinput_files\fR\->\fBpodcasts\fR
.Sp
Name of file containing podcast information.  Is set to 'input.podcasts'.
.IP "\(bu" 4
\&\fBinput_files\fR\->\fBpubdates\fR
.Sp
Name of file containing pubdates.  Is set to 'input.pubdates'.
.RE
.RS 4
.RE
.PP
\fIConstructors\fR
.IX Subsection "Constructors"
.PP
There is a single method signature that does not accept any arguments:
.PP
.Vb 1
\&        my $ojb = new DnChannel;  OR  my $ojb = DnChannel\->new();
.Ve
.PP
\fISetters\fR
.IX Subsection "Setters"
.PP
.Vb 10
\&        $c\->set_title( \*(Aq<title>\*(Aq );
\&        $c\->set_base_url( \*(Aq<base_url>\*(Aq );
\&        $c\->set_language( \*(Aq<language>\*(Aq );
\&        $c\->set_author( \*(Aq<author>\*(Aq );
\&        $c\->set_summary( \*(Aq<summary>\*(Aq );
\&        $c\->set_image( \*(Aq<image>\*(Aq );
\&        $c\->set_category( \*(Aq<category>\*(Aq );
\&        $c\->set_subcategory( \*(Aq<subcategory>\*(Aq );
\&        $c\->set_explicit( \*(Aq<explicit>\*(Aq );
\&        $c\->set_items( @items );
\&        $c\->add_item( %items );
\&        $c\->set_file_mask( \*(Aq<file_mask>\*(Aq );
\&        $c\->set_title_mask( \*(Aq<title_mask>\*(Aq );
\&        $c\->set_series( \*(Aq<series_number>\*(Aq );
\&        $c\->set_episode( \*(Aq<episode_number>\*(Aq );
\&        $c\->set_disc( \*(Aq<disc_number>\*(Aq );
\&        $c\->set_artist( \*(Aq<artist>\*(Aq );
\&        $c\->set_composer( \*(Aq<composer>\*(Aq );
\&        $c\->set_album( \*(Aq<album_title>\*(Aq );
\&        $c\->set_year( \*(Aq<year>\*(Aq );
\&        $c\->set_comment( \*(Aq<comment>\*(Aq );
\&        $c\->set_genre( \*(Aq<genre>\*(Aq );
.Ve
.PP
There are no setters for scheme, genres or input filenames as they are set at object construction time.
.PP
\fIGetters\fR
.IX Subsection "Getters"
.PP
.Vb 10
\&        $c\->title();
\&        $c\->base_url();
\&        $c\->language();
\&        $c\->author();
\&        $c\->summary();
\&        $c\->image();
\&        $c\->category();
\&        $c\->subcategory();
\&        $c\->explicit();
\&        $c\->items();   # returns list
\&        $c\->scheme();  # returns hash reference
\&        $c\->file_mask();
\&        $c\->title_mask();
\&        $c\->series();
\&        $c\->episode();
\&        $c\->disc();
\&        $c\->artist();
\&        $c\->composer();
\&        $c\->album();
\&        $c\->year();
\&        $c\->comment();
\&        $c\->genres();  # returns list
\&        $c\->genre();
\&        $c\->metadata_file();
\&        $c\->podcasts_file();
\&        $c\->pubdates_file();
.Ve
.PP
\fIOther\fR
.IX Subsection "Other"
.PP
\fIxml()\fR
.IX Subsection "xml()"
.PP
Prints xml tree for channel.  It is intended to be included in the final rss feed file.  Here is example output:
.PP
.Vb 10
\&        <channel>
\&                <title><![CDATA[Political Incorrections]]></title>
\&                <language>en</language>
\&                <itunes:author>Bill Maher</itunes:author>
\&                <itunes:summary><![CDATA[Compilation of highlights from "Politically Incorrect", a late\-night, half\-hour political talk show hosted by Bill Maher that ran from 1993 to 2002. The show aired on Comedy Central from 1993 to 1996 and on ABC from 1997 to 2002.]]></itunes:summary>
\&                <description><![CDATA[Compilation of highlights from "Politically Incorrect", a late\-night, half\-hour political talk show hosted by Bill Maher that ran from 1993 to 2002. The show aired on Comedy Central from 1993 to 1996 and on ABC from 1997 to 2002.]]></description>
\&                <itunes:image href="http://localhost/podcasts/pol\-inc/bill\-maher.jpg"/>
\&                <itunes:category text="Comedy"/>
\&                <item>
\&                        <title><![CDATA[01 Political Incorrections]]></title>
\&                        <SNIP/>
\&                        <itunes:keywords><![CDATA[politics satire]]></itunes:keywords>
\&                </item>
\&        </channel>
.Ve
.PP
The base url is prepended to all urls in channel and subsidiary items.
.PP
By default the 'channel' element is flush left with all subsidiary elements indented normally.  You can increase the left indent of all output by supplying the number of additional tab indents in an argument.
.PP
Parameters: [ 0 = class ] , 1 = tabs.
.PP
Return type: List (one line per element, newline ends each line).
.PP
\fIvalid_categorisation()\fR
.IX Subsection "valid_categorisation()"
.PP
Checks whether categorisation is valid.  The method will work with category only set, or with both category and subcategory set.
.PP
Any non-entitised ampersands are entitised before checking, i.e., '&' converted to '&amp;'.
.PP
Parameters: [ 0 = class ].
.PP
Return type: Boolean.
.PP
\fIvalid_image_type()\fR
.IX Subsection "valid_image_type()"
.PP
Determines whether image mime type is valid.  Valid mime types are 'image/jpeg' and 'image/png'.
.PP
Parameters: [ 0 = class ].
.PP
Return type: Boolean.
.PP
\fIvalid_language()\fR
.IX Subsection "valid_language()"
.PP
Determines whether language code is a valid \s-1ISO639\s0 language identification code.
.PP
Parameters: [ 0 = class ].
.PP
Return type: Boolean.
.PP
\fIvalid_explicit()\fR
.IX Subsection "valid_explicit()"
.PP
Determines whether explicit setting is valid.  Valid settings are 'yes', 'clean' and 'no'.  This method accepts only these values although some systems will interpret any value other than 'yes' and 'clean' as 'no'.
.PP
Parameters: [ 0 = class ].
.PP
Return type: Boolean.
.PP
\fIempty()\fR
.IX Subsection "empty()"
.PP
Determines whether channel is empty.  This requires the following items to be undefined/empty: title, base url, author, summary, image, category, and no items.
.PP
Parameters: [ 0 = class ].
.PP
Return type: Boolean.
.PP
\fIcomplete()\fR
.IX Subsection "complete()"
.PP
Determines whether channel is complete.  This requires:
.PP
.Vb 5
\&        \- all of the following items: title, base url, language, author, summary, image, category, optional subcategory, explicit setting and at least one item,
\&        \- language is a complete ISO639 code,
\&        \- complete explicit setting, 
\&        \- image mime type is either \*(Aqimage/jpeg\*(Aq or \*(Aqimage/png\*(Aq, and
\&        \- complete categorisation.
.Ve
.PP
Parameters: [ 0 = class ].
.PP
Return type: Boolean.
.PP
\fIwhy_incomplete()\fR
.IX Subsection "why_incomplete()"
.PP
Returns list of why_incomplete, i.e., reasons why channel is not complete.
.PP
Does not check whether channel is complete \*(-- it is presumed 'complete' method has already determined this.  It is therefore possible for this function, if improperly called on a complete channel, to return an empty list.
.PP
See 'complete' method for the requirements of a complete channel.
.PP
Parameters: [ 0 = class ].
.PP
Return type: List (one line per element, newline end each line).
.PP
\fIclear()\fR
.IX Subsection "clear()"
.PP
Clear all values from item.
.PP
Parameters: [ 0 = class ].
.PP
Return type: N/A.
.PP
\fIoutput_scheme()\fR
.IX Subsection "output_scheme()"
.PP
Outputs the scheme in format suitable for printing.  Output is sorted (case-insensitive).  Ampersand entities are de-entitised, i.e., '&amp;' to '&'.
.PP
Output is in the form of a List.  There is one (sub)category per line with subcategories indented one tab.  All lines end with newlines.  The easiest way to use the output is something like:
.PP
.Vb 1
\&        print $_ foreach $cat\->output_scheme();
.Ve
.PP
Parameters: [ 0 = class ].
.PP
Return type: List (one line per element, newlines end each line, categories are flush left and subcategories are indented one tab space).
.PP
\fIenter_metadata()\fR
.IX Subsection "enter_metadata()"
.PP
Prompts user to enter metadata values.  Accepts a simple key-value hash with existing or default values which the user has the option of changing or adding to.
.PP
Returns results in a hash compatible with method 'insert_values' (see that method for more information).
.PP
Because this method uses the 'datum' data members, you can obtain a result with:
.PP
.Vb 1
\&        DnChannel\->new( \e%key_values )\->enter_metadata();
.Ve
.PP
Parameters: [ 0 = class ].
.PP
Uses data mambers: datum = key-value hash reference.
.PP
Return type: Hash reference.
.PP
\fIvalidate_metadata()\fR
.IX Subsection "validate_metadata()"
.PP
Takes (reference to) data extracted by method 'extract_file_data' and checks whether it is a valid set of metadata, as supplied by an 'input.metadata' file (whose template is generated by this utility when invoked with the '\-m' option).  See method 'extract_file_data' for the data structure it supplies.
.PP
The metadata set must be complete \*(-- all required keys must be provided and no provided key can have an empty value.
.PP
The following checks are performed:
.PP
.Vb 11
\&        sanity checks on constrained keys
\&                that all constrained key names are valid
\&                that all constrained keys have associated allowed values
\&        no invalid keys
\&        all required keys are present
\&        all provided keys have a non\-empty value
\&        no singular keys are duplicated
\&        all constrained keys have a valid value
\&        no pubdates provided unless \*(Aqpubdate\-method\*(Aq is \*(Aqprovide\*(Aq
\&        language, image and category/subcategory are valid
\&        dates are valid
.Ve
.PP
The script dies if a check fails.
.PP
Because this method uses the 'datum' data members, you can obtain a result with:
.PP
.Vb 1
\&        DnChannel\->new( \e@metadata )\->validate_metadata();
.Ve
.PP
Parameters: [ 0 = class ].
.PP
Uses data mambers: datum = metadata array reference.
.PP
Return type: N/A.
.PP
\fIpubdates()\fR
.IX Subsection "pubdates()"
.PP
Derives list of publication dates from metadata.
.PP
Assumes metadata has been validated, i.e., 'pubdate\-method' key is present with a valid value, and any pubdates are in valid format.
.PP
Takes an array of mp3 files to be added to skeleton input file in order to know how many pubdates to return.  If 'pubdate\-method' is 'descend or 'ascend' the pubdates are generated using the arbitrary start date of 2008\-07\-01.
.PP
If 'pubdate\-method' is 'provide' then pubdates are harvested from 'pubdate' key-value pairs.  Excess pubdates are ignored.  Processing will halt with an error if there are fewer provided pubdates than mp3 files.
.PP
Note that metadata array contains anonymous hashes in a format specified in method 'extract_file_data'.
.PP
Because this method uses the 'datum' data members, you can obtain a result with:
.PP
.Vb 1
\&        DnChannel\->new( \e@mp3_files , \e@metadata )\->pubdates();
.Ve
.PP
Parameters: [ 0 = class ].
.PP
Uses data mambers: datum   = mp3 files array reference,
                   datum_1 = metadata array reference.
.PP
Return type: List.
.SH "PACKAGE: DnFeed"
.IX Header "PACKAGE: DnFeed"
An internal package encapsulating methods and data for manipulating an rss feed.
.SS "Methods"
.IX Subsection "Methods"
\fIData Members\fR
.IX Subsection "Data Members"
.PP
\&\f(CW%self\fR = (
.PP
.Vb 1
\&        $import_filename  =>  "<filepath>" ,
\&
\&        @imported_lines   =>  [ $line , ... ] ,
\&
\&        @line_numbers     =>  [ $number , ... ] ,
\&
\&        $output_base      =>  "<basename>" ,
\&
\&        $channel          =>  %channel ,
.Ve
.PP
)
.IP "\(bu" 4
\&\fBimport_filename\fR
.Sp
File path of import file.  May be set at object construction from passed parameter.
.IP "\(bu" 4
\&\fBimported_lines\fR
.Sp
Lines imported from import file.  Only imports data lines.
.IP "\(bu" 4
\&\fBline_numbers\fR
.Sp
This List is built along with 'imported_lines'.  For each imported data line this List holds that line's line number in the import file.
.IP "\(bu" 4
\&\fBoutput_base\fR
.Sp
Basename of rss xml feed and subscription opml filenames.  Default: 'rss\-feed'.
.IP "\(bu" 4
\&\fBchannel\fR
.Sp
\&\s-1RSS\s0 channel comprising the feed.
.PP
\fIConstructors\fR
.IX Subsection "Constructors"
.PP
There are two method signatures.  One accepts the import file as a parameter and the other accepts no arguments:
.PP
.Vb 2
\&        my $ojb = new DnFeed;  OR  my $ojb = DnFeed\->new();
\&        my $ojb = DnFeed\->new( "<import_filename>" );
.Ve
.PP
\fISetters\fR
.IX Subsection "Setters"
.PP
.Vb 5
\&        $r\->set_import_filename( "<import_filename>" );
\&        $r\->add_imported_lines( @lines );
\&        $r\->add_line_numbers( @numbers );
\&        $r\->set_output_base( "<basename>" );
\&        $r\->set_channel( %channel );
.Ve
.PP
\fIGetters\fR
.IX Subsection "Getters"
.PP
.Vb 5
\&        $r\->import_filename();
\&        $r\->imported_lines();
\&        $r\->line_numbers();
\&        $r\->output_base();
\&        $r\->channel();
.Ve
.PP
\fIOther\fR
.IX Subsection "Other"
.PP
\fIfeed_input_template()\fR
.IX Subsection "feed_input_template()"
.PP
Provides feed-related portion of input template as a List.
.PP
Parameters: [ 0 = class ].
.PP
Return type: List (each element is a line, each line terminated by newline).
.PP
\fIchannel_input_template()\fR
.IX Subsection "channel_input_template()"
.PP
Provides channel-related portion of input template as a List.
.PP
Parameters: [ 0 = class ].
.PP
Return type: List (each element is a line, each line terminated by newline).
.PP
\fIitem_input_template()\fR
.IX Subsection "item_input_template()"
.PP
Provides item-related portion of input template as a List.
.PP
Parameters: [ 0 = class ].
.PP
Return type: List (each element is a line, each line terminated by newline).
.PP
\fImetadata_input_template()\fR
.IX Subsection "metadata_input_template()"
.PP
Provides template for metadata input file as a List.
.PP
Parameters: [ 0 = class ].
.PP
Return type: List (each element is a line, each line terminated by newline).
.PP
\fIwrite_input_template()\fR
.IX Subsection "write_input_template()"
.PP
Write input file template ('input.template') to current directory.  If a file of that name already exists it will be renamed before writing the new file.
.PP
An input file template lists all input keys and is self-documented.
.PP
Parameters: [ 0 = class ].
.PP
Return type: N/A.
.PP
\fIwrite_input_metadata()\fR
.IX Subsection "write_input_metadata()"
.PP
Creates metadata input file template ('input.metadata') in current directory.  If a file of that name already exists the user can edit and add to file data.  If it does not exists one will be written and the user will have a chance to add data to it.
.PP
A metadata input file provides all values needed in an input skeleton file not extracted from audio mp3 files.
.PP
Parameters: [ 0 = class ].
.PP
Return type: N/A.
.PP
\fIwrite_input_skeleton()\fR
.IX Subsection "write_input_skeleton()"
.PP
Write input file skeleton ('input.skeleton') to current directory.  If a file of that name already exists it will be renamed before writing the new file.
.PP
An input file skeleton is like an input file template except that it includes a set of item keys for each mp3 file in the current directory.  The 'item\-file' key for each item has the file name already set.
.PP
Attempts to intelligently set author, title and summary keys for each item from mp3 tags.
.PP
Uses metadata input file 'input.metadata' if present in the working directory.  This file can provide feed and channel values.  Can also use publication date input file 'input.pubdates' if present.  This file supplies mp3/podcast publication dates.
.PP
Parameters: [ 0 = class ].
.PP
Return type: N/A.
.PP
\fIimport_feed()\fR
.IX Subsection "import_feed()"
.PP
Reads \s-1RSS\s0 feed data from import file into List.  Only imports data lines, i.e., ignores blank and comments lines.  A second List of matching input file line numbers for each imported line is also built during import.
.PP
Gets import file name from 'import_filename' data member.
.PP
Adds terminal 'item_start' key to ensure last item is added to channel at end of import.
.PP
Assigns imported List of data lines to 'imported_lines' data member.  Assigns imported List of line lumbers to 'line_numbers' data member.
.PP
Parameters: [ 0 = class ].
.PP
Return type: Boolean (= success of import).
.PP
\fIprocess_feed()\fR
.IX Subsection "process_feed()"
.PP
Reads \s-1RSS\s0 feed data from import file.
.PP
Parameters: [ 0 = class ].
.PP
Return type: Boolean (= success of import).
.PP
\fIxml()\fR
.IX Subsection "xml()"
.PP
Generates \s-1RSS\s0 feed xml as a List.  The easiest way to display the content is with:
.PP
.Vb 1
\&        print $_ foreach $rss\->xml();
.Ve
.PP
Parameters: [ 0 = class ].
.PP
Return type: List (one line per element, newline ends each line).
.PP
\fIopml()\fR
.IX Subsection "opml()"
.PP
Generates content of an \s-1OPML\s0 file that can be used to add the \s-1RSS\s0 feed to an aggregator's subscription list.  The easiest way to display it is with:
.PP
.Vb 1
\&        print $_ foreach $rss\->opml();
.Ve
.PP
Because the feed xml contains only one channel, the \s-1OPML\s0 file can use the channel title and summary for the feed title and outline, respectively.
.PP
Parameters: [ 0 = class ].
.PP
Return type: List (one line per element, newline ends each line).
.SH "PACKAGE: main"
.IX Header "PACKAGE: main"
The main program.
.SS "Dependencies"
.IX Subsection "Dependencies"
The following perl modules are required:
.PP
\fIGetopt::Declare\fR
.IX Subsection "Getopt::Declare"
.PP
Used for parameter processing.
.PP
Debian: provided by package 'libgetopt\-declare\-perl'.
.SS "Description"
.IX Subsection "Description"
First handles parameters.  If '\-c' is passed then print category scheme and exit.  If '\-t' is passed, write template input file 'input.template' file to current directory.  If '\-s' is passed, write skeleton input file 'input.skeleton' file to current directory.
.PP
Then import and process input file.
.PP
Finally, output feed xml and subscription opml files.  Note that rather than overwrite an existing output file, the existing file is renamed.
.SH "AUTHOR"
.IX Header "AUTHOR"
David Nebauer, david <at> nebauer <dot> org
