#!/usr/bin/perl

###############################################################################
# The perlpod documentation in this script is designed to produce a man page. #
# To perform the conversion, execute this command:                            #
#                                                                             #
# 		pod2man dn-podcasts-rss dn-podcasts-rss.1                             #
#                                                                             #
# in the dn-qk-deb build directory.                                           #
###############################################################################

=head1 NAME

dn-podcasts-rss - maintains podcast files and generates rss feed files

=head1 SUMMARY

Generates an rss feed file and corresponding opml file for podcasts.  All audio files for the podcast must be in the current directory.

Running this script enables the user to specify channel attributes: base url, title, author, summary and image.  The following attributes are stored for each channel item, i.e., podcast audio file: file name, title, description, genre and publication date.  The file name and publication date item attributes are stored, along with channel attributes, in memory and then in an xml storage file.  Item attributes title, description and genre are stored in audio file tags and frames.  As a convenience feature users are able to change audio file album, performer, author, track and year tags during the process.

At this time only mp3 audio files and ID3 tags are supported.

This script supports only one channel per rss feed and requires all files for a given feed to be in the same directory.  This script must be run from inside that directory.

To use this script for the first time simply ensure the podcast feed audio files are in a single directory, along with an appropriate image file, and run this script in that directory.

=head1 USAGE

dn-podcasts-rss

=over

This is the standard usage.

The output files are called 'rss-feed.xml' and 'rss-feed.opml'.

=back

dn-podcasts-rss -a

=over

The default behaviour is to process only new audio files in the directory -- audio files that have been previously processed are skipped.  This option forces the script to process all audio files in the directory.

=back

dn-podcasts-rss -i

=over

The default behaviour when editing item attributes is to present to the user the values entered for the previous item and, where present, the corresponding tag/frame content for attributes title, performer, author, description, album and year.  This option suppresses presentation of existing tag/frame content.

The previous paragraph applies to new (not previously processed) audio files.  If the '-a' option is in effect then previously processed files in the directory will be re-processed.  When a file is re-processed only existing values are presented.  This happens regardless of whether the '-i' option is present.

=back

=head1 STRUCTURE

RSS feed files consist of one or more channels, each of which contains one or more items.  Each item is a single audio track.  In this implementation there is only one channel per RSS feed.  If you have multiple channels you will have to create an RSS feed for each one.

This script defines the following classes (packages):

=head2 'DnRss'

Models the rss feed and a single channel.

=head2 'DnItem'

Models a single channel item.  Data are assembled from file storage, podcast file attributes, audio file tags and user input.

=head2 'DnAudioFile'

Models a single podcast audio file.  Utilises a subsidiary package to write and read information from audio file tags and frames.  The particular subsidiary package used for a file depends upon its mime type.

=head2 'DnMp3File'

Models a single mp3 file.  Handle writing and reading of file tags and frames.

=head1 PACKAGE: DnMp3File

An internal package encapsulating methods and data for updating podcast mp3 file tags and retrieving information about podcast mp3 files.

This package is used by DnAudioFile when the audio file underlying the channel item is an mp3 file.

=cut

package DnMp3File;

use strict;
use warnings;
use parent qw/ Dn::PodcastsRss /;

our $VERSION = '0.1';

use constant TRUE => 1;
use constant FALSE => 0;

=head2 Dependencies

The following perl modules are required:

=head3 MP3::Tag

Used for reading and writing mp3 tags.

Debian: provided by package 'libmp3-tag-perl'.

=cut

use MP3::Tag;

=head2 Methods

=head3 Data Members

$self = {

	'$filename'  =>  "<filename>" ,

	'$mp3'   =>  MP3::Tag object ,

}

=cut

sub new {
	my $proto = shift;
	my $class = ref($proto) || $proto;
	my $self  = {};

=over

=item

B<filename>

File name of audio file.

=cut

	$self->{'filename'} = shift;  # undef if no file path parameter

=item

B<mp3>

Subsidiary mp3 file object which does tag editing and reading.  Currently module MP3::Tag is used.  Necessary configuration is done after object creation. 

=cut

	$self->{'mp3'} = MP3::Tag->new( $self->{'filename'} );
	$self->{'mp3'}->config( 'write_v24' => TRUE );
	$self->{'mp3'}->config( 'autoinfo' => 'ID3v2' , 'ID3v1' );

=back

=head3 Constructors

There is one method signature:

	my $ojb = DnMp3File->new( $file );

=cut

	bless ( $self , $class );
	return $self;
}

=head3 Setters

	$i->set_title( $title );
	$i->set_description( $description );
	$i->set_author( $author );
	$i->set_performer( $performer );
	$i->set_genre( $genre );
	$i->set_album( $album );
	$i->set_disc( $disc );
	$i->set_track( $track );
	$i->set_year( $year );

=cut

	sub set_title {
		my ( $self , $title ) = ( shift , shift );
		my $mp3 = $self->mp3();
		$mp3->title_set( $title , TRUE );
		$mp3->update_tags();
	}
	sub set_description {
		my ( $self , $description ) = ( shift , shift );
		my $mp3 = $self->mp3();
		$mp3->comment_set( $description , TRUE );
		$mp3->update_tags();
	}
	sub set_author {
		my ( $self , $author ) = ( shift , shift );
		my $mp3 = $self->mp3();
		$mp3->select_id3v2_frame_by_descr( 'TCOM' , $author );
		$mp3->update_tags();
	}
	sub set_performer {
		my ( $self , $performer ) = ( shift , shift );
		my $mp3 = $self->mp3();
		$mp3->select_id3v2_frame_by_descr( 'TPE1' , $performer );
		$mp3->update_tags();
	}
	sub set_genre {
		my ( $self , $genre ) = ( shift , shift );
		my $mp3 = $self->mp3();
		$mp3->genre_set( $genre , TRUE );
		$mp3->update_tags();
	}
	sub set_album {
		my ( $self , $album ) = ( shift , shift );
		my $mp3 = $self->mp3();
		$mp3->album_set( $album , TRUE );
		$mp3->update_tags();
	}
	sub set_disc {
		my ( $self , $disc ) = ( shift , shift );
		my $mp3 = $self->mp3();
		$mp3->select_id3v2_frame_by_descr( 'TPOS' , $disc );
		$mp3->update_tags();
	}
	sub set_track {
		my ( $self , $track ) = ( shift , shift );
		$track =~ s/^0+//;
		my $mp3 = $self->mp3();
		$mp3->track_set( $track , TRUE );
		$mp3->update_tags();
	}
	sub set_year {
		my ( $self , $year ) = ( shift , shift );
		my $mp3 = $self->mp3();
		$mp3->year_set( $year , TRUE );
		$mp3->update_tags();
	}

=head3 Getters

	$m->mp3();  # object reference
	$m->title();
	$m->description();
	$m->author();
	$m->performer();
	$m->genre();
	$m->album();
	$m->disc();
	$m->track();
	$m->year();

=cut

	sub mp3 { $_[0]->{'mp3'}; }
	sub title {
		my $self = shift;
		my $mp3 = $self->mp3();
		$mp3->title();
	}
	sub description {
		my $self = shift;
		my $mp3 = $self->mp3();
		$mp3->comment();
	}
	sub author {
		my $self = shift;
		my $mp3 = $self->mp3();
		$mp3->select_id3v2_frame_by_descr( 'TCOM' );
	}
	sub performer {
		my $self = shift;
		my $mp3 = $self->mp3();
		$mp3->performer();
	}
	sub genre {
		my $self = shift;
		my $mp3 = $self->mp3();
		$mp3->genre();
	}
	sub album {
		my $self = shift;
		my $mp3 = $self->mp3();
		$mp3->album();
	}
	sub disc {
		my $self = shift;
		my $mp3 = $self->mp3();
		$mp3->select_id3v2_frame( 'TPOS' , undef , undef );
	}
	sub track {
		my $self = shift;
		my $mp3 = $self->mp3();
		$mp3->track();
	}
	sub year {
		my $self = shift;
		my $mp3 = $self->mp3();
		$mp3->year();
	}

=head1 PACKAGE: DnAudioFile

An internal package encapsulating methods and data for updating podcast audio file tags and retrieving information about podcast audio files.

This package is an "envelope" of sorts.  It calls upon one of a number of subsidiary packages to handle all input and output.  It chooses which subsidiary package to use based on the mime type of the audio file forming the basis of the channel item.

=cut

package DnAudioFile;

use strict;
use warnings;
use parent qw/ Dn::PodcastsRss /;

our $VERSION = '0.1';

use constant TRUE => 1;
use constant FALSE => 0;

=head2 Methods

=head3 Data Members

$self = {

	'filename'  =>  $filename ,

	'object'    =>  DnXxxxFile object ,

}

=cut

sub new {
	my $proto = shift;
	my $class = ref($proto) || $proto;
	my $self  = {};

=over

=item

B<filename>

File name of audio file.

=cut

	$self->{'filename'} = shift;  # undef if no file path parameter

=item

B<object>

Subsidiary audio file object.  The file type determines what package is used to create the object.  All have the same method signature and methods.

=cut

	$self->{'object'} = undef;

=back

=head3 Constructors

There is one method signature:

	my $ojb = DnAudioFile->new( $file );

=cut

	bless ( $self , $class );
	return $self;
}

=head3 Setters

The 'set_object' setter method constructs a subsidiary object.  It chooses from several possible subsidiary objects based on the mime type of the audio file this object is based upon.

	$i->set_object();
	$i->set_title( $title );
	$i->set_description( $description );
	$i->set_author( $author );
	$i->set_performer( $performer );
	$i->set_genre( $genre );
	$i->set_album( $album );
	$i->set_disc( $disc );
	$i->set_track( $track );
	$i->set_year( $year );

=cut

	sub set_object {
		my ( $self ) = ( shift );
		my $file = $self->filename();
		my $mime_type = $self->mime_type();
		# must be an audio file
		die "'$file' ($mime_type) is not an audio file"
			if not $self->audio_mime_type( $file );
		# create subsidiary object based on audio mime type
		if ( $self->mp3_mime_type( $file ) ) {
			$self->{'object'} = DnMp3File->new( $file );
		} else {
			die "'$file' has unknown audio mime type '$mime_type'";
		}
	}
	sub set_title {
		my ( $self , $title ) = ( shift , shift );
		$self->set_object() if not $self->object();
		$self->{'object'}->set_title( $title );
	}
	sub set_description {
		my ( $self , $description ) = ( shift , shift );
		$self->set_object() if not $self->object();
		$self->{'object'}->set_description( $description );
	}
	sub set_author {
		my ( $self , $author ) = ( shift , shift );
		$self->set_object() if not $self->object();
		$self->{'object'}->set_author( $author );
	}
	sub set_performer {
		my ( $self , $performer ) = ( shift , shift );
		$self->set_object() if not $self->object();
		$self->{'object'}->set_performer( $performer );
	}
	sub set_genre {
		my ( $self , $genre ) = ( shift , shift );
		$self->set_object() if not $self->object();
		$self->{'object'}->set_genre( $genre );
	}
	sub set_album {
		my ( $self , $album ) = ( shift , shift );
		$self->set_object() if not $self->object();
		$self->{'object'}->set_album( $album );
	}
	sub set_disc {
		my ( $self , $disc ) = ( shift , shift );
		$self->set_object() if not $self->object();
		$self->{'object'}->set_disc( $disc );
	}
	sub set_track {
		my ( $self , $track ) = ( shift , shift );
		$self->set_object() if not $self->object();
		$self->{'object'}->set_track( $track );
	}
	sub set_year {
		my ( $self , $year ) = ( shift , shift );
		$self->set_object() if not $self->object();
		$self->{'object'}->set_year( $year );
	}

=head3 Getters

	$a->filename();
	$a->mime_type();
	$a->object();
	$a->title();
	$a->description();
	$a->author();
	$a->performer();
	$a->genre();
	$a->album();
	$a->disc();
	$a->track();
	$a->year();

=cut

	sub filename {
		my ( $self ) = ( shift );
		$self->{'filename'};
	}
	sub mime_type {
		my ( $self ) = ( shift );
		$self->file_mime_type( $self->filename() );
	}
	sub object {
		my ( $self ) = ( shift );
		$self->{'object'};
	}
	sub title {
		my ( $self ) = ( shift );
		$self->set_object() if not $self->object();
		$self->object()->title();
	}
	sub description {
		my ( $self ) = ( shift );
		$self->set_object() if not $self->object();
		$self->object()->description();
	}
	sub author {
		my ( $self ) = ( shift );
		$self->set_object() if not $self->object();
		$self->object()->author();
	}
	sub performer {
		my ( $self ) = ( shift );
		$self->set_object() if not $self->object();
		$self->object()->performer();
	}
	sub genre {
		my ( $self ) = ( shift );
		$self->set_object() if not $self->object();
		$self->object()->genre();
	}
	sub album {
		my ( $self ) = ( shift );
		$self->set_object() if not $self->object();
		$self->object()->album();
	}
	sub disc {
		my ( $self ) = ( shift );
		$self->set_object() if not $self->object();
		$self->object()->disc();
	}
	sub track {
		my ( $self ) = ( shift );
		$self->set_object() if not $self->object();
		$self->object()->track();
	}
	sub year {
		my ( $self ) = ( shift );
		$self->set_object() if not $self->object();
		$self->object()->year();
	}

=head1 PACKAGE: DnItem

An internal package encapsulating methods and data for updating podcast mp3 file tags and retrieving information about podcast mp3 files.

The following is a list of what is required to generate an rss feed channel item.  The source of each is shown.

	audio file: in directory
	title: tag 'title'
	description: tag 'comment'
	filepath/guid: channel attribute 'base_url' + file attribute 'filename'
	type: file attribute 'mime-type'
	size: file attribute 'size'
	pubdate: saved channel object state

In summary, then, here are the sources for rss feed channel items metadata:

	file attributes: 'filename', 'mime-type' and 'size',
	tags: 'title' and 'comment',
	channel attributes: 'base_url' and
	saved object state: 'pubdate'

The audio file tags mentioned are able to be edited.  There are other tags and frames that are not required for generating an rss feed channel item, but that users often want to alter for the sake of completeness.  As a convenience, this utility enables setting them as well.  These additional tags are:

	author
	performer
	album
	year
	genre: default = 'Podcast'
	disc:  default = ''
	track: default = ''

=cut

package DnItem;

use strict;
use warnings;
use parent qw/ Dn::PodcastsRss /;

our $VERSION = '0.1';

use constant TRUE => 1;
use constant FALSE => 0;

=head2 Dependencies

The following perl modules are required:

=head3 Date::Simple

Used for writing date strings.

Debian: provided by package 'libdate-simple-perl'.

=cut

use Date::Simple;

=head3 Date::Calc

Provides functions for manipulating date-times, including 'Delta_Days'.

Debian: provided by package 'libdate-calc-perl'.

=cut

use Date::Calc qw( Delta_Days );

=head3 File::Util

Used for various file and directory operations, including recursive directory creation and extracting filename and/or dirpath from a filepath.

Debian: provided by package 'libfile-util-perl'.

=cut

use File::Util;

=head3 File::Copy

Used for file copying.  Provides the 'copy' and 'move' functions.

Debian: provided by package 'perl-modules'.

=cut

use File::Copy;
use Data::Dumper;
=head2 Methods

=head3 Data Members

$self = {

	'filename'          =>  $filename ,

	'audiofile'         =>  DnAudioFile ,

	'base_url'          =>  $base_url ,

	'file_attributes'   =>  $hash_ref ,

	'pubdate_method'    =>  $pubdate_method ,

	'other_attributes'  =>  $hash_ref ,

	'ignore_tags'       =>  $boolean ,

}

=cut

sub new {
	my $proto = shift;
	my $class = ref($proto) || $proto;
	my $self  = {};

=over

=item

B<filename>

Name of audio file.

=cut

	$self->{'filename'} = shift;  # undef if no file name parameter

=item

B<audiofile>

Audio file object used to manipulate file tags and file name.

=cut

	$self->{'audiofile'} = DnAudioFile->new( $self->{'filename'} );

=item

B<base_url>

URL base prepended to filename when forming item link and guid.

=cut

	$self->{'base_url'} = shift;

=item

B<file_attributes>

Hash of audiofile file attributes.  This is a template of sorts applied to each audio file in turn.  The user has the opportunity to alter it before the values are applied to the audiofile.

=cut

	$self->{'file_attributes'} = shift;

=item

B<pubdate_method>

Method by which publication date is assigned.

=cut

	$self->{'pubdate_method'} = shift;

=item

B<other_attributes>

Item attributes that are not stored in the audiofile itself.

=cut

	$self->{'other_attributes'} = shift;

=item

B<ignore_tag_content>

Whether to ignore current tag/frame content when presenting potential items attributes to the user.

=cut

	$self->{'ignore_tags'} = shift;

=back

=head3 Constructors

There is one method signature:

	my $ojb = DnItem->new(
		$filename ,
		$base_url ,
		$file_attributes_hash_ref ,
		$pubdate_method ,
		$other_attributes_hash_ref ,
		$ignore_tags ,
	);

=cut

	bless ( $self , $class );
	return $self;
}

=head3 Setters

Audio file object is set at object construction but may later be reset.

All other object values are set at construction time.  Only the file_attributes and other_attributes hashes are altered by this object and that is done directly by other methods.

These setters update audio file tags and the 'other_attributes' hash.

	$i->set_filename( $filename );
	$i->set_audiofile( $filename );
	$i->set_filename( $file );
	$i->set_title( $title );
	$i->set_description( $description );
	$i->set_author( $author );
	$i->set_performer( $performer );
	$i->set_genre( $genre );
	$i->set_pubdate( $pubdate );
	$i->set_album( $album );
	$i->set_disc( $disc );
	$i->set_track( $track );
	$i->set_year( $year );

=cut

	sub set_audiofile { $_[0]->{'audiofile'} = DnAudioFile->new( $_[1] ); }
	sub set_filename {
		my ( $self , $new_file ) = ( shift , shift );
		my $current_file = $self->filename();
		return if $new_file eq $current_file;
		move( $current_file , $new_file )
			or die "Unable to rename file '$current_file'";
		# rename object data member
		$self->{'filename'} = $new_file;
		# rename attribute hash passed from channel
		$self->{'other_attributes'}->{$new_file}
			= $self->{'other_attributes'}->{$current_file};
		delete $self->{'other_attributes'}->{$current_file};
		# recreate audio file object
		$self->set_audiofile( $new_file );
	}
	sub set_title {
		my ( $self , $title ) = ( shift , shift );
		return if $title eq ( ( $self->title() ) ? $self->title() : '' );
		$self->{'audiofile'}->set_title( $title );
	};
	sub set_description {
		my ( $self , $description ) = ( shift , shift );
		return if $description
			eq ( ( $self->description() ) ? $self->description() : '' );
		$self->{'audiofile'}->set_description( $description );
	};
	sub set_author {
		my ( $self , $author ) = ( shift , shift );
		return if $author eq ( ( $self->author() ) ? $self->author() : '' );
		$self->{'audiofile'}->set_author( $author );
	};
	sub set_performer {
		my ( $self , $performer ) = ( shift , shift );
		return if $performer 
			eq ( ( $self->performer() ) ? $self->performer() : '' );
		$self->{'audiofile'}->set_performer( $performer );
	};
	sub set_genre {
		my ( $self , $genre ) = ( shift , shift );
		return if $genre eq ( ( $self->genre() ) ? $self->genre() : '' );
		$self->{'audiofile'}->set_genre( $genre );
	};
	sub set_pubdate {
		my ( $self , $pubdate ) = ( shift , shift );
		my $file = $self->filename();
		$self->{'other_attributes'}->{$file}->{'pubdate'} = $pubdate;
	};
	sub set_album {
		my ( $self , $album ) = ( shift , shift );
		return if $album eq ( ( $self->album() ) ? $self->album() : '' );
		$self->{'audiofile'}->set_album( $album );
	};
	sub set_disc {
		my ( $self , $disc ) = ( shift , shift );
		return if $disc eq ( ( $self->disc() ) ? $self->disc() : '' );
		$self->{'audiofile'}->set_disc( $disc );
	};
	sub set_track {
		my ( $self , $track ) = ( shift , shift );
		return if $track eq ( ( $self->track() ) ? $self->track() : '' );
		$self->{'audiofile'}->set_track( $track );
	};
	sub set_year {
		my ( $self , $year ) = ( shift , shift );
		return if $year eq ( ( $self->year() ) ? $self->year() : '' );
		$self->{'audiofile'}->set_year( $year );
	};

=pod

These setters update the in-memory data structure used to store/edit attribute values.  Series, episode and part have no persistent value and so cannot be retrieved -- the relevant value is instead changed to an empty string.

	$i->load_file_mask( $file_mask );
	$i->load_title_mask( $title_mask );
	$i->load_description_mask( $description_mask );
	$i->load_author( $author );
	$i->load_performer( $performer );
	$i->load_genre( $genre );
	$i->load_pubdate( $pubdate );
	$i->load_album( $album );
	$i->load_disc( $disc );
	$i->load_track( $track );
	$i->load_year( $year );
	$i->load_series( $series );
	$i->load_episode( $episode );
	$i->load_part( $part );
	$i->load_exclude( $exclude );
	$i->load_increment( $increment );
	$i->load_sequence( $sequence );

=cut

	sub load_file_mask {
		$_[0]->file_attributes()->{'file_mask'}->{'value'} = $_[1];
	}
	sub load_title_mask {
		$_[0]->file_attributes()->{'title_mask'}->{'value'} = $_[1];
	}
	sub load_description_mask {
		$_[0]->file_attributes()->{'description_mask'}->{'value'} = $_[1];
	}
	sub load_author {
		$_[0]->file_attributes()->{'author'}->{'value'} = $_[1];
	}
	sub load_performer {
		$_[0]->file_attributes()->{'performer'}->{'value'} = $_[1];
	}
	sub load_genre {
		$_[0]->file_attributes()->{'genre'}->{'value'} = $_[1];
	}
	sub load_pubdate {
		$_[0]->file_attributes()->{'pubdate'}->{'value'} = $_[1];
	}
	sub load_album {
		$_[0]->file_attributes()->{'album'}->{'value'} = $_[1];
	}
	sub load_disc {
		$_[0]->file_attributes()->{'disc'}->{'value'} = $_[1];
	}
	sub load_track {
		$_[0]->file_attributes()->{'track'}->{'value'} = $_[1];
	}
	sub load_year {
		$_[0]->file_attributes()->{'year'}->{'value'} = $_[1];
	}
	sub load_series {
		$_[0]->file_attributes()->{'series'}->{'value'} = $_[1];
	}
	sub load_episode {
		$_[0]->file_attributes()->{'episode'}->{'value'} = $_[1];
	}
	sub load_part {
		$_[0]->file_attributes()->{'part'}->{'value'} = $_[1];
	}
	sub load_exclude{
		$_[0]->file_attributes()->{'exclude'}->{'value'} = $_[1];
	}
	sub load_increment{
		$_[0]->file_attributes()->{'increment'}->{'value'} = $_[1];
	}
	sub load_sequence{
		$_[0]->file_attributes()->{'sequence'}->{'value'} = $_[1];
	}

=head3 Getters

These getters read from item attributes stored in audio file tags and other_attributes hash. 

	$i->filename();
	$i->mime_type();
	$i->base_url();
	$i->audiofile();  # returns hash_ref
	$i->title();
	$i->description();
	$i->url();
	$i->length();
	$i->author();
	$i->performer();
	$i->genre();
	$i->album();
	$i->track();
	$i->disc();
	$i->year();
	$i->file_attributes();  # hash_ref
	$i->other_attributes();  # hash_ref
	$i->pubdate_method();
	$i->pubdate();
	$i->ignore_tags();

=cut

	sub filename         { $_[0]->{'filename'};                          }
	sub mime_type        { $_[0]->file_mime_type( $_[0]->filename() );   }
	sub base_url         { $_[0]->{'base_url'};                          }
	sub audiofile        { $_[0]->{'audiofile'};                         }
	sub title            { $_[0]->audiofile()->title();                  }
	sub description      { $_[0]->audiofile()->description();            }
	sub url              {
		sprintf( "%s/%s" , $_[0]->base_url() , $_[0]->filename() );
	}
	sub length           { File::Util->new()->size( $_[0]->filename() ); }
	sub author           { $_[0]->audiofile()->author();                 }
	sub performer        { $_[0]->audiofile()->performer();              }
	sub genre            { $_[0]->audiofile()->genre();                  }
	sub album            { $_[0]->audiofile()->album();                  }
	sub track            { $_[0]->audiofile()->track();                  }
	sub disc             { $_[0]->audiofile()->disc();                   }
	sub year             { $_[0]->audiofile()->year();                   }
	sub file_attributes  { $_[0]->{'file_attributes'};                   }
	sub other_attributes { $_[0]->{'other_attributes'};                  }
	sub pubdate_method   { $_[0]->{'pubdate_method'};                    }
	sub pubdate          {
		$_[0]->other_attributes()->{$_[0]->filename()}->{'pubdate'};
	}
	sub ignore_tags      { $_[0]->{'ignore_tags'};                       }

=pod

These getters read from the file attributes hash stored in memory.

	$i->read_file_mask();
	$i->read_title_mask();
	$i->read_description_mask();
	$i->read_author();
	$i->read_performer();
	$i->read_genre();
	$i->read_album();
	$i->read_track();
	$i->read_disc();
	$i->read_year();
	$i->read_pubdate();

=cut

	sub read_file_mask{
		$_[0]->file_attributes()->{'file_mask'}->{'value'};
	}
	sub read_title_mask{
		$_[0]->file_attributes()->{'title_mask'}->{'value'};
	}
	sub read_description_mask{
		$_[0]->file_attributes()->{'description_mask'}->{'value'};
	}
	sub read_author{
		$_[0]->file_attributes()->{'author'}->{'value'};
	}
	sub read_performer{
		$_[0]->file_attributes()->{'performer'}->{'value'};
	}
	sub read_genre{
		$_[0]->file_attributes()->{'genre'}->{'value'};
	}
	sub read_album{
		$_[0]->file_attributes()->{'album'}->{'value'};
	}
	sub read_track{
		$_[0]->file_attributes()->{'track'}->{'value'};
	}
	sub read_disc{
		$_[0]->file_attributes()->{'disc'}->{'value'};
	}
	sub read_year{
		$_[0]->file_attributes()->{'year'}->{'value'};
	}
	sub read_pubdate{
		$_[0]->file_attributes()->{'pubdate'}->{'value'};
	}

=head3 Other

=head4 next_iso_day()

Takes a date and returns the date of the following day.

Note that the supplied date is NOT checked for validity.

All dates are in iso format:

	yyyy-mm-dd

Parameters: [ 0 = class ] , 1 = date.

Return type: Scalar (string date).

=cut

sub next_iso_day { Date::Simple->new( $_[1] )->next()->as_str(); }

=head4 previous_iso_day()

Takes a date and returns the date of the previous day.

Note that the supplied date is NOT checked for validity.

All dates are in iso format:

	yyyy-mm-dd

Parameters: [ 0 = class ] , 1 = date.

Return type: Scalar (string date).

=cut

sub previous_iso_day { Date::Simple->new( $_[1] )->prev()->as_str(); }

=head4 by_chronology()

Sort routine used to sort list of dates into chronological order: oldest date first and most recent date last.  All dates are strings complying with iso date format 'yyyy-mm-dd'.

Note that the supplied dates are NOT checked for validity.

Uses module Date::Calc, function 'Delta_Days'.

This method would be used as follows:

	my @dates_ordered = sort by_chronology @dates_unordered;

Parameters: [ 0 = class ].

Return type: List.

=cut

sub by_chronology {
	# a sort subroutine, expect $a and $b
	my $delta = Delta_Days( split( '-' , $a ) , split( '-' , $b ) );
	if ( $delta > 0 ) { -1 } elsif ( $delta < 0 ) { 1 } else { 0 };
}

=head4 oldest_iso_date()

Takes a list of dates and determines the oldest.  All dates are strings complying with iso date format 'yyyy-mm-dd'.

Note that the supplied dates are NOT checked for validity.

The list is passed by reference:

	my $oldest = $self->oldest_iso_date( \@dates );

Parameters: [ 0 = class ] , 1 = date list reference.

Return type: Scalar (string date).

=cut

sub oldest_iso_date { ( sort by_chronology @{ $_[1] } )[0]; }

=head4 newest_iso_date()

Takes a list of dates and determines the most recent.  All dates are strings complying with iso date format 'yyyy-mm-dd'.

Note that the supplied dates are NOT checked for validity.

The list is passed by reference:

	my $latest = $self->newest_iso_date( \@dates );

Parameters: [ 0 = class ] , 1 = date list reference.

Return type: Scalar (string date).

=cut

sub newest_iso_date { ( sort by_chronology @{ $_[1] } )[-1]; }

=head4 apply_mask()

Apply mask to attribute.

A set of attributes is supplied, as is the name of the attribute to which the mask is applied.  The mask consists of fixed text and tokens representing other attributes.  The tokens are replaced by the appropriate attribute values.

A optional parameter enables removal of leading zeroes from attribute values before substitution.  Another optional parameter enables removal of hyphens from iso dates.

Once all conversions have been applied the transformed value is returned.

Parameters: [ 0 = class ] , 1 = attribute, 2 = attribute set reference, 3 = remove leading zeroes (boolean, optional, default = FALSE), 4 = remove date hyphens (boolean, optional, default = FALSE).

Return type: Scalar (string).

=cut

sub apply_mask {
	my ( $self , $attribute , $attributes , $remove_zeroes , $dehyphen_dates )
		= ( shift , shift , shift , shift , shift );
	$remove_zeroes = FALSE if not $remove_zeroes;
	$dehyphen_dates = FALSE if not $dehyphen_dates;
	my ( $mask , %tokens );
	# process attributes
	foreach my $key ( keys %{ $attributes } ) {
		# get mask
		$mask = $attributes->{$key}->{'value'} if $key eq $attribute;
		# assemble tokens and their replacement values
		if ( $attributes->{$key}->{'token'} ) {
			if ( $attributes->{$key}->{'value'} ) {
				my $value = $attributes->{$key}->{'value'};
				$value =~ s/^0+// if $remove_zeroes;
				$value =~ s/(\d{4})-(\d{2})-(\d{2})/$1$2$3/g if $dehyphen_dates;
				$tokens{$attributes->{$key}->{'token'}} = $value;
			}
		}
	}
	die "Could not retrieve mask for '$attribute'" if not $mask;
	# replace tokens
	while ( my ( $key , $value ) = each %tokens ) {
		$mask =~ s/$key/$value/g;
	}
	$mask;
}

=head4 valid_audio_filename()

Audio filenames must not contain uppercase characters or spaces.

Parameters: [ 0 = class ] , 1 = filename.

Return type: Boolean.

=cut

sub valid_audio_filename {
	my ( $self , $file ) = ( shift , shift );
	return FALSE if $file =~ m/[A-Z]/;
	return FALSE if $file =~ m/\s/;
	TRUE;
}

=head4 valid_iso_date()

Determine whether supplied date is a valid iso date, i.e., of format:

	yyyy-mm-dd

Parameters: [ 0 = class ] , 1 = date.

Return type: Boolean.

=cut

sub valid_iso_date {
	( $_[1] =~ /^\d{4}-\d{2}-\d{2}$/ and Date::Simple->new( $_[1] ) ) ? TRUE : FALSE;
}

=head4 set_attributes()

Set all item attributes.

First, the file hash is updated with all other attributes so user edits all attributes in a single file.  One of the other attributes is pubdate.  The next pubdate is predicted using pubdate_method before presenting attributes to the user.

Some additional attributes are then derived:

	filename is derived from filename mask and numerical/date attributes,
	title is derived from title mask and numerical/date attributes, and
	description is derived from description mask and numerical/date attributes.
	
Checks not performed by the attribute editing method are then performed:

	filename must be all lowercase with no spaces.

Once the user has specified the attributes they are set.  First the filename is changed if required -- this involves:

	changing the filename data member,
	regenerating the audiofile object,
	copying the other_attributes entry for the new filename, and
	deleting the other_attributes entry for the old filename.

The audiofile object is used to set all file attributes.  The other attributes are then altered.

Parameters: [ 0 = class ].

Return type: Boolean (false if user aborts).

=cut

sub set_attributes {
	my ( $self , $attributes_set , @dates , $pubdate , @fragments )
		= ( shift , FALSE );
	my ( $title , $filename , $description ) = ();
	my $attrs = $self->file_attributes();
	my $other = $self->other_attributes();
	my $pubdate_method = $self->pubdate_method();
	if ( $other and %{ $other } ) {
		foreach my $file ( keys %{ $other } ) {
			push @dates , $other->{$file}->{'pubdate'};
		}
	}
	push @dates , '2008-07-01' if not @dates;
	# check date validity
	foreach ( @dates ) {
		die "Invalid pubdate '$_' in stored item data\n"
			unless $self->valid_iso_date( $_ );
	}
	# predict next pubdate
	# must be exactly two items in @fragments
	# switch: pubdate_method
	# case: 'descend'
	( grep $pubdate_method eq $_ , qw/ descend / ) and do {
		my $oldest = $self->oldest_iso_date( \@dates );
		@fragments = (
			"each new item gets an older date" ,
			"the oldest pubdate so far is $oldest" ,
		);
		$pubdate = $self->previous_iso_day( $oldest );
	};
	# case: 'ascend'
	( grep $pubdate_method eq $_ , qw/ ascend / ) and do {
		my $newest = $self->newest_iso_date( \@dates );
		@fragments = (
			"each new item gets a newer date" ,
			"the most recent pubdate so far is $newest" ,
		);
		$pubdate = $self->next_iso_day( $newest );
	};
	# case: 'provide'
	( grep $pubdate_method eq $_ , qw/ provide / ) and do {
		my $newest = $self->newest_iso_date( \@dates );
		@fragments = (
			"you enter a date for each new item" ,
			"defaulting to the most recent pubdate" ,
		);
		$pubdate = $newest;
	};
	# case: default
	( not grep $pubdate_method eq $_ ,
			qw/ descend ascend provide / ) and do {
		die "Invalid pubdate method '$pubdate_method'";
	};
	# endswitch
	$attrs->{'pubdate'} = {
		'value'     =>  $pubdate ,
		'token'     =>  '%U' ,
		'options'   =>  [] ,
		'required'  =>  TRUE ,
		'help'      =>  [
			"publication date of item; the pubdate selection method for" ,
			"this channel is set to $pubdate_method, meaning" ,
			"$fragments[0];" ,
			"$fragments[1];" ,
			"value may be used in file name or audio file title or" ,
			"description tags" ,
		] ,
	};
	# if no masks use filename
	$attrs->{'file_mask'}->{'value'} = lc( $self->filename() )
		if not $attrs->{'file_mask'}->{'value'};
	$attrs->{'title_mask'}->{'value'} = $self->filename()
		if not $attrs->{'title_mask'}->{'value'};
	$attrs->{'description_mask'}->{'value'} = $self->filename()
		if not $attrs->{'description_mask'}->{'value'};
	# if file already processed then overwrite attribute hash
	# with existing item values
	my $already_processed = FALSE;
	if ( grep { $self->filename() eq $_ } keys %{ $other } ) {
		# file previously processed
		$already_processed = TRUE;
		$self->load_file_mask( $self->filename() );
		$self->load_title_mask( $self->title() );
		$self->load_description_mask( $self->description() );
		$self->load_author( $self->author() );
		$self->load_performer( $self->performer() );
		$self->load_genre( $self->genre() );
		$self->load_pubdate(
			$self->other_attributes()->{$self->filename()}->{'pubdate'}
		);
		$self->load_album( $self->album() );
		$self->load_disc( $self->disc() );
		$self->load_track( $self->track() );
		$self->load_year( $self->year() );
		$self->load_series( '' );
		$self->load_episode( '' );
		$self->load_part( '' );
		$self->load_exclude( '' );
		$self->load_increment( '' );
		$self->load_sequence( 'file_mask title_mask description_mask pubdate year performer author genre disc track album series episode part increment sequence exclude' );
	} else {  # file not previously processed
		# to certain attributes prepend existing tag value
		my ( $file_mask , $title_mask , $description_mask, $performer ,
		     $author, $album , $year ) = ( '', '' , '' , '' , '' , '' , '' );
		$file_mask = $self->filename();  # set to tag
		if ( $self->read_file_mask()
				and $file_mask ne $self->read_file_mask() ) {
			# if attribute hash ('template') value exists and is different
			# then provide it as well
			if ( $file_mask ) {  # two values so use separator
				$file_mask = $self->read_file_mask() . '::' .  $file_mask;
			} else {
				$file_mask = $self->read_file_mask();
			}
		}
		$self->load_file_mask( $file_mask );
		# - title_mask
		$title_mask = $self->title() unless $self->ignore_tags();  # set to tag
		if ( $self->read_title_mask()
				and $title_mask ne $self->read_title_mask() ) {
			# if attribute hash ('template') value exists and is different
			# then provide it as well
			if ( $title_mask ) {  # two values so use separator
				$title_mask = $title_mask . '::' . $self->read_title_mask();
			} else {
				$title_mask = $self->read_title_mask();
			}
		}
		$self->load_title_mask( $title_mask );
		# - description_mask
		$description_mask = $self->description() unless $self->ignore_tags();
		if ( $self->read_description_mask()
				and $description_mask ne $self->read_description_mask() ) {
			if ( $description_mask ) {
				$description_mask = $description_mask . '::' .
				                    $self->read_description_mask();
			} else {
				$description_mask = $self->read_description_mask();
			}
		}
		$self->load_description_mask( $description_mask );
		# - performer
		$performer = $self->performer() unless $self->ignore_tags();
		if ( $self->read_performer()
				and $performer ne $self->read_performer() ) {
			if ( $performer ) {
				$performer = $performer . '::' . $self->read_performer();
			} else {
				$performer = $self->read_performer();
			}
		}
		$self->load_performer( $performer );
		# - author
		$author = $self->author() unless $self->ignore_tags();
		# -- prevent 'unitialised value' error in next 'if' statement
		$author = '' unless $author;
		if ( $self->read_author()
				and $author ne $self->read_author() ) {
			if ( $author ) {
				$author = $author . '::' . $self->read_author();
			} else {
				$author = $self->read_author();
			}
		}
		$self->load_author( $author );
		# - album
		$album = $self->album() unless $self->ignore_tags();
		if ( $self->read_album()
				and $album ne $self->read_album() ) {
			if ( $album ) {
				$album = $album . '::' . $self->read_album();
			} else {
				$album = $self->read_album();
			}
		}
		$self->load_album( $album );
		# - year
		$year = $self->year() unless $self->ignore_tags();
		if ( $self->read_year()
				and $year ne $self->read_year() ) {
			if ( $year ) {
				$year = $year . '::' . $self->read_year();
			} else {
				$year = $self->read_year();
			}
		}
		$self->load_year( $year );
	}
	# preamble for attribute editing
	my $preamble = [
		"Your are editing attributes for channel item:" ,
		"  " . $self->filename ,
		"==============================================\n" ,
	];
	# repeat this text with each attribute
	my $repeat = [ "{item = '" . $self->filename . "'}" ];
	# specify attribute values
	my $first_loop = TRUE;
	while ( not $attributes_set ) {
		# increment only on first loop, but never if already processed
		my $no_increment = ( $first_loop ) ? FALSE : TRUE;
		$no_increment = TRUE if $already_processed;
		# edit attributes now
		$self->edit_attribute_set(
			$attrs , $preamble , $repeat , $no_increment
		) or die "Aborting at user request\n";
		# now derive additional attributes
		# - for filename remove iso date hypens
		# - for title and description remove leading zeroes
		$filename = $self->apply_mask( 'file_mask' , $attrs , FALSE , TRUE );
		$title = $self->apply_mask( 'title_mask' , $attrs , TRUE );
		$description = $self->apply_mask( 'description_mask' , $attrs , TRUE);
		# check all attributes validly set
		$attributes_set = TRUE;
		if ( not $self->valid_audio_filename( $filename ) ) {
			$attributes_set = FALSE;
			print "Error: File name cannot contain upper case or whitespace\n";
		}
		if ( not $self->valid_iso_date( $attrs->{'pubdate'}->{'value'} ) ) {
			$attributes_set = FALSE;
			print "Error: Attribute 'pubdate' has an invalid value\n";
		}
		# option to quit
		if ( not $attributes_set ) {
			my $msg = "Quit?\n\n"
					. "If you continue you will have to "
					. "re-edit problem attributes";
			return FALSE if $self->ui_confirm( $msg );
		}
		$first_loop = FALSE;
	}
	# set attribute values
	$self->set_filename( $filename );
	$self->set_title( $title );
	$self->set_description( $description );
	$self->set_author( $attrs->{'author'}->{'value'} );
	$self->set_performer( $attrs->{'performer'}->{'value'} );
	$self->set_genre( $attrs->{'genre'}->{'value'} );
	$self->set_pubdate( $attrs->{'pubdate'}->{'value'} );
	$self->set_album( $attrs->{'album'}->{'value'} );
	$self->set_disc( $attrs->{'disc'}->{'value'} );
	$self->set_track( $attrs->{'track'}->{'value'} );
	$self->set_year( $attrs->{'year'}->{'value'} );
	TRUE;  # if reached here then exiting successfully
}

=head1 PACKAGE: DnRss

An internal package encapsulating methods and data for manipulating an rss feed.  Incorporates rss feed and its consituent channel.

=cut

package DnRss;

use strict;
use warnings;
use parent qw/ Dn::PodcastsRss /;

our $VERSION = '0.1';

use constant TRUE => 1;
use constant FALSE => 0;

# file used to store object state between invocations
use constant STORE_state => '@stored_state@';
use constant STORE_initial => '/usr/share/@pkg@/@initial_state@';
use constant RSS_xml => 'rss-feed.xml';
use constant RSS_opml => 'rss-feed.opml';

=head2 Dependencies

The following perl modules are required:

=head3 XML::Dumper

Used to save object state to xml file.

Debian: provided by package 'libxml-dumper-perl'.

=cut

use XML::Dumper;
our $dump = new XML::Dumper;

use Data::Dumper;  ### DELETE

=head3 XML::RSS

Used to write rss xml feed file.

Debian: provided by package 'libxml-rss-perl'.

=cut

use XML::RSS;

=head3 XML::OPML

Used to write rss opml feed exchange file.

Debian: provided by package 'libxml-opml-perl'.

=cut

use XML::OPML;

=head3 Time::ParseDate

Convert date to seconds since epoch. Provides the 'parsedate' function.

Debian: provided by package 'libtime-modules-perl'.

=cut

use Time::ParseDate;

=head3 Email::Date::Format

Enable writing of current time in RFC 2822 format.  Provides the 'email_date' function.

Debian: provided by package 'libemail-date-format-perl'.

=cut

use Email::Date::Format qw/ email_date /;

=head3 HTML::Entities

Convert to and from html emtities.  Provides the 'encode_entities' and 'decode_entities' functions.

Debian: provided by package 'libhtml-parser-perl'.

=cut

use HTML::Entities;

=head2 Methods

=head3 Data Members

$self = {

	'attributes'  =>  {
	
		'base_url'        =>  {

			'value'     =>  $basename ,

			'token'     =>  $token ,

			'options'   =>  [ $option1 , $option2 , ... ] ,

			'required'  =>  $boolean ,

			'help'      =>  [ $line1 , $line2 , ... ] ,

		} ,

		'title'           =>  ( ATTRIBUTE ) ,

		'author'          =>  ( ATTRIBUTE ) ,

		'summary'         =>  ( ATTRIBUTE ) ,

		'image'           =>  ( ATTRIBUTE ) ,

		'pubdate_method'  =>  ( ATTRIBUTE ) ,

		'sequence'        =>  ( ATTRIBUTE ) ,

		'exclude'         =>  ( ATTRIBUTE ) ,
			
	} ,

	'items'  =>  {
	
		'file_attributes'  =>  {
		
			'series'      =>       ( ATTRIBUTE ) ,

			'episode'     =>       ( ATTRIBUTE ) ,
	
			'disc'        =>       ( ATTRIBUTE ) ,
	
			'part'        =>       ( ATTRIBUTE ) ,
	
			'track'       =>       ( ATTRIBUTE ) ,
	
			'file_mask'   =>       ( ATTRIBUTE ) ,
	
			'title_mask'  =>       ( ATTRIBUTE ) ,
	
			'description_mask' =>  ( ATTRIBUTE ) ,
	
			'year'        =>       ( ATTRIBUTE ) ,
	
			'performer'   =>       ( ATTRIBUTE ) ,

			'author'      =>       ( ATTRIBUTE ) ,
	
			'genre'       =>       ( ATTRIBUTE ) ,

			'album'       =>       ( ATTRIBUTE ) ,
	
			'increment'   =>       ( ATTRIBUTE ) ,

			'sequence'    =>       ( ATTRIBUTE ) ,

			'exclude'     =>       ( ATTRIBUTE ) ,

		} ,
	
		'other_attributes'  =>  {

			$filename1  =>  {
			
				'pubdate'  =>  $iso_date ,

			} ,

			... ,

		} ,

	} ,

	'flags'  =>  {

		'all_podcasts'        =>  $boolean ,

		'ignore_tag_content'  =>  $boolean ,
	
	} ,

}

=cut

sub new {
	my $proto = shift;
	my $class = ref($proto) || $proto;
	my $self  = {};
	if ( -e STORE_state ) {  # load current state
		$self = $dump->xml2perl( STORE_state );
	} elsif ( -e STORE_initial ) {  # load default initial state
		$self = $dump->xml2perl( STORE_initial );
	} else {
		print "Could not locate initial state storage file\n";
		printf "  '%s'\n" , STORE_initial;
		die "Aborting\n";
	}

=over

=item

B<attributes>

Attributes of rss feed and channel required to create output files.

=over

=item

B<attributes>-E<gt>B<base_url>

Base url to prepend to all file paths, including items and channel image.

=item

B<attributes>-E<gt>B<title>

Channel title.

=item

B<attributes>-E<gt>B<author>

Channel author.

=item

B<attributes>-E<gt>B<summary>

Channel summary.

=item

B<attributes>-E<gt>B<image>

Filepath of channel image.  The Apple specification requires the image to be of type jpg or png.  Base url will be prepended to this filepath when outputting.

=item

B<attributes>-E<gt>B<pubdate-method>

Method by which publication date is assigned to channel items (podcast files).  Options are 'descend' (used for discrete set of podcasts such as an audiobook), 'ascend' (used for ongoing podcasts), and 'provide' (where users manually assign pubdates).

=item

B<attributes>-E<gt>B<sequence>

The order in which attributes are listed when editing.  A space-delimited list.  Attributes not included are listed after specified attributes.

=item

B<attributes>-E<gt>B<exclude>

Attributes not to include for editing.  A space-delimited list.  The script will let you add 'exclude' to the list but will always display it for editing, otherwise the user could never again change the exlusion list!

=back

=item

B<items>

Information pertaining explicitly to the channel items, i.e., podcast files.

=over

=item

B<items>-E<gt>B<file_attributes>

Channel item, i.e., podcast, attributes that are stored in the audio file itself.  These attributes are stored either in the file name or in audio file tags.  Some attributes (increment, sequence and exclude) control how other attributes are displayed.  Some attributes (album, disc and year) enable alteration of audio file tags but are not actually used in generating rss feeds -- they are included here only as a convenience.

=over

=item

B<items>-E<gt>B<file_attributes>-E<gt>B<series>

Series number.  Value may be used in file name or audio file title tag.

=item

B<items>-E<gt>B<file_attributes>-E<gt>B<episode>

Episode number.  Value may be used in file name or audio file title tag.

=item

B<items>-E<gt>B<file_attributes>-E<gt>B<disc>

Disc number.  Value may be used in file name or audio file title tag.  Also used to set ID3 frame 'disk number'.

=item

B<items>-E<gt>B<file_attributes>-E<gt>B<part>

Part number.  Value may be used in file name or audio file title tag.

=item

B<items>-E<gt>B<file_attributes>-E<gt>B<track>

Track number.  Value may be used in file name or audio file title tag.  Also used to set audio file track number tag.

=item

B<items>-E<gt>B<file_attributes>-E<gt>B<file_mask>

Mask for audio file name.  Must be in lowercase.  Can use the following tokens:

	%S = series number,
	%E = episode number,
	%D = disc number,
	%P = part number,
	%T = track number, and
	%U = publication date (pubdate).

Hyphens will be removed from any file mask iso date token values, e.g., '2001-05-10' is converted to '20010510'.

=item

B<items>-E<gt>B<file_attributes>-E<gt>B<title_mask>

Mask for file name.  Can contain any characters.  Can use same tokens available to the file mask.  Any leading zeroes in title mask token values will be removed.  Corresponds to ID3 tag 'title'.

=item

B<items>-E<gt>B<file_attributes>-E<gt>B<description_mask>

Mask for summary of individual podcast.  Can contain any characters. Can use same tokens available to the file mask.  Any leading zeroes in description mask token values will be removed.  Corresponds to ID3 tag 'comment'.

=item

B<items>-E<gt>B<file_attributes>-E<gt>B<performer>

Podcast artist.  Used to set ID3 tag 'artist'.

=item

B<items>-E<gt>B<file_attributes>-E<gt>B<author>

Podcast author.  Used to set ID3 frame 'TCOM'.

=item

B<items>-E<gt>B<file_attributes>-E<gt>B<genre>

Podcast genre.  Corresponds to ID3 tag 'genre'.  Is set to 'Podcast' by default -- this helps some mp3 devices to treat these podcasts correctly, even though this value is not one of the genres defined in the ID3 specification.

=item

B<items>-E<gt>B<file_attributes>-E<gt>B<album>

Podcast album title.  Corresponds to ID3 tag 'album'.  Not used in creating rss feed but included as a convenience feature.

=item

B<items>-E<gt>B<file_attributes>-E<gt>B<year>

Podcast year of publication.  Corresponds to ID3 tag 'year'.  Not used in creating rss feed but included as a convenience feature.

=item

B<items>-E<gt>B<file_attributes>-E<gt>B<increment>

Those values to incremented by one between edits.  Is useful only with numeric values.  It has no effect on non-numeric values.  An empty/undefined value is *not* incremented to one.  Most commonly used with series, episode, disc, part, and track.

=item

B<items>-E<gt>B<file_attributes>-E<gt>B<sequence>

As described for attributes-E<gt>sequence.

=item

B<items>-E<gt>B<file_attributes>-E<gt>B<exclude>

As described for attributes-E<gt>exclude.

=back

=item

B<items>-E<gt>B<other_attributes>

Other attributes for channel items, i.e., podcast files, that are not stored as attributes of the file itself.  This is currently only publication date (pubdate).  The data item consists of a hash of podcast filenames.  Each filename key points to another hash, currently containing one key: pubdate.

=back

=item

B<flags>

Various flags that are set by user options or internal script events.  Each has a boolean value.

=over

=item

B<flags>-E<gt>B<all_podcasts>

Whether to process all podcast files (true) or only new podcast files (false, default).

=item

B<flags>-E<gt>B<ignore_tag_content>

When setting podcast item attributes the default behaviour is to present the user with the previously used values for each attribute, i.e., the 'template' values.  For some attributes -- title, performer, author, description, album and year -- the corresponding audio file tag/frame contents are also presented if available.  If this flag is set to true the tag/frame contents are not presented to the user.

=back

=back

=head3 Constructors

There is a single method signature that does not accept any arguments:

	my $ojb = new DnChannel;  OR  my $ojb = DnChannel->new();

User entered data is stored by the script between invocations.  Some data is stored in podcast file mp3 tags.  The remaining user-entered information is stored in a persistent file called '@stored_state@'.  While this file is in human readable xml, edit it manually with greate care and at your own risk.  It is far safer to let the script manipulate it.  If the file is deleted or renamed the script will require the data to be re-entered.

The constructor will look in the current directory for '@stored_state@'.  If found it will take the file's stored object and use it to populate this object.

If no stored data file is found in the current directory the constructor initialises the object with default data loaded from /usr/share/@pkg@/@initial_state@.

=cut

	bless ( $self , $class );
	return $self;
}

=head3 Setters

There are no setters for attributes as they are set by other methods that act generically upon attribute hash structures.

	$c->set_all_podcasts( '<boolean>' );
	$c->ignore_tag_content( '<boolean>' );

=cut

sub set_all_podcasts { $_[0]->{'flags'}->{'all_podcasts'} = $_[1]; }
sub set_ignore_tag_content { $_[0]->{'flags'}->{'ignore_tag_content'} = $_[1]; }

=head3 Getters

There are no getters for individual item attributes.

	$c->attributes();  # hash_ref
	$c->base_url();
	$c->title();
	$c->author();
	$c->summary();
	$c->image();
	$c->pubdate_method();
	$c->item_attributes();  # hash_ref
	$c->item_file_attributes();  # hash_ref
	$c->item_other_attributes();  # hash_ref
	$c->all_podcasts();
	$c->ignore_tag_content();

=cut

sub attributes      { $_[0]->{'attributes'};                                }
sub base_url        { $_[0]->{'attributes'}->{'base_url'}->{'value'};       }
sub title           { $_[0]->{'attributes'}->{'title'}->{'value'};          }
sub author          { $_[0]->{'attributes'}->{'author'}->{'value'};         }
sub summary         { $_[0]->{'attributes'}->{'summary'}->{'value'};        }
sub image           { $_[0]->{'attributes'}->{'image'}->{'value'};          }
sub pubdate_method  { $_[0]->{'attributes'}->{'pubdate_method'}->{'value'}; }
sub item_attributes { $_[0]->{'items'};                                     }
sub item_file_attributes {
	$_[0]->item_attributes()->{'file_attributes'};
}
sub item_other_attributes {
	$_[0]->item_attributes()->{'other_attributes'};
}
sub all_podcasts    { $_[0]->{'flags'}->{'all_podcasts'};                   }
sub ignore_tag_content { $_[0]->{'flags'}->{'ignore_tag_content'};          }

=head3 Other

=head4 set_channel_attributes()

Set channel attributes.

Parameters: [ 0 = class ].

Return type: N/A.

=cut

sub set_channel_attributes {
	my ( $self ) = ( shift );
	my $preamble = [
		"You are editing attributes for an rss channel" ,
		"=============================================\n" ,
	];
	$self->edit_attribute_set( $self->attributes() , $preamble )
		or die "Aborting at user request\n";
	$dump->perl2xml( $self , STORE_state )
		or die "Failed to save object state\n";
}

=head4 set_item_attributes()

Edit/create item attributes.  Each item refers to an audio file.  Some of the item attributes attributes are stored as audio file tags.  Others are stored in this object.

Parameters: [ 0 = class ].

Return type: N/A.

=cut

sub set_item_attributes {
	my ( $self , @files ) = ( shift );
	my $base_url = $self->base_url();
	my $file_attrs = $self->item_file_attributes();
	my $other_attrs = $self->item_other_attributes();
	my $pubdate_method = $self->pubdate_method();
	my @files_done = keys %{ $other_attrs };
	# get list of audio files to process
	foreach my $file ( glob "*" ) {
		next if not $self->audio_mime_type( $file );
		if ( $self->all_podcasts() ) {  # doing all audio files
			push @files , $file;
		} else {  # do only new audio files
			my $file_grep = $file;
			$file_grep =~ s/\+/\\+/;  # escape quantifier
			push @files , $file unless grep /^$file_grep$/ , @files_done;
		}
	}
	print "There are no new files to process\n" if not @files;
	# process audio files
	foreach my $file ( @files ) {
		my $item = DnItem->new(
			$file ,
			$base_url ,
			$file_attrs ,
			$pubdate_method ,
			$other_attrs ,
			$self->ignore_tag_content() ,
		);
		$item->set_attributes() or die "Aborting at user request\n";
		# save after each item completed so work not lost if abort on an item
		$dump->perl2xml( $self , STORE_state )
			or die "Failed to save object state\n";
	}
}

=head4 iso_to_rfc2822()

Converts iso date to RFC 2822 format.

Uses module Email::Date::Format, function 'email_date'.
Uses module Time::ParseDate, function 'parsedate'.

Parameters: [ 0 = class ] , 1 = iso date.

Return type: Scalar (string date).

=cut

sub iso_to_rfc2822 { email_date( parsedate( $_[1] ) ); }

=head4 now_rfc2822()

Gets the current datetime in RFC 2822 format.

Uses module Email::Date::Format, function 'email_date'.

Parameters: [ 0 = class ].

Return type: Boolean.

=cut

sub now_rfc2822 { email_date; }

=head4 write_output()

Write xml rss and opml files.  File names are 'rss-feed.xml' 'rss-feed.opml'.

Then dumps object structure to file for next invocation.

Uses modules XML::RSS and XML::OPML.

Parameters: [ 0 = class ].

Return type: Nil.

=cut

sub write_output {
	my ( $self , @files ) = ( shift );
	my $base_url = $self->base_url();
	my $file_attrs = $self->item_file_attributes();
	my $other_attrs = $self->item_other_attributes();
	my $pubdate_method = $self->pubdate_method();
	my $rss = XML::RSS->new( 'version' => '2.0' );
	my $opml = new XML::OPML( 'version' => '1.1' );
	my $attrs = $self->attributes();
	for ( glob "*" ) {
		push @files , $_ if $self->audio_mime_type( $_ );
	}
	# rss file
	$rss->channel(
		title       => $self->title() ,
		link        => $self->base_url() ,
		description => $self->summary() ,
	);
	$rss->image(
		title => $self->title() ,
		url   => sprintf( "%s/%s" , $self->base_url() , $self->image() ) ,
		link  => $self->base_url() ,
	);
	foreach my $file ( @files ) {
		my $item = DnItem->new(
			$file ,
			$base_url ,
			$file_attrs ,
			$pubdate_method ,
			$other_attrs ,
		);
		$rss->add_item(
			title       => $item->title() ,
			guid        => $item->url() ,
			enclosure   => {
				url    => $item->url() ,
				length => $item->length() ,
				type   => $item->mime_type() ,
			},
			description => $item->description() ,
			pubDate     => $self->iso_to_rfc2822( $item->pubdate() ) ,
		);
	}
	$rss->save( RSS_xml );
	printf "Wrote rss feed file '%s'\n" , RSS_xml;
	# opml file
	$opml->head(
		title => encode_entities( $self->title() ) ,
		dateModified => $self->now_rfc2822() ,
	);
	$opml->add_outline(
		text   => encode_entities( $self->summary() ) ,
		title  => encode_entities( $self->title() ) ,
		type   => 'rss',
		xmlUrl => sprintf( "%s/%s" , $self->base_url() , RSS_xml ) ,
	);
	$opml->save( RSS_opml );
	printf "Wrote rss feed exchange file '%s'\n" , RSS_opml;
}

=head1 PACKAGE: main

The main program.

=cut

package main;

use constant TRUE => 1;
use constant FALSE => 0;

=head2 Dependencies

The following perl modules are required:

=head3 Getopt::Declare

Used for parameter processing.

Debian: provided by package 'libgetopt-declare-perl'.

=cut

use Getopt::Declare;

our $VERSION = "0.1";

my $args = new Getopt::Declare (<<'EOPARAM');
DESCRIPTION

Generates an rss feed file and corresponding opml file for
podcasts.  All audio files for the podcast must be in the
current directory.

Running this script enables the user to specify channel
attributes: base url, title, author, summary and image.
The following attributes are stored for each channel item,
i.e., podcast audio file: file name, title, performer,
author, description, genre and publication date.  The file
name and publication date items attributes are stored,
along with channel attributes, in memory and then in a
local perl storage file.  Item attributes title, performer,
author, description and genre are stored in audio file
tags and frames.  As a convenience feature users are able
to change audio file album, track and year tags during the
process.

At this time only mp3 audio files and ID3 tags are
supported.

This script supports only one channel per rss feed and
requires all files for a given feed to be in the same
directory.  This script must be run from inside that
directory.

To use this script for the first time simply ensure the
podcast feed audio files are in a single directory and run
this script in that directory.

USAGE

	dn-podcasts-rss
	dn-podcasts-rss -a
	dn-podcasts-rss -i

OPTIONS

	-a	process all podcast files
		\[default = process new files only]
	-i	ignore existing tag/frame content
		\[default = present existing content]
EOPARAM

my $rss = DnRss->new();

=head2 Description

First handles parameters.

=cut

$rss->set_all_podcasts( FALSE );  # default value
$rss->set_all_podcasts( TRUE )  if $args->{'-a'};
$rss->set_ignore_tag_content( FALSE );  # default value
$rss->set_ignore_tag_content( TRUE )  if $args->{'-i'};

=pod

Set channel attributes.

=cut

$rss->set_channel_attributes();

=pod

Process podcasts.

=cut

$rss->set_item_attributes();

=pod

Generate output files.

=cut

$rss->write_output();

=head1 AUTHOR

David Nebauer, david E<lt>atE<gt> nebauer E<lt>dotE<gt> org
