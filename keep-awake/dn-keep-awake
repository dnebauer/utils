#!/usr/bin/perl

# commands are defined in:
# package Dn::KeepAwake, method _build_commands

use Moo;    #                                                          {{{1
use strictures 2;
use namespace::clean;
use 5.014_002;
use version; our $VERSION = qv('0.1');

# package Dn::KeepAwake::Base                                          {{{1
{

    package Dn::KeepAwake::Base;

    use Moo;
    use strictures 2;
    use namespace::clean;
    use Function::Parameters;
    use Carp qw(confess);
    use Readonly;
    use Types::Standard qw(Str);
    use Dn::Common;
    my $cp = Dn::Common->new();

    Readonly my $TRUE  => 1;
    Readonly my $FALSE => 0;

    # Attributes
    has 'icon' => (
        is            => 'ro',
        isa           => Types::Standard::Str,
        required      => $TRUE,
        default       => '@icons_dir@/dn-keep-awake.xpm',
        documentation => 'Application icon',
    );

    has 'title' => (
        is            => 'ro',
        isa           => Types::Standard::Str,
        required      => $TRUE,
        default       => 'Keep Awake',
        documentation => 'Dialog title',
    );

    method notify ($msg, $type = 'info') {
        if ( not $msg ) { confess 'No message provided'; }
        $cp->notify_sys( $msg, title => $self->title, icon => $self->icon );
        my $script = $cp->scriptname();
        if ( $type eq 'error' ) {
            warn "$msg\n";
        }
        else {
            say "$script: $msg";
        }
    }
}

# package Dn::KeepAwake::Command                                       {{{1
{

    package Dn::KeepAwake::Command;

    use Moo;    #                                                      {{{2
    use namespace::clean;
    use Function::Parameters;
    use English qw(-no_match_vars);
    use Carp qw(confess);
    use Readonly;
    use Types::Standard qw(Bool RegexpRef Str);
    use Dn::Common;
    my $cp = Dn::Common->new();
    my $b  = Dn::KeepAwake::Base->new();

    Readonly my $TRUE  => 1;
    Readonly my $FALSE => 0;    #                                      }}}2

    # Attributes

    # name                                                             {{{2
    has 'name' => (
        is            => 'rw',
        isa           => Types::Standard::Str,
        accessor      => '_name',
        required      => $TRUE,
        documentation => 'Human readable name of command',
    );

    # cmd                                                              {{{2
    has 'cmd' => (
        is            => 'rw',
        isa           => Types::Standard::Str,
        accessor      => '_cmd',
        required      => $TRUE,
        documentation => 'Execution command string',
    );

    # background                                                       {{{2
    has 'background' => (
        is            => 'rw',
        isa           => Types::Standard::Bool,
        accessor      => '_background',
        required      => $TRUE,
        documentation => 'Whether command executes in the background',
    );

    # psgrep                                                           {{{2
    has 'psgrep' => (
        is            => 'rw',
        isa           => Types::Standard::RegexpRef,
        accessor      => '_psgrep',
        required      => $TRUE,
        documentation => 'String to match command is psgrep output',
    );    #                                                            }}}2

    # Methods

    # display()                                                        {{{2
    #
    # does:   provide human-readable report of command content
    # params: nil
    # prints: nil
    # return: list (display lines)
    method display () {
        my @input;
        push @input, 'Name:       ' . $self->_name;
        push @input, 'Command:    ' . $self->_cmd;
        push @input, 'Ps grep:    ' . $self->_psgrep;
        push @input,
            'Background: ' . ( ( $self->_background ) ? 'Yes' : 'No' );
        my @output = $cp->do_wrap(
            [@input],
            indent => 4,
            hang   => 16,
            break  => [ q{ }, q{/}, q{-} ],
        );
        return @output;
    }

    # run()                                                            {{{2
    #
    # does:   run command
    # params: nil
    # prints: nil
    # return: n/a
    method run () {
        my $name   = $self->_name;
        my $exec   = $self->_cmd;
        my $psgrep = $self->_psgrep;
        my $bkgrnd = $self->_background;
        if ( $cp->process_running($psgrep) ) {
            $b->notify("$name is already running");
            return;
        }

        # launch app
        my $pid = fork;
        if ( not( defined $pid ) ) {

            # fork failed
            confess "could not fork: $ERRNO";
        }
        if ( $pid == 0 ) {

            # child -- $pid is null
            #   cannot call '_notify' method from child process
            #   as doing so causes the process to hang silently
            if ($bkgrnd) {

                # backgrounded process -- rely on process
                # monitoring to detect when app exits
                exec "$exec" or confess "cannot execute '$exec': $ERRNO";
            }
            else {
                # foregrounded process -- system call does not
                # return till app exits

                if ( not $cp->suspend_screensaver( $b->title ) ) { return; }

                my ( $success, $err ) = $cp->run_command( [$exec] );
                if ($success) {
                    $b->notify("$name has exited");
                }
                else {
                    $b->notify( "$name exited unsuccessfully",   'error' );
                    $b->notify( "$err",                          'error' );
                    $b->notify( 'See console for full feedback', 'error' );
                }

                $cp->restore_screensaver( $b->title );

                exit;
            }
        }

        # monitor app if running in background
        # - monitor process name ('psgrep') rather than process id because
        #   a child process can remain alive, even after it is finished,
        #   as a "defunct" process that is, ironically, waiting for its
        #   parent to exit; while the pid remains active, the process name
        #   changes to indicate it is defunct and no longer matches the
        #   psgrep
        if ($bkgrnd) {

            if ( not $cp->suspend_screensaver( $b->title ) ) { return; }

            while ($TRUE) {
                sleep 2;
                if ( not $cp->process_running($psgrep) ) {
                    $b->notify( $name . ' has exited' );
                    last;
                }
            }

            $cp->restore_screensaver( $b->title );
        }
    }    #                                                             }}}2
}    #                                                                 }}}1

{

    package Dn::KeepAwake;

    use Moo;    #                                                      {{{1
    use namespace::clean;
    use MooX::HandlesVia;
    use MooX::Options;
    use Dn::Common;
    use Function::Parameters;
    use English qw(-no_match_vars);
    use List::Util qw(uniq);
    use Readonly;
    use Types::Standard qw(Bool HashRef InstanceOf Str);
    my $cp = Dn::Common->new();
    my $b  = Dn::KeepAwake::Base->new();

    Readonly my $TRUE          => 1;
    Readonly my $FALSE         => 0;
    Readonly my $manual_cmd    => '@libexec_dir@/@pkg@/dn-keep-awake-manual';
    Readonly my $manual_psgrep => qr(@libexec_dir@/@pkg@/dn-keep-awake-manual);

    #                                                                  }}}1

    # Options

    # list (-l)                                                       {{{1
    option 'list' => (
        is            => 'rw',
        required      => $FALSE,
        default       => $FALSE,
        reader        => '_list',
        short         => 'l',
        documentation => 'List commands (overrides other options)',
    );    #                                                           }}}1

    # Attributes

    # _keyword                                                        {{{1
    has '_keyword' => (
        is  => 'lazy',
        isa => Types::Standard::Str,
        doc => 'Keyword of command to execute',
    );

    method _build__keyword () {

        # no duplicates allowed
        my @args = List::Util::uniq @ARGV;
        if ( scalar @ARGV > scalar @args ) {
            die "Duplicate keywords not allowed\n";
        }

        # must have one keyword only
        die "No keyword provided\n" if not @args;
        die "Too many keywords (need one only)\n" if scalar @args > 1;

        # keyword must be valid
        my $keyword = $args[0];
        die "Invalid keyword '$keyword'\n" if not $self->_get_cmd($keyword);

        return $keyword;
    }

    # _commands_list                                                  {{{1
    has '_commands_list' => (
        is  => 'ro',
        isa => Types::Standard::HashRef [
            Types::Standard::InstanceOf ['Dn::KeepAwake::Command']
        ],
        handles_via => 'Hash',
        handles     => {
            _get_cmd      => 'get',
            _cmd_keywords => 'keys',
        },
        builder => '_build_commands',
    );

    method _build_commands () {
        return {
            bleach => Dn::KeepAwake::Command->new(
                name       => 'Bleach',
                cmd        => 'google-chrome www.crunchyroll.com/bleach',
                background => $FALSE,
                psgrep =>
                    qr(opt/google/chrome/chrome www[.]crunchyroll[.]com/bleach),
            ),
            iview => Dn::KeepAwake::Command->new(
                name       => 'iView',
                cmd        => 'google-chrome iview.abc.net.au/your/watchlist',
                background => $FALSE,
                psgrep =>
                    qr(opt/google/chrome/chrome iview[.]abc[.]net[.]au/your/watchlist),
            ),
            manual => Dn::KeepAwake::Command->new(
                name       => 'Manual',
                cmd        => $manual_cmd,
                background => $FALSE,
                psgrep     => $manual_psgrep,
            ),
            netflix => Dn::KeepAwake::Command->new(
                name       => 'Netflix',
                cmd        => 'google-chrome www.netflix.com',
                background => $FALSE,
                psgrep => qr(opt/google/chrome/chrome www[.]netflix[.]com),
            ),
            stan => Dn::KeepAwake::Command->new(
                name       => 'Stan',
                cmd        => 'google-chrome www.stan.com.au',
                background => $FALSE,
                psgrep => qr(opt/google/chrome/chrome www[.]stan[.]com[.]au),
            ),
        };
    }    #                                                             }}}1

    # Methods

    #   main()                                                         {{{1
    #
    #   does:   main method
    #   params: nil
    #   prints: feedback
    #   return: result
    method main () {

        # list commands takes precedence
        if ( $self->_list ) {
            $self->_display_commands;
            return;
        }

        # run command
        my $keyword = $self->_keyword;
        my $cmd     = $self->_get_cmd($keyword);
        $cmd->run;
    }

    # _display_commands()                                              {{{1
    #
    # does:   generate console output of command
    # params: nil
    # prints: nil
    # return: list (output lines)
    method _display_commands () {
        my @report;
        foreach my $keyword ( sort $self->_cmd_keywords ) {
            my $cmd = $self->_get_cmd($keyword);
            push @report, $keyword;
            push @report, $cmd->display;
            push @report, q{ };
        }
        pop @report;              # remove last q{ }
        $cp->pager( [@report], 'more' );
        return;
    }    #                                                             }}}1

}

my $p = Dn::KeepAwake->new_with_options->main;

1;

# POD                                                                  {{{1

__END__

=head1 NAME

dn-keep-awake - suppresses KDE screensaver while running a command

=head1 USAGE

B<dn-keep-awake> keyword

B<dn-keep-awake> I<-l>

B<dn-keep-awake -h>

=head1 ARGUMENTS

=over

=item B<keyword>

Command keyword. Required.

=back

=head1 OPTIONS

=over

=item B<-l>  B<--list>

List commands. Overrides any command keyword provided. Optional.

=item B<-h>

Display help and exit.

=back

=head1 DESCRIPTION

Suspends the KDE screensaver while a command is run. The command to run is
determined by the keyword provided.

All commands are defined internally. To see a list of available commands and
their keywords use the C<-l> option.

Note that one of the keywords, C<manual>, simply displays a message box that
remains until manually dismissed. The KDE screensaver is suspended while the
message box displays.

=head1 DEPENDENCIES

=head2 Perl modules

Carp, Dn::Common, English, Function::Parameters, List::Util, Moo,
MooX::HandlesVia, MooX::Options, namespace::clean, Readonly, strictures,
Types::Standard, version.

=head2 Executables

google-chrome.

=head1 CONFIGURATION AND ENVIRONMENT

Only suppresses KDE screensaver so any other screensavers that are active will
still activate.

=head1 BUGS AND LIMITATIONS

Please report any bugs to the author.

=head1 AUTHOR

David Nebauer E<lt>david@nebauer.comE<gt>

=head1 LICENSE AND COPYRIGHT

Copyright (c) 2015 David Nebauer E<lt>davidnebauer@hotkey.net.auE<gt>

This script is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

=cut
# vim:fdm=marker
