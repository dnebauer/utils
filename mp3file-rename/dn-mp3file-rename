#!/usr/bin/perl

use Moo;                 # {{{1
use strictures 2;
use 5.006;
use 5.036_001;
use version; our $VERSION = qv('0.1');
use namespace::clean;    # }}}1

# package Dn::MP3Rename::Role    {{{1
# - base class
{

  package Dn::MP3Rename::Role;

  use Moo::Role;    # {{{2
  use strictures 2;
  use namespace::clean;
  use charnames qw(:full);
  use Const::Fast;
  use Text::Unidecode;

  const my $TRUE  => 1;
  const my $FALSE => 0;    # }}}2

  # methods

  # _make_ascii($string)    {{{2
  #
  # does:   convert to pure ascii, i.e., decimal 0-127 and hex 00-7F
  # params: $string - scalar string to encode [required]
  # prints: feedback
  # return: scalar string, dies on failure
  sub _make_ascii ($self, $string)
  {    ## no critic (RequireInterpolationOfMetachars)
    my $ascii = Text::Unidecode::unidecode($string);
    return $ascii;
  }

  # _simplify($name)    {{{2
  #
  # does:   simplify name by performing these steps
  #         - convert to lower case
  #         - remove unnecessary characters: "',()[]
  #         - convert spaces to dashes
  #         - convert multiple dashes to single dashes
  #         - remove leading and trailing dashes (originally spaces)
  #         - remove insignificant prefixes 'a', 'an' and 'the'
  #         - replace '&' with 'and'
  # params: $name - name to be simplifed [scalar string, required]
  # prints: feedback
  # return: scalar string, dies on failure
  sub _simplify ($self, $name)
  {    ## no critic (RequireInterpolationOfMetachars)

    # - ignore three perlcritic 'string *may* require interpolation'
    #   warnings triggered by use of this variable
    # - for an unknown reason using '\N{DIVISION SLASH}\N{REVERSE SOLIDUS}'
    #   instead of '\\\/' does not work in practice on all track titles
    # - is safe to convert dots to dashes in this script because this method
    #   is only ever carried out on parts of a file basename, and will never
    #   interfere with dots preceding file extensions
    ## no critic (RequireInterpolationOfMetachars)
    my $extraneous_chars =
          q{["'`,;:?!\\\/}
        . '\N{LEFT PARENTHESIS}\N{RIGHT PARENTHESIS}'
        . '\N{LEFT SQUARE BRACKET}\N{RIGHT SQUARE BRACKET}'
        . '\N{LEFT CURLY BRACKET}\N{RIGHT CURLY BRACKET}]';
    ## use critic
    my $string = lc $name;                          # lower case
    $string =~ s{$extraneous_chars}{}gxsm;          # remove extra chars
    $string =~ s/ /-/gsm;                           # spaces to dashes
    $string =~ s/[.]/-/gxsm;                        # dots to dashes
    $string =~ s/-+/-/gxsm;                         # collapse dashes
    $string =~ s/\A-+//xsm;                         #\ remove dashes from
    $string =~ s/-+\Z//xsm;                         #/ both ends
    $string =~ s/\A^(a-|an-|the-)?(.*)\Z/$2/xsm;    # remove prefixes
    $string =~ s/&/and/gxsm;                        # expand '&' to 'and'

    # - special cases
    $string =~ s/[.]-/-/gxsm;                       # dot-dash to dash

    return $string;
  }    # }}}2

}

# package Dn::MP3Rename::AudioFile    {{{1
# - represents the raw google takeout audio mp3 file
{

  package Dn::MP3Rename::AudioFile;    ## no critic (ProhibitMultiplePackages)

  use Moo;                             # {{{2
  use strictures 2;
  use namespace::clean;
  use autodie qw(open close);
  use Carp    qw(croak);
  use Const::Fast;
  use English qw(-no_match_vars);
  use MP3::Info;
  use Types::Path::Tiny qw(AbsFile);
  use Types::Standard;

  with qw(Role::Utils::Dn);

  const my $TRUE  => 1;
  const my $FALSE => 0;    # }}}2

  # attributes

  # filepath    {{{2
  has 'filepath' => (
    is       => 'ro',
    isa      => AbsFile,
    required => $TRUE,
    coerce   => AbsFile->coercion,
    doc      => 'File path of audio track',
  );

  # tags    {{{2
  has 'tags' => (
    is      => 'ro',
    isa     => Types::Standard::InstanceOf ['MP3::Info'],
    lazy    => $TRUE,
    default => sub {
      my $self     = shift;
      my $filename = $self->filepath->canonpath;
      return MP3::Info->new($filename);
    },
    doc => 'Mp3 tags object',
  );

  # title    {{{2
  has 'title' => (
    is      => 'ro',
    isa     => Types::Standard::Str,
    lazy    => $TRUE,
    default => sub {
      my $self  = shift;
      my $title = $self->tags->title;
      my $ascii = $self->_make_ascii($title);
      return $self->_simplify($ascii);
    },
    doc => 'Track title',
  );

  # artist    {{{2
  has 'artist' => (
    is      => 'ro',
    isa     => Types::Standard::Str,
    lazy    => $TRUE,
    default => sub {
      my $self   = shift;
      my $artist = $self->tags->artist;
      my $ascii  = $self->_make_ascii($artist);
      return $self->_simplify($ascii);
    },
    doc => 'Track artist',
  );

  # album    {{{2
  has 'album' => (
    is      => 'ro',
    isa     => Types::Standard::Str,
    lazy    => $TRUE,
    default => sub {
      my $self  = shift;
      my $album = $self->tags->album;
      my $ascii = $self->_make_ascii($album);
      return $self->_simplify($ascii);
    },
    doc => 'Track album',
  );

  # year    {{{2
  has 'year' => (
    is      => 'ro',
    isa     => Types::Standard::Str,
    lazy    => $TRUE,
    default => sub {
      my $self = shift;
      my $year = $self->tags->year;
      return $self->_make_ascii($year);
    },
    doc => 'Track year',
  );

  # number    {{{2
  has 'number' => (
    is      => 'ro',
    isa     => Types::Standard::Int,
    lazy    => $TRUE,
    default => sub {
      my $self       = shift;
      my $tag_number = $self->_make_ascii($self->tags->tracknum);
      my $filename   = $self->filepath->canonpath;

      # assume format is either 'NUM' or 'NUM/TOTAL'
      my $number;
      if ($tag_number =~ /\A(\d+)/xsm) { $number = $1; }
      else { croak "No valid track number in file '$filename'"; }

      return $number;
    },
    doc => 'Track number',
  );

  # disk    {{{2
  has 'disk' => (
    is      => 'ro',
    isa     => Types::Standard::Int,
    lazy    => $TRUE,
    default => sub {
      my $self     = shift;
      my $filename = $self->filepath->canonpath;

      # MP3::Info object does not have a direct method for disc number
      # must use a class function to derive tag hash
      my ($TAG_VERSION, $RAW_V2) = (undef, 2);
      my $tags = MP3::Info::get_mp3tag($filename, $TAG_VERSION, $RAW_V2);
      my $tag_disk;
      ## no critic (ProhibitDuplicateLiteral)
      if   (exists $tags->{'TPOS'}) { $tag_disk = $tags->{'TPOS'}; }
      else                          { $tag_disk = 1; }
      ## use critic

      # assume format is either 'NUM' or 'NUM/TOTAL'
      my $disk;
      if   ($tag_disk =~ /\A(\d+)/xsm) { $disk = $1; }
      else                             { $disk = 1; }

      return $disk;
    },
    doc => 'Disk number',
  );

  # methods

  # initialise()    {{{2
  #
  # does:   ensure all tags are extracted and all attributes are set
  #         - can be used to ensure all tags are extracted from a file at
  #           once (to avoid multiple disk operations)
  # params: nil
  # prints: feedback
  # return: n/a, dies on failure
  sub initialise ($self) {    ## no critic (RequireInterpolationOfMetachars)

    $self->title;
    $self->artist;
    $self->album;
    $self->year;
    $self->number;
    $self->disk;

    return;
  }

  # new_filename($format, $num_width, $disk_width)    {{{2
  #
  # does:   derive new filename using a format template with
  #         these possible placeholders:
  #         %t = title
  #         %a = artist
  #         %l = album
  #         %y = year
  #         %n = number
  #         %d = disk
  # params: $format     - format template [scalar string, required
  #         $num_width  - width of track number [scalar integer, required]
  #         $disl_width - width of disk number [scalar integer, required]
  # prints: feedback
  # return: n/a, die on failure
  sub new_filename ($self, $format, $num_width, $disk_width)
  {    ## no critic (RequireInterpolationOfMetachars, ProhibitManyArgs)

    # mp3 files commonly have no disk number
    my $disk_num = $self->disk;
    my $disk =
        ($disk_num and $disk_width)
        ? $self->pad($disk_num, $disk_width)
        : 1;
    my %placeholders = (
      t => $self->title,
      a => $self->artist,
      l => $self->album,
      y => $self->year,
      n => $self->pad($self->number, $num_width),
      d => $disk,
    );

    # start with format template
    my $basename = $format;

    # replace placeholders
    #while (my ($char, $value) = each %placeholders) {
    for my $char (keys %placeholders) {
      my $value       = $placeholders{$char};
      my $placeholder = q{%} . $char;
      $basename =~ s/$placeholder/$value/gxsm;
    }

    # add extension
    my $ext      = '.mp3';
    my $filename = $basename . $ext;

    return $filename;
  }    # }}}2

}    # }}}1

{

  package Dn::MP3Rename;    ## no critic (ProhibitMultiplePackages)

  use Moo;                  # {{{1
  use strictures 2;
  use namespace::clean -except => [ '_options_data', '_options_config' ];
  use autodie qw(open close);
  use Carp    qw(croak);
  use Const::Fast;
  use English       qw(-no_match_vars);
  use Log::Log4perl qw(get_logger);
  use MooX::HandlesVia;
  use MooX::Options protect_argv => 0;
  use Term::ProgressBar::Simple;
  use Types::Path::Tiny;
  use Types::Standard;

  with qw(
      Dn::MP3Rename::Role
      Role::Utils::Dn
  );

  const my $TRUE  => 1;
  const my $FALSE => 0;

  const my $MINUS_ONE => -1;    # }}}1

  # options

  # format  (-f)    {{{1
  option 'format' => (
    is       => 'ro',
    format   => 's',
    required => $TRUE,
    short    => 'f',
    doc      => 'Filename format template',
  );    # }}}1

  # attributes

  # _format    {{{1
  has '_format' => (
    is       => 'ro',
    isa      => Types::Standard::Str,
    lazy     => $TRUE,
    required => $TRUE,
    default  => sub {
      my $self => shift;
      my $format = $self->format;
      if (not $format) { croak 'Format is an empty string'; }
      return $format;
    },
    doc => 'Filename format template', ## no critic (ProhibitDuplicateLiteral)
  );

  # _number_width    {{{1
  has '_number_width' => (
    is       => 'rw',
    isa      => Types::Standard::Maybe [Types::Standard::Int],
    required => $TRUE,
    default  => sub {undef},
    doc      => 'Width of the largest track number',
  );

  # _disk_width    {{{1
  has '_disk_width' => (
    is       => 'rw',
    isa      => Types::Standard::Maybe [Types::Standard::Int],
    required => $TRUE,
    default  => sub {undef},
    doc      => 'Width of the largest disk number',
  );

  # _cwd    {{{1
  has '_cwd' => (
    is       => 'ro',
    isa      => Types::Standard::Str,
    required => $TRUE,
    default  => sub {Cwd::getcwd},
    doc      => 'Current working directory',
  );

  # _add_audio_file, _audio_files, _audio_file_count    {{{1
  has '_audio_file_list' => (
    is  => 'rw',
    isa => Types::Standard::ArrayRef [
      Types::Standard::InstanceOf ['Dn::MP3Rename::AudioFile'],
    ],
    required    => $TRUE,
    default     => sub { [] },
    handles_via => 'Array',
    handles     => {
      _add_audio_file   => 'push',
      _audio_files      => 'elements',
      _audio_file_count => 'count',
    },
    doc => 'Array of audio files',
  );

  # _set_filename, _filename, _has_filename, _filenames    {{{1
  has '_audio_filename_hash' => (
    is          => 'rw',
    isa         => Types::Standard::HashRef [Types::Standard::Str],
    required    => $TRUE,
    default     => sub { {} },
    handles_via => 'Hash',
    handles     => {
      _set_filename => 'set',       # $key => $value
      _filename     => 'get',       # $key
      _has_filename => 'exists',    # $key
      _filenames    => 'keys',
    },
    doc => 'Hash of audio file names: new => original',
  );    # }}}1

  # methods

  # main()    {{{1
  #
  # does:   main method
  # params: nil
  # prints: feedback
  # return: n/a, dies on failure
  sub main ($self) {    ## no critic (RequireInterpolationOfMetachars)

    $self->_start_logging;

    $self->_read_audio_files;

    $self->_set_number_width;    # pad width of track number

    $self->_set_disk_width;      # pad width of disk number

    $self->_set_new_filenames;

    if ($self->_confirm_renaming) { $self->_rename_files; }

    return;
  }

  # _abort()    {{{1
  #
  # does:   log error message and exit script
  # params: nil
  # prints: feedback
  # return: n/a, dies on failure
  sub _abort ($self, $msg) {    ## no critic (RequireInterpolationOfMetachars)
    my $logger = get_logger();
    $logger->logdie("$msg\n");
    return;
  }

  # _info()    {{{1
  #
  # does:   log informational message
  # params: nil
  # prints: feedback
  # return: n/a, dies on failure
  # note:   relies on Log::Log4perl being configured elsewhere
  sub _info ($self, $msg)
  {   ## no critic (RequireInterpolationOfMetachars, ProhibitDuplicateLiteral)
    my $logger    = get_logger();
    my $msg_ascii = $self->_make_ascii($msg);
    $logger->info($msg_ascii);
    return;
  }

  # _start_logging()    {{{1
  #
  # does:   initialise logger
  # params: nil
  # prints: feedback
  # return: n/a, dies on failure
  sub _start_logging ($self) {  ## no critic (RequireInterpolationOfMetachars)

    # initialise logger to screen    {{{2
    my $conf =
          "log4perl.logger = DEBUG, Screen\n"
        . "log4perl.appender.Screen = Log::Log4perl::Appender::Screen\n"
        . "log4perl.appender.Screen.layout = SimpleLayout\n" . "\n";
    Log::Log4perl->init_once(\$conf);

    return;
  }

  # _read_audio_files()    {{{1
  #
  # does:   builds internal list of audio files in current directory
  # params: nil
  # prints: feedback
  # return: n/a, dies on failure
  sub _read_audio_files ($self)
  {    ## no critic (RequireInterpolationOfMetachars)

    # get list of files in current directory
    my @files = glob '*.mp3';
    if (not scalar @files) { $self->_abort('No *.mp3 files found'); }
    my $count = @files;
    $self->_info("Found $count audio (mp3) files");
    $self->_info('Initial processing of audio files');
    my $progress = Term::ProgressBar::Simple->new($count);

    # cycle through files
    for my $file (@files) {

      # create audiofile object
      my $audiofile = Dn::MP3Rename::AudioFile->new(filepath => $file);
      $audiofile->initialise;

      # add audiofile object to internal array
      $self->_add_audio_file($audiofile);

      $progress++;
    }
    undef $progress;    # ensure final messages displayed

    return;
  }

  # _set_number_width()    {{{1
  #
  # does:   set width of highest track number
  #         - can obtain from either track count or track numbers
  # params: nil
  # prints: feedback
  # return: n/a, dies on failure
  sub _set_number_width ($self)
  {    ## no critic (RequireInterpolationOfMetachars)

    # get track numbers from audio files
    my @numbers = map { $_->number } $self->_audio_files;

    # get track count
    push @numbers, $self->_audio_file_count;

    # get maximum value from list
    my $max_num = List::Util::max @numbers;

    # set width of maximum number
    my $width = length $max_num;
    $self->_number_width($width);

    return;
  }

  # _set_disk_width()    {{{1
  #
  # does:   set width of highest disk number
  # params: nil
  # prints: feedback
  # return: n/a, dies on failure
  sub _set_disk_width ($self) { ## no critic (RequireInterpolationOfMetachars)

    # get disk numbers from audio files
    my @disks = map { $_->disk } $self->_audio_files;

    # get maximum value from list
    my $max_disk = List::Util::max @disks;

    # set width of maximum disk
    my $width = length $max_disk;
    if (not $width) { $width = 1; }
    $self->_disk_width($width);

    return;
  }

  # _set_new_filenames()    {{{1
  #
  # does:   create new file names and add to internal hash
  # params: nil
  # prints: feedback
  # return: n/a, dies on failure
  # note:   new names must all be unique
  sub _set_new_filenames ($self)
  {    ## no critic (RequireInterpolationOfMetachars)
    $self->_info('Create new filenames');
    my @args = ($self->_format, $self->_number_width, $self->_disk_width);
    for my $audio_file ($self->_audio_files) {

      # get old (existing) file name
      my $old_filepath = $audio_file->filepath->canonpath;
      my $old_filename = $self->file_name($old_filepath);

      # create new file name
      my $new_filename = $audio_file->new_filename(@args);
      if ($self->_has_filename($new_filename)) {
        my $previous_filename = $self->_filename($new_filename);
        my $msg               = 'These files both generate the new file name '
            . "$new_filename: $previous_filename, $old_filename";
        $self->_abort($msg);
      }
      $self->_set_filename($new_filename, $old_filename);
    }

    return;
  }

  # _confirm_renaming()    {{{1
  #
  # does:   display renaming details and get user confirmation to proceed
  # params: nil
  # prints: feedback
  # return: n/a, dies on failure
  sub _confirm_renaming ($self)
  {    ## no critic (RequireInterpolationOfMetachars)

    my @new_filenames = sort $self->_filenames;

    # get maximum widths of new and old/current filenames
    my $new_width = List::Util::max map {length} @new_filenames;
    my $old_width =
        List::Util::max map { length $self->_filename($_) } @new_filenames;

    # display details of renaming operation
    $self->_info('Proposed file renaming:');
    for my $new_filename (@new_filenames) {
      my $old_filename = $self->_filename($new_filename);
      my $msg          = q{  }
          . $self->pad($old_filename, $old_width, q{ }, 'right') . ' -> '
          . $new_filename;
      $self->_info($msg);
    }

    # get confirmation to proceed
    my $msg     = 'QUERY - Proceed with renaming?';
    my $proceed = $self->interact_confirm($msg);
    if (not $proceed) { $self->_info('Okay, aborting'); }

    return $proceed;
  }

  # _rename_files()    {{{1
  #
  # does:   rename audio files
  # params: nil
  # prints: feedback
  # return: n/a, dies on failure
  sub _rename_files ($self) {   ## no critic (RequireInterpolationOfMetachars)

    my @new_filenames = sort $self->_filenames;
    my $count         = @new_filenames;
    my $progress      = Term::ProgressBar::Simple->new($count);

    for my $new_filename (@new_filenames) {
      my $old_filename = $self->_filename($new_filename);
      $self->file_move($old_filename, $new_filename);
      $progress++;
    }
    undef $progress;    # ensure final messages displayed

    $self->_info('Files renamed');

    return;
  }    # }}}1

}

my $p = Dn::MP3Rename->new_with_options->main;

1;

# POD    {{{1
__END__

=encoding utf8

=head1 NAME

dn-mp3file-rename - rename mp3 files according to user formatting template

=head1 VERSION

This documentation refers to dn-mp3file-rename version 0.1.

=head1 USAGE

B<dn-mp3file-rename> B<-f> format

B<dn-mp3file-rename -h>

=head1 REQUIRED ARGUMENTS

There are no required arguments.

=head1 REQUIRED OPTIONS

=over

=item B<-f>  B<--format>

Formatting template used to create file base names. Is a string that can
contain the following placeholders: C<%t> (title), C<%a> (artist), C<%l>
(album), C<%y> (year), C<%n> (track number), and C<%d> (disk number). The
template needs to result in unique file base names for each track file. The
F<.mp3> extension does not need to be included in the format template.

Scalar string. Required.

=back

=head1 OPTIONS

=over

=item B<-h>

Display help and exit.

=back

=head1 DESCRIPTION

Renames all audio mp3 files in the current directory. The names given to the
files are determined by a format template provided by the user. This template
actually determines the base name of the new file; all files automatically
retain the F<.mp3> extension.

=head2 Placeholders in the format template

The format template can contain any of the following placeholders:

=over

=item

C<%t> = track title

=item

C<%a> = track artist

=item

C<%l> = album name

=item

C<%y> = track year

=item

C<%n> = track number

=item

C<%d> = disk number.

=back

All placeholder values are 'simplified':

=over

=item

converted to lower case

=item

spaces changed to dashes

=item

multiple dashes collapsed to single dashes

=item

leading and trailing dashes removed

=item

punctuations marks such as commas, semicolons, colons, apostrophes,
question marks and exclamation points removed

=item

words like 'a', 'an' and 'the' removed from the beginning.

=back

=head2 Numeric tags

Both "number" and "disk" are positive non-zero integers. Their raw tag values
may be a simple integer indicating track number, e.g., '6', or two integers
indicating track number and total number of tracks, e.g., '6/12'. A simple
algorithm is used to extract the track number: the initial sequence of digits
in the tag is extracted.

It is a fatal error if a valid track number cannot be extracted from a file's
tags. In contrast, if a valid disk number cannot be extracted it defaults to
'1'.

=head2 User confirmation

The proposed renaming operation is shown to the user, who must give
confirmation before files are renamed.

=head1 DIAGNOSTICS

=head2 No valid track number in file 'FILE'

The audio mp3 track number tag is empty or does not contain a valid track
number. A valid track number is either:

=over

=item a single positive non-zero integer, e.g., '6', or

=item two positive non-zero integers separated by a slash, e.g., '6/10'.

=back

=head2 Format is an empty string

An empty format string was provided.

=head2 No *.mp3 files found

The current directory contains no files with an F<.mp3> extension.

=head2 These files both generate the new file name FILE: FILE, FILE

The format template, when applied to two audio mp3 files, generates the same
new file name. This error can be artificially generated by using a format
template (C<-f>) with no placeholders.

=head1 DEPENDENCIES

=head2 Perl modules

autodie, Const::Fast, English, Log::Log4perl, Moo, MooX::HandlesVia,
MooX::Options, MP3::Info, namespace::clean, Path::Tiny, Role::Utils::Dn,
strictures, Term::ProgressBar::Simple, Text::Unidecode, Types::Path::Tiny,
Types::Standard, version.

=head1 CONFIGURATION

No configuration files are used.

=head1 INCOMPATIBILITIES

There are no known incompatibilities.

=head1 EXIT STATUS

There are no script-specific exit status values set. Any non-zero exit value is
the exit value of the operation whose failure caused the script to exit, or of
the C<die> command that caused a premature end to execution.

=head1 BUGS AND LIMITATIONS

Please report any bugs to the author.

=head1 AUTHOR

David Nebauer (david at nebauer dot org)

=head1 LICENSE AND COPYRIGHT

Copyright (c) 2020 David Nebauer (david at nebauer dot org)

This script is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.

=cut
# vim:foldmethod=marker:
