#!/bin/sh

# File: dn-mc-conf
# Author: David Nebauer
# Purpose: Generate local mc configuration files
# Created: 2012-06-17 Created


# VARIABLES

self="$( basename ${0} )"
usage="Usage:"
parameters=""
cron_script="/etc/cron.daily/@pkg@"
# - local mc configuration directory
mc_conf_dir_local="/home/USER/.config/mc"
# = extensions file
# - supplied by this package
ext_file_pkg="@pkgdata_dir@/mc.ext"
# - supplied by mc package
ext_file_global="@sysconf_dir@/mc/mc.ext"
# - to be created by cron job merging two previous extension files
ext_file_local="${mc_conf_dir_local}/mc.ext"
# = menu file
# - supplied by this package
menu_file_pkg="@pkgdata_dir@/menu"
# - supplied by mc package
menu_file_global="@sysconf_dir@/mc/mc.menu"
# - to be created by cron job merging two previous extension files
# - note breal in naming paradigm, i.e., not called 'mc.menu'
#   like global conf file
menu_file_local="${mc_conf_dir_local}/menu"


# PROCEDURES

# Show usage
#   params: nil
#   prints: nil
#   return: nil
displayUsage () {
cat << _USAGE
${self}: regenerate local mc configuration files

Midnight Commander (mc) is a file browser.  Much of its
power comes from its ability to configure how to open and
view different file types.  This configuration is done via
'extension files'.  These files contain entries based on
file extensions, file types and mime types.  When a file is
opened or viewed the extension file is searched for a
matching entry and the first match is used.

Determining which extension file to use is a little
unwieldy.  There is a global extension file
('${ext_file_global}') which is used by default.
If a local extension file ('${ext_file_local}')
is present then it is used instead of the global file, and
the global extension file is *not* used.  There is no way
to call the global extension file from the local one.  In
fact, there is *no* way to call both local and global
extension files.

The only way to maintain a local extension file without the
overhead of tracking changes in the package's global
extension file is to keep local changes in a 'changes' file
and periodically regenerate the local extension file by
concatenating the 'changes' file and the global extension
file as saving the result as the local extension file.

Midnight Commander also has a user-configurable menu system
controlled by 'menu files'. These configuration files
determine the options in the user menu (F2). As with
extension files, there is a global menu file
('${menu_file_global}') which is used by default.
A local menu file ('${menu_file_local}') will be used
if present and there is no way for it to call the global
menu file. As with extension files, local menu items are
kept in a local 'changes' and the local menu file is
periodically regenerated by concatenating the 'changes'
file and global menu file.

This package provides local 'changes' files for extensions
('${ext_file_pkg}') and menu items ('${menu_file_pkg}'),
and a daily cron script that regenerates local mc extension
and menu files. The cron script writes feedback to the
system log.

This script, ${self}, is a wrapper for the daily cron script
enabling it to be called directly.

${usage} ${self} ${parameters}
       ${self} -h
_USAGE
}
# Process command line
#   params: all command line parameters
#   prints: feedback
#   return: nil
processCommandLine () {
	# Read the command line options
	#   - if optstring starts with ':' then error reporting is suppressed
	#     leave ':' at start as '\?' and '\:' error capturing require it
	#   - if option is followed by ':' then it is expected to have an argument
	while getopts ":hx:" opt ; do  # **
		case ${opt} in
			'h' ) displayUsage && exit 0;;
			'x' ) var="${OPTARG}";;
			\?  ) echo -e "Error: Invalid flag '${OPTARG}' detected"
				  echo -e "Usage: ${self} ${parameters}"
				  echo -e "Try '${self} -h' for help"
				  echo -ne "\a"
				  exit 1;;
			\:  ) echo -e "Error: No argument supplied for flag '${OPTARG}'"
				  echo -e "Usage: ${self} ${parameters}"
				  echo -e "Try '${self} -h' for help"
				  echo -ne "\a"
				  exit 1;;
		esac
	done
	shift $(( ${OPTIND} - 1 ))
	args="${@}"  # reset arguments
	unset usage parameters
}


# MAIN

# Process command line
processCommandLine "${@}"
while [ "${*}" != "${args}" ] ; do shift ; done
unset args

# Pass control to cron script
${cron_script}
