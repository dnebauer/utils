#!/bin/sh

# File: dn-alsa-device
# Author: David Nebauer
# Purpose: Handle alsa device configuration files
# Created: 2010-12-28 Created


# VARIABLES

dn_self="$( basename ${0} )"
args="${@}"
global_conf="@pkgconf_dir@/${dn_self}rc"
usage="Usage:"
parameters=""
declare -a labels=()       # user-created device labels
declare -a names=()        # alsa-assigned device names
declare -a numbers=()      # device (card) numbers
declare -a descriptions=() # device descriptions
declare -a defaults=()     # whether device is system default
declare -a set_sounds=()   # whether to set device sound when made default
declare -a controls=()     # mixer controls to set volume level of
declare -a levels=()       # sound level settings for devices
label=       # user-created device label
name=        # alsa-assigned device name
number=      # device (card) number
description= # device description
default=     # whether device is system default
set_sound=   # whether to set device sound when made default
control=     # mixer control to set volume level of
level=       # sound level setting for device
conf_stub="asound.conf-dn."  # stub filename for user-created config file
sysconfdir="@sysconf_dir@"    # system configuration directory (/etc)
pkgconfdir="@pkgconf_dir@"      # package configuration dir (/etc/dn-alsa-device)
link_name="asound.conf"      # name of main alsa config file (symlink)
default_label=   # label of default device
title="Alsa Default Device"  # default title of notification dialogs
dn_app_icon="@pkgdata_dir@/sound.xpm"  # override dialog icons
dn_app_icon_all_dialogs='yes'          # override all dialogs
msg=
args=""


# PROCEDURES

# Show usage
#   params: nil
#   prints: nil
#   return: nil
displayUsage () {
cat << _USAGE
${dn_self}: change default alsa sound device

This script can only be run by the root user.

Once suitable configuration has been done, this script is
used to change the default alsa sound device.  For example,
changing from the computer speakers to a usb headset.

This script is designed to be called by udev rules which
detect when a usb sound device is plugged or unplugged.

The user must configure at least one system sound device,
and as many usb sound devices as desired.

To configure a single device three things must be done:
1. Add a line to this script's configuration file,
2. Create an alsa configuration file for it, and
3. Add two rules to a udev rules file.

These things are quite simple to do.  This script's manpage
explains how they are accomplished.

Because this script is designed to be called by udev, it
does not send output to the terminal.  Feedback is sent to
the system log (/var/log/messages).  The script tries to
send output to the screen in a dialog box but this will
work only if there is at least one user running an X
session.

${usage} ${dn_self} ${parameters}
       ${dn_self} -h

Options: label = user-designated label for sound device
_USAGE
}
# Process configuration files
#   params: 1 - global config filepath (optional)
#           2 - local config filepath (optional)
#   prints: nil
#   return: nil
processConfigFiles () {
	# set variables
	local conf= name= label= alsa_name= description= 
	local number= default= set_sound= control= level=
	local global_conf="$( normalisePath "${1}" )"
	# process config files
	if [ -r "${global_conf}" ] ; then
        # read variable order must match following variable assignment order
		while read name label alsa_name number description \
			       default set_sound control level ; do
			if [ -n "${name}" ] ; then
				# remove enclosing quotes if present
				# convert underscores to spaces for descriptions
				# convert default and set_sound to [0|1]
				label="$( stripEnclosingQuotes "${label}" )"
				alsa_name="$( stripEnclosingQuotes "${alsa_name}" )"
				number="$( stripEnclosingQuotes "${number}" )"
				description="$( stripEnclosingQuotes "${description}" )"
				description="$( underSpace "${description}" )"
				default="$( stripEnclosingQuotes "${default}" )"
				default="$( standardiseBoolean "${default}" )"
				set_sound="$( stripEnclosingQuotes "${set_sound}" )"
				set_sound="$( standardiseBoolean "${set_sound}" )"
				control="$( stripEnclosingQuotes "${control}" )"
				level="$( stripEnclosingQuotes "${level}" )"
				case ${name} in
				'device'  )
					# check whether duplicate label
					load=0
					elementInArray "${label}" "${labels[@]}" && load=1
					if flagTrue ${load} ; then  # load arrays
						index=${#labels[*]}
						labels[${index}]="${label}"
						names[${index}]="${alsa_name}"
						numbers[${index}]="${number}"
						descriptions[${index}]="${description}"
						defaults[${index}]="${default}"
						set_sounds[${index}]="${set_sound}"
						controls[${index}]="${control}"
						levels[${index}]="${level}"
					fi
					;;
				esac
			fi
		done < "${global_conf}"
	fi
}
# Process command line
#   params: all command line parameters
#   prints: feedback
#   return: nil
processCommandLine () {
	# Read the command line options
	#   - if optstring starts with ':' then error reporting is suppressed
	#     leave ':' at start as '\?' and '\:' error capturing require it
	#   - if option is followed by ':' then it is expected to have an argument
	while getopts ":h" opt ; do
		case ${opt} in
			'h' ) displayUsage && exit 0;;
			\?  ) echo -e "Error: Invalid flag '${OPTARG}' detected"
				  echo -e "Usage: ${dn_self} ${parameters}"
				  echo -e "Try '${dn_self} -h' for help"
				  echo -ne "\a"
				  exit 1;;
			\:  ) echo -e "Error: No argument supplied for flag '${OPTARG}'"
				  echo -e "Usage: ${dn_self} ${parameters}"
				  echo -e "Try '${dn_self} -h' for help"
				  echo -ne "\a"
				  exit 1;;
		esac
	done
	shift $(( ${OPTIND} - 1 ))
	args="${@}"  # reset arguments
	unset usage parameters
}
# Get label of default audio device
# [as set in the config file by the user]
#   params: nil
#   prints: label of default device
#   return: nil
defaultLabel () {
	# set and check variables
	local label="" i=
	# check each 
	for (( i=0 ; i<${#labels[*]} ; i++ )) ; do
		if flagTrue "${defaults[${i}]}" ; then
			label="${labels[${i}]}"
		fi
	done
	echo "${label}"
}
# Get device parameter corresponding to label
#   params: 1 - label
#           2 - parameter ('name'|'default'|etc.)
#   prints: parameter
#   return: boolean (0=success|1=failure)
deviceParam () {
	# set and check variables
	local label="${1}" param="${2}" i= retval=
	local valid_params='label name description number default set_sound control level'
	# get and report parameter
	for (( i=0 ; i<${#labels[*]} ; i++ )) ; do
		if [ "${labels[${i}]}" = "${label}" ] ; then
			case ${param} in
			'name'        ) retval="${names[${i}]}";;
			'number'      ) retval="${numbers[${i}]}";;
			'description' ) retval="${descriptions[${i}]}";;
			'set_sound'   ) retval="${set_sounds[${i}]}";;
			'control'     ) retval="${controls[${i}]}";;
			'level'       ) retval="${levels[${i}]}";;
			esac
		fi
	done
	echo "${retval}"
}
# Load all device parameters into variables
#   params: 1 - label
#   prints: nil
#   return: boolean (0=success|1=failure)
loadDeviceParams () {
	label="${1}"
	name="$( deviceParam "${label}" 'name' )"
	number="$( deviceParam "${label}" 'number' )"
	description="$( deviceParam "${label}" 'description' )"
	set_sound="$( deviceParam "${label}" 'set_sound' )"
	control="$( deviceParam "${label}" 'control' )"
	level="$( deviceParam "${label}" 'level' )"
}
# Normalise path (make absolute)
#   params: 1 - path
#   prints: normalised path
#   return: nil
normalisePath () {
	local path="${1}" previous_length=0 length=1 sed=
	# deal with shorthand for home directory
	path="$( echo ${path} | sed -e "s?^~?${HOME}?" )"
	# deal with relative path
	[ $( echo ${path} | grep -c -- "^/" ) -eq 0 ] && path="$( pwd )/${path}"
	# expand to full path if starts with a relative directory
	[ $( echo ${path} | grep -c -- "^\.\(\.\)\?\/" ) -eq 1 ] \
		&& path="$( pwd )/${path}"
	# remove the self directory: './'
	# must loop because may miss ('./') when two joined together ('././')
	while [ ${length} -ne ${previous_length} ] ; do
		path="$( echo "${path}" | sed -e 's=\/\.\/=\/=g' )"
		previous_length="${length}"
		length="$( echo "${path}" | wc --bytes )"
	done
	previous_length=0 length=1
	# remove relative parent directory ('../') and actual parent directory
	# use ACK (octal 006) instead of '../' to avoid problems with '.'
	path="$( echo "${path}" | tr -d '\006' | sed -e 's=\.\.\/=\o006=g' )"
	while [ ${length} -ne ${previous_length} ] ; do
		sed="\(\/[[:alnum:]._/-]\+\/\)"  # before parent directory
		sed="${sed}[[:alnum:]._-]\+\/\o006"  # parent dir and relative dir
		sed="${sed}\([[:alnum:][:cntrl:]._/-]\+\)$"  # after parent directory
		path="$( echo "${path}" | sed -e "s,${sed},\1\2," )"
		previous_length="${length}"
		length="$( echo "${path}" | wc --bytes )"
	done
	# remove terminal slash from directory
	path="$( removeEndSlash "${path}" )"
	# return result
	echo "${path}"
}
# Remove terminal slash ('/') from string
#   params: 1 - string
#   prints: edited string
#   return: nil
removeEndSlash () { echo "$( echo "${1}" | sed -e 's/\(.*\)\/$/\1/' )"; }
# Convert underscores to spaces
#   params: 1 - string
#   prints: converted string
#   return: nil
underSpace () { echo "${1}" | tr '_' ' '; }
# Strip quotes from front and end of string
#   params: 1 - string
#   prints: string with enclosed quotes removed
#   return: nil
stripEnclosingQuotes () {
	# set variable
	local string="${1}"
	eval echo "${string}" &>/dev/null  # multiple quotes can confuse eval
	local use_eval=${?}
	# strip quotes
	if [ $( echo "${string}" | grep -c -- '^"' ) -eq 1 ] ; then
		# do not use eval if use causes error
		if [ ${use_eval} -eq 0 ] ; then
			string="$( eval echo "${string}" | \
			                sed -e 's/^"//'  | \
							sed -e 's/"$//'    \
			         )"
		else
			string="$( echo "${string}"      | \
			                sed -e 's/^"//'  | \
			                sed -e 's/"$//'    \
			         )"
		fi
	elif [ $( echo "${string}" | grep -c -- "^'" ) -eq 1 ] ; then
		if [ ${use_eval} -eq 0 ] ; then
			string="$( eval echo "${string}" | \
			                sed -e "s/^'//"  | \
			                sed -e "s/'$//"    \
			         )"
		else
			string="$( echo "${string}"      | \
			                sed -e "s/^'//"  | \
			                sed -e "s/'$//"    \
			         )"
		fi
	fi
	echo "${string}"
}
# Determine whether string present in array
#   params: 1  - element
#           2+ - array elements
#   prints: nil
#   return: boolean (0=present|1=not present)
elementInArray () {
	[ ${#} -gt 0 ] || return 1  # sanity check
	local element="${1}"
	shift
	while [ "${#}" -gt 0 ] ; do  # loop through array elements
		[ "${1}" = "${element}" ] && return 0
		shift
	done
	return 1
}
# Check if flag variable equal to zero
#   params: 1 - flag variable
#   prints: nil
#   return: boolean (0=flag true|1=flag false)
flagTrue () {
	[ -n "${1}" ] || return 1  # empty flag variable is false
	return ${1}
}
# Standardise flag value to 0|1
#   params: 1 - flag value [required]
#   prints: boolean (0=true|1=false) if match standard value
#           input value unchanged if no match to standard value
#   return: nil
standardiseBoolean () {
	# set variables
	local flag="$( lowercase "${1}" )"
	# standardise
	case ${flag} in
		'y'|'yes'|'t'|'true'|'on'|'0'  ) flag=0;;
		'n'|'no'|'f'|'false'|'off'|'1' ) flag=1;;
		* ) flag="${flag}";;  # unchanged
	esac
	# return result and indicate outcome
	echo "${flag}"
}
# Change uppercase to lowercase
#   params: 1 - string
#   prints: string
#   return: nil
lowercase () { echo "$( echo "${1}" | tr '[[:upper:]]' '[[:lower:]]' )"; }
# Write messages to system logger
#   params: 1+ - message part(s)
#   prints: nil
#   return: nil
note () {
	while [ -n "${1}" ] ; do
		logger -t "${dn_self}" "${1}"
		shift
	done
}
# Display dialog
#   params: 1 - message
#           2 - title (optional, default = script_name)
#   prints: nil
#   return: 0|1 (Boolean)
infoDlg () { dn_dlg "info" "${2}" "${1}"; }
warnDlg () { dn_dlg "warn" "${2}" "${1}"; }
errorDlg () { dn_dlg "error" "${2}" "${1}"; }
# Dialog engine
#   params: 1 - type ('info', 'warn', 'error')
#           2 - title
#           3 - message
#   prints: nil
#   return: 0|1 (Boolean)
dn_dlg () {
	# set variables and sanity checks
	local type="${1}" title="${2:-${title}}" msg="${3}" icon= x11user=
	local duration=10000  # popup display time in milliseconds
	# must have at least one user with active X session in order 
	# to display GUI message
	x11user="$( who | grep ":0" | cut -d ' ' -f 1 | sort | uniq | head -n 1 )"
	[ -n "${x11user}" ] || return
	# prepare to issue command
	case "${type}" in
	'info'  ) icon="@pkgdata_dir@/info.xpm";;
	'warn'  ) icon="@pkgdata_dir@/warn.xpm";;
	'error' ) icon="@pkgdata_dir@/error.xpm";;
	esac
	if [ -n "${dn_app_icon}" -a -f "${dn_app_icon}" ] ; then
		# user has overridden icon
		case "${type}" in
		'info'|'popup' ) icon="${dn_app_icon}" ;;
		'warn'|'error' ) dnFlagTrue $( standardiseBoolean \
			"${dn_app_icon_all_dialogs}" ) && icon="${dn_app_icon}";;
		esac
	fi
	# issue command
	su  - ${x11user} \
		-c "DISPLAY=:0 notify-send \
			-i \"${icon}\" \
			-t ${duration} \
			\"${title}\" \
			\"${msg}\"" 
	flagTrue "${?}" || note "unable to send system notification"
}
# Common exit point from script when failure has occurred
# Send messages to system logger
#   params: 1+ - message parts
#   prints: nil
#   return: nil
abort () { note "${@}"; exit 1; }
# Determine whether a the sound device is attached to the system
# i.e, is it plugged in?
#   params: alsa device name
#   prints: nil
#   return: boolean (0=success|1=failed)
deviceAttached () {
	local device="${1}" attached=1 card=""
	# loop through attached devices looking for match
	for card in $( cat /proc/asound/cards \
		         | grep "^ *[[:digit:]]\+" \
		         | sed -e "s/^ * [[:digit:]]\+ \[\([[:graph:]]\+\) *\].*$/\1/" \
				 ) ; do
		[ "${device}" = "${card}" ] && attached=0
	done
	return ${attached}
}


# MAIN

# Process configuration files
processConfigFiles "${global_conf}"
unset global_conf

# Process command line
processCommandLine "${@}"
while [ "${*}" != "${args}" ] ; do shift ; done
unset args

# Some preliminary checks
# - check: number of parameters
[ ${#} -eq 1 ] || abort "need one parameter only -- received '${@}'"
# - check: that there is a default device
default_label="$( defaultLabel )"
[ -n "${default_label}" ] || abort "no default device is configured"

# Determine whether device has been inserted or removed
# - if not attached assume script called on remove event
#   so switch to system default device
label="${1}"
loadDeviceParams "${label}"
if ! deviceAttached "${name}" ; then
	note "${description} appears to have been unplugged"
	label="${default_label}"
	loadDeviceParams "${label}"
	note "switching to ${description}"
fi
unset default_label names[@] numbers[@] descriptions[@] defaults[@]
unset set_sounds[@] controls[@] levels[@] name

# Now that we have determined the label, do more checks
# - check: label must be described in config file
elementInArray "${label}" "${labels[@]}" || abort "invalid label '${label}'"
# - check: must have config file matching label
if ! test -f "${pkgconfdir}/${conf_stub}${label}" ; then
	msg="Label '${label}' has no\nmatching configuration file"
	msg="${msg}\n'${pkgconfdir}/${conf_stub}${label}'"
	errorDlg "${msg}"
	abort "label '${label}' has no matching configuration file" \
	      "  '${pkgconfdir}/${conf_stub}${label}'"
fi
# - check: main alsa config file must be a symlink
if test -f "${sysconfdir}/${link_name}" ; then
	if ! test -h "${sysconfdir}/${link_name}" ; then
		errorDlg "${sysconfdir}/${link_name}\nis not a symlink"
		abort "${sysconfdir}/${link_name} is not a symlink"
	fi
fi
unset labels[@]

# Delete existing symlink
if test -h "${sysconfdir}/${link_name}" ; then
	rm -f "${sysconfdir}/${link_name}" >/dev/null 2>&1
	if ! flagTrue "${?}" ; then
		errorDlg "Unable to delete\n'${sysconfdir}/${link_name}'"
		abort "unable to delete '${sysconfdir}/${link_name}'"
	fi
fi

# Create new symlink
ln -s "${pkgconfdir}/${conf_stub}${label}" \
	"${sysconfdir}/${link_name}" >/dev/null 2>&1
if flagTrue "${?}" ; then
	infoDlg "Default sound device is now the ${description}"
	sleep 3  # allow previous message to display in full
	note "${description} set as alsa default"
else
	msg="Unable to symlink\n${pkgconfdir}/${conf_stub}${label}"
	msg="${msg}\nto ${sysconfdir}/${link_name}"
	errorDlg "${msg}"
	abort "unable to symlink ${pkgconfdir}/${conf_stub}${label}" \
	      "  to ${sysconfdir}/${link_name}"
fi
unset label pkgconfdir sysconfdir link_name conf_stub description

# Set sound level if requested to
if flagTrue "${set_sound}" ; then
	amixer -c ${number} set "${control}" "${level}" unmute >/dev/null 2>&1
	if flagTrue "${?}" ; then
		infoDlg "Sound level set to ${level}"
		note "sound level set to ${level}"
	else
		warnDlg "Unable to set mixer control ${control} to ${level}"
		abort "unable to set mixer control ${control} to ${level}"
	fi
fi
unset number set_sound control level title msg
