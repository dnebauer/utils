#!/usr/bin/perl 

use Moo;    #                                                          {{{1
use strictures 2;
use 5.014_002;
use version; our $VERSION = qv('0.1');
use namespace::clean;    #                                             }}}1

# package Dn::Event                                                    {{{1
# - models a single event
{

    package Dn::Event;

    use Moo;    #                                                      {{{2
    use strictures 2;
    use namespace::clean;
    use Date::Simple;
    use Function::Parameters;
    use Readonly;
    use Time::Simple;
    use Types::Standard qw(InstanceOf Str);

    Readonly my $TRUE  => 1;
    Readonly my $FALSE => 0;    #                                      }}}2

    # attributes

    # date_obj, iso_date, long_date, columnar_date                     {{{2
    has 'date_obj' => (
        is            => 'rw',
        isa           => Types::Standard::InstanceOf ['Date::Simple'],
        required      => $TRUE,
        documentation => 'Date of event',
    );

    method iso_date () {    # 2015-09-10
        return $self->date_obj->format('%F');
    }

    method long_date () {    # Thursday 10 September 2015
        my $string = $self->date_obj->format('%A %e %B %Y');
        $string =~ s/\s{2,}/ /xsmg;
        return $string;
    }

    method columnar_date () {    # Thu 10 Sep 2015
        return $self->date_obj->format('%a %e %b %Y');
    }

    # start_time_obj, start_time                                       {{{2
    has 'start_time_obj' => (
        is            => 'rw',
        isa           => Types::Standard::InstanceOf ['Time::Simple'],
        required      => $FALSE,
        documentation => 'Event start time',
    );

    method start_time () {
        if ( $self->start_time_obj ) {
            return $self->start_time_obj->format('%H%M');
        }
        else {
            return '????';
        }
    }

    # end_time_obj, end_time                                           {{{2
    has 'end_time_obj' => (
        is            => 'rw',
        isa           => Types::Standard::InstanceOf ['Time::Simple'],
        required      => $FALSE,
        documentation => 'Event end time',
    );

    method end_time () {
        if ( $self->end_time_obj ) {
            return $self->end_time_obj->format('%H%M');
        }
        else {
            return '????';
        }
    }

    # name                                                             {{{2
    has 'name' => (
        is            => 'rw',
        isa           => Types::Standard::Str,
        required      => $TRUE,
        documentation => 'Event name',
    );

    # location                                                         {{{2
    has 'location' => (
        is            => 'rw',
        isa           => Types::Standard::Str,
        required      => $TRUE,
        documentation => 'Event location',
    );

    # equal_to($event)                                                 {{{2
    #
    # does:   determine event is equal to another event
    # params: $event - event to compare with [required]
    # prints: nil, except error messages
    # return: n/a, dies on failure
    method equal_to ($event) {

        # compare dates
        if ( $self->date_obj != $event->date_obj ) { return; }

        # dates equal, so compare times
        # - if both times defined, check for inequality
        if ( $self->start_time_obj and $event->start_time_obj ) {
            if ( $self->start_time_obj->format ne
                $event->start_time_obj->format )
            {
                return;
            }
        }
        if ( $self->end_time_obj and $event->end_time_obj ) {
            if ( $self->end_time_obj->format ne $event->end_time_obj->format )
            {
                return;
            }
        }

        # - if only one time defined, then unequal
        my $start_times_defined = 0;
        if ( $self->start_time_obj )     { $start_times_defined++; }
        if ( $event->start_time_obj )    { $start_times_defined++; }
        if ( $start_times_defined == 1 ) { return; }
        my $end_times_defined = 0;
        if ( $self->end_time_obj )     { $end_times_defined++; }
        if ( $event->end_time_obj )    { $end_times_defined++; }
        if ( $end_times_defined == 1 ) { return; }

        # times equal, so compare names
        if ( $self->name ne $event->name ) { return; }

        # names equal, so compare locations
        if ( $self->location ne $event->location ) { return; }

        # all equal
        return $TRUE;
    }

    # methods

    # summary($columnar)                                               {{{2
    #
    # does:   provide one-line summary of event
    # params: $columnar - format for columnar output [optional, default=false]
    # prints: nil
    # return: scalar string
    method summary ($columnar = $FALSE) {
        my $time   = $self->start_time . q{-} . $self->end_time;
        my $locn   = q{(} . $self->location . q{)};
        my @items  = ( $self->columnar_date, $time, $self->name, $locn );
        my $string = join q{ }, @items;
        return $string;
    }

    # valid()                                                          {{{2
    #
    # does:   determine whether object is valid
    # params: nil
    # prints: error messages if invalid
    # return: scalar boolean
    # note:   must have all attributes except times
    method valid () {
        return ( $self->date_obj and $self->name and $self->location );
    }    #                                                             }}}2

}    #                                                                 }}}1

# package Dn::Events                                                   {{{1
# - models a group of events
{

    package Dn::Events;

    use Moo;    #                                                      {{{2
    use strictures 2;
    use namespace::clean;
    use Carp qw(confess);
    use Data::Dumper::Simple;
    use Dn::Common;
    use Function::Parameters;
    use MooX::HandlesVia;
    use Readonly;
    use Scalar::Util qw(blessed);
    use Types::Standard qw(ArrayRef InstanceOf);

    my $cp = Dn::Common->new();
    Readonly my $TRUE  => 1;
    Readonly my $FALSE => 0;    #                                      }}}2

    # attributes

    # _events_list                                                     {{{2
    has '_events_list' => (
        is  => 'rw',
        isa => Types::Standard::ArrayRef [
            Types::Standard::InstanceOf ['Dn::Event']
        ],
        default     => sub { [] },
        handles_via => 'Array',
        handles     => {
            _add_event => 'push',
            has_events => 'count',
            events     => 'elements',
        },
        documentation => 'Events',
    );    #                                                            }}}2

    # methods

    # add_event($event)                                                {{{2
    #
    # does:   add event
    # params: $event - Dn::Event object [required]
    # prints: nil, except error feedback if unable to add event
    # return: n/a, dies on failure
    method add_event ($event) {
        $self->_ensure_is_event($event);

        # event must be valid
        if ( not $event->valid() ) {
            my $val = Dumper($event);
            warn "Event ($val) is invalid\n";
            return;
        }

        # event must not already exist
        if ( $self->_event_exists($event) ) {
            warn "Event already exists\n";
            return;
        }

        # okay, add event
        if ( $self->_add_event($event) ) { return $TRUE; }
        return;
    }

    # _ensure_is_event($value)                                         {{{2
    #
    # does:   ensure value is an event object
    # params: $value - value to analyse [required]
    # prints: nil, except error feedback
    # return: n/a, dies on failure
    method _ensure_is_event ($event) {
        if ( not $event ) { confess 'No event provided'; }
        my $val = Dumper($event);
        if ( not Scalar::Util::blessed($event) ) {
            confess "Event ($val) is not an object";
        }
        if ( not $event->isa('Dn::Event') ) {
            confess "Event ($val) is not a Dn::Event object";
        }
    }

    # _event_exists($event)                                            {{{2
    #
    # does:   determine whether event already exists
    # params: $event - event to look for [required]
    # prints: nil, except error messages
    # return: n/a, dies on failure
    method _event_exists ($event) {
        $self->_ensure_is_event($event);

        # compare to existing events
        for my $existing_event ( $self->events ) {
            return $TRUE if $existing_event->equal_to($event);
        }

        return;
    }

    # sort_events()                                                    {{{2
    #
    # does:   sort events in place
    # params: nil
    # prints: nil
    # return: n/a, dies on failure
    method sort_events () {
        my @sorted_events = sort _custom_sort $self->events;
        say 'Sorted events';
        return $self->_events_list( [@sorted_events] );
    }

    # _custom_sort()                                                   {{{2
    #
    # does:   custom sort routine
    # params: $a and $b passed automatically by reference
    # prints: nil
    # return: scalar integer (-1, 0 or 1)
    method _custom_sort () {

        # $a and $b passed by reference

        # assume events are valid:
        # - have dates
        # - may not have times

        # compare dates
        if ( $a->date_obj > $b->date_obj ) { return 1; }
        if ( $a->date_obj < $b->date_obj ) { return -1; }

        # dates equal, so compare start times...
        # - format('%s') returns seconds since epoch
        if ( $a->start_time_obj and $b->start_time_obj ) {
            my $a_start_epoch = $a->start_time_obj->format('%s');
            my $b_start_epoch = $b->start_time_obj->format('%s');
            if ( $a_start_epoch > $b_start_epoch ) { return 1; }
            if ( $a_start_epoch < $b_start_epoch ) { return -1; }
        }
        else {    # consider undefined time to be before any defined time
            if ( $a->start_time_obj ) { return 1; }
            if ( $b->start_time_obj ) { return -1; }
        }

        # ...and then compare end times
        # - format('%s') returns seconds since epoch
        if ( $a->end_time_obj and $b->end_time_obj ) {
            my $a_end_epoch = $a->end_time_obj->format('%s');
            my $b_end_epoch = $b->end_time_obj->format('%s');
            if ( $a_end_epoch > $b_end_epoch ) { return 1; }
            if ( $a_end_epoch < $b_end_epoch ) { return -1; }
        }
        else {    # consider undefined time to be before any defined time
            if ( $a->end_time_obj ) { return 1; }
            if ( $b->end_time_obj ) { return -1; }
        }

        # times equal, so compare names
        if ( $a->name gt $b->name ) { return 1; }
        if ( $a->name lt $b->name ) { return -1; }

        # names equal, so compare locations
        if ( $a->location gt $b->location ) { return 1; }
        if ( $a->location lt $b->location ) { return -1; }

        # all equal
        return 0;
    }

    # iso_dates()                                                      {{{2
    #
    # does:   get dates for which events are defined
    # params: nil
    # prints: nil
    # return: list of sorted dates (ISO-format)
    method iso_dates () {
        my @dates = map { $_->iso_date() } $self->events;
        @dates = List::MoreUtils::uniq @dates;
        return @dates;
    }

    # names()                                                          {{{2
    #
    # does:   get event names
    # params: nil
    # prints: nil
    # return: list of event names
    method names () {
        my @names = map { $_->name } $self->events;
        @names = List::MoreUtils::uniq @names;
        @names = sort @names;
        return @names;
    }

    # names_locations()                                                {{{2
    #
    # does:   get arrayref of event names,
    #         each of which has arrayref of locations
    # params: nil
    # prints: nil
    # return: arrayref of event names, each with arrayref of locations
    method names_locations () {
        my $ref = {};
        foreach my $event ( $self->events ) {
            my $name     = $event->name;
            my $location = $event->location;
            $ref->{$name}->{$location} = $TRUE;
        }
        return $ref;
    }

    # event_locations($name)                                           {{{2
    #
    # does:   get list of locations for specific event
    # params: $name - event name [required]
    # prints: nil
    # return: list of locations
    method event_locations ($name) {
        if ( not $name ) { confess 'No event name provided'; }
        my @locations;
        foreach my $event ( $self->events ) {
            my $event_name = $event->name;
            if ( $event_name eq $name ) {
                push @locations, $event->location;
            }
        }
        @locations = List::MoreUtils::uniq @locations;
        @locations = sort @locations;
        return @locations;
    }

    # locations()                                                      {{{2
    #
    # does:   get list of locations
    # params: nil
    # prints: nil
    # return: list of event locations
    method locations () {
        my @locations = map { $_->location } $self->events;
        @locations = List::MoreUtils::uniq @locations;
        @locations = sort @locations;
        return @locations;
    }

    # event_index($prompt)                                             {{{2
    #
    # does:   get index of particular event (zero-based)
    # params: $prompt - user prompt [optional, default='Select event:']
    # prints: nil
    # return: scalar integer
    method event_index ($prompt) {
        if ( not $prompt ) { $prompt = 'Select event:'; }
        my @events = $self->events;
        if ( not @events ) { return; }
        my @items = map { $_->summary() } @events;
        return Dn::Menu->new(
            type      => 'term',
            header    => 'Event Planner',
            prompt    => $prompt,
            menu_list => [@items],
            index     => $TRUE,
        )->select_option();
    }

    # replace_event($index, $event)                                    {{{2
    #
    # does:   replace event
    # params: $index - index of event to replace [required]
    #         $event - replacement event [required]
    # prints: nil, except for error messages
    # return: boolean success
    method replace_event ($index, $event) {

        # check args
        if ( not defined $index ) { confess 'No index provided'; }
        if ( not $event )         { confess 'No event provided'; }
        my @events = $self->events;
        if ( not $events[$index] ) { return; }
        $self->_ensure_is_event($event);

        # replace event
        $events[$index] = $event;
        return $self->_events_list( [@events] );
    }

    # delete_event($index)                                             {{{2
    #
    # does:   delete event
    # params: $index - index of event to delete [required]
    # prints: nil, except for error messages
    # return: boolean success
    method delete_event ($index) {

        # check arg
        if ( not defined $index ) { confess 'No index provided'; }
        my @events = $self->events;
        if ( not $events[$index] ) { return; }

        # delete event
        splice @events, $index, 1;
        return $self->_events_list( [@events] );
    }

    # display_events([$title])                                         {{{2
    #
    # does:   display events
    # params: $title - title of event collection [optional]
    # prints: event details
    # return: n/a
    method display_events ($title) {
        my @display;
        if ($title) {
            push @display, $cp->centre_text( uc $title );
        }
        push @display, map { $_->summary($TRUE) } $self->events;
        @display = $cp->do_wrap( [@display], hang => 4 );
        $cp->pager( [@display], 'more' );
    }

    # change_event_name($old, $new)                                    {{{2
    #
    # does:   change event name across all events
    # params: $old - existing event name to change [required]
    #         $new - new event name [required]
    # prints: feedback
    # return: n/a
    method change_event_name ($old, $new) {

        # check args
        if ( not $old ) { confess 'No existing event name provided'; }
        if ( not $new ) { confess 'No new event name provided'; }

        # rename events
        my $count  = 0;
        my @events = $self->events;
        foreach my $event (@events) {
            if ( $event->name eq $old ) {
                $event->name($new);
                $count++;
            }
        }

        # save changes
        if ( not $self->_events_list( [@events] ) ) { return; }

        # provide feedback
        say $cp->pluralise( "Renamed $count (event|events)", $count );

        return $TRUE;
    }

    # change_location($old, $new)                                      {{{2
    #
    # does:   change location across all events
    # params: $old - existing location to change [required]
    #         $new - new location [required]
    # prints: feedback
    # return: n/a
    method change_location ($old, $new) {

        # check args
        if ( not $old ) { confess 'No existing location provided'; }
        if ( not $new ) { confess 'No new location provided'; }

        # rename location
        my $count  = 0;
        my @events = $self->events;
        foreach my $event (@events) {
            if ( $event->location eq $old ) {
                $event->location($new);
                $count++;
            }
        }

        # save changes
        if ( not $self->_events_list( [@events] ) ) { return; }

        # provide feedback
        say $cp->pluralise( "Changed location in $count (event|events)",
            $count );

        return $TRUE;
    }    #                                                             }}}2

}    #                                                                 }}}1

{

    package Dn::FestivalPlanner;

    use Moo;    # {{{1
    use strictures 2;
    use namespace::clean -except => [ '_options_data', '_options_config' ];
    use autodie qw(open close);
    use Carp qw(cluck confess);
    use Dn::Common;
    use Dn::Menu;
    use English qw(-no_match_vars);
    use Function::Parameters;
    use HTML::Template;
    use List::MoreUtils qw(first_index uniq);
    use MIME::Base64;
    use MooX::Options;
    use Readonly;
    use Storable qw(retrieve store);
    use Types::Standard qw(Bool InstanceOf Str);
    use experimental 'switch';

    my $cp = Dn::Common->new();    # DELETE ???

    Readonly my $TRUE  => 1;
    Readonly my $FALSE => 0;

    # debug
    use Data::Dumper::Simple;      #                                     }}}1

    # options

    # datastore (-s)                                                   {{{1
    option 'datastore' => (
        is            => 'ro',
        format        => 's',
        required      => $FALSE,
        default       => 'festival.data',
        short         => 's',
        order         => 1,
        documentation => 'Data store filepath',
    );

    # list      (-l)                                                   {{{1
    option 'list' => (
        is            => 'ro',
        short         => 'l',
        order         => 2,
        documentation => 'List event details and exit',
    );

    # write     (-w)                                                   {{{1
    option 'write' => (
        is            => 'ro',
        short         => 'w',
        order         => 3,
        documentation => 'Write output files and exit',
    );    #                                                            }}}1

    # attributes

    # _title                                                           {{{1
    has '_title' => (
        is            => 'rw',
        isa           => Types::Standard::Str,
        required      => $FALSE,
        documentation => 'Title of html page',
    );

    # _events                                                          {{{1
    has '_events' => (
        is            => 'rw',
        isa           => Types::Standard::InstanceOf ['Dn::Events'],
        builder       => '_build_events',
        documentation => 'Collection of events',
    );

    method _build_events () {
        return Dn::Events->new();
    }

    # _save                                                            {{{1
    has '_save' => (
        is            => 'rw',
        isa           => Types::Standard::Bool,
        default       => $FALSE,
        documentation => 'Whether to save data on exit',
    );

    # _using_menu                                                      {{{1
    has '_using_menu' => (
        is            => 'rw',
        isa           => Types::Standard::Bool,
        documentation => 'Whether main menu is being used',

        # cannot be set at startup, presumably because it relies
        # on the values of options, and startup timing of setting
        # options and attributes precludes that
    );    #                                                            }}}1

    # methods

    # main()                                                           {{{1
    #
    # does:   main method
    # params: nil
    # prints: feedback
    # return: n/a, dies on failure
    method main () {

        # set attribute '_using_menu' to prevent unnecessary delays
        $self->_set_using_menu();

        # load data from data store if available
        $self->_load_data();

        # process args (each arg requires exiting)
        if ( $self->_process_args() ) { return; }

        # enter title if not already loaded
        if ( not $self->_title ) {
            say 'Festival name has not been set';
            $self->_set_title();
        }

        # go to dispatch table
        $self->_dispatch();

        # write data before exiting
        $self->_save_data();

        return;
    }

    # _set_using_menu                                                  {{{1
    #
    # does:   set attribute '_using_menu'
    # params: nil
    # prints: nil
    # return: n/a, dies on failure
    method _set_using_menu () {
        my $using = $TRUE;
        if ( $self->write or $self->list ) { $using = $FALSE; }
        $self->_using_menu($using);
    }

    # _process_args()                                                  {{{1
    #
    # does:   process args
    # params: nil
    # prints: feedback
    # return: boolean (whether arg provided)
    method _process_args () {

        # list events if user requested
        if ( $self->list ) {
            $self->_list_events();
            return $TRUE;
        }

        # write output files if user requested
        if ( $self->write ) {
            $self->_write_output();
            return $TRUE;
        }

        return;
    }

    # _load_data()                                                     {{{1
    #
    # does:   load data from data store
    # params: nil
    # prints: nil, except error messages
    # return: n/a, dies on failure
    method _load_data () {
        while (1) {

            # check for data store
            my $store = $self->datastore;
            if ( not -r $store ) {
                my @err = (
                    "Cannot find '$store'\n",
                    "-- will be created on exit\n",
                    "No data loaded\n",
                );
                warn @err;
                last;
            }

            # load data
            my $data;
            if ( $data = Storable::retrieve($store) ) {
                say "Found data store: '$store'";
            }
            else {
                warn "Unable to load data from '$store'\n";
                last;
            }

            # extract title and/or events from data
            my ( $title, $events );
            if ( $data->{'title'} )  { $title  = $data->{'title'}; }
            if ( $data->{'events'} ) { $events = $data->{'events'}; }
            my @loaded;
            if ($title) {
                $self->_title($title);
                push @loaded, 'title';
            }
            if ($events) {
                $self->_events($events);
                if ( $self->_events->has_events ) { push @loaded, 'events'; }
            }
            else {
                $self->_events( Dn::Events->new() );
            }

            # provide feedback
            if (@loaded) { say 'Loaded: ' . ( join q{, }, @loaded ); }
            else         { say 'No data loaded'; }

            last;
        }
        if ( $self->_using_menu ) { sleep 2; }
    }

    # _set_title()                                                     {{{1
    #
    # does:   enter/edit title
    # params: nil
    # prints: nil, except error messages
    # return: n/a, dies on failure
    method _set_title () {
        while (1) {

            # set prompts and feedback
            my ( $prompt, $default, $verb );
            if ( $self->_title ) {
                $prompt  = 'Edit festival name:';
                $default = $self->_title;
                $verb    = 'changed';
            }
            else {
                $prompt = 'Enter festival name:';
                $verb   = 'entered';
            }

            # get title from user
            my $title = $cp->input_ask( $prompt, $default );

            # set title if provided
            if ($title) {
                $self->_title($title);
                say "Festival name $verb";
                $self->_save($TRUE);
                last;
            }

            # repeat if title not provided
            warn "Festival name is required\n";
        }
        if ( $self->_using_menu ) { sleep 2; }
    }

    # _dispatch()                                                      {{{1
    #
    # does:   dispatch table
    # params: nil
    # prints: nil, except error messages
    # return: n/a, dies on failure
    method _dispatch () {

        while (1) {
            my @options;
            my $has_events = $self->_events->has_events;

            # set available options
            # - those that do not require events
            push @options, 'Add events';
            push @options, 'Change festival name';

            # - those that require events
            if ($has_events) {
                push @options, 'List events';
                push @options, 'Edit events';
                push @options, 'Delete events';
                push @options, 'Write output files';
                push @options, 'Rename events';
                push @options, 'Rename locations';
            }

            # - those that require either events or title
            if ( $self->_title or $has_events ) {
                push @options, 'Save data';
            }

            # select option
            my $prompt = 'Select option (Esc to save data and exit)';
            my $option = $self->_select( $prompt, [@options] );

            # dispatch
            last if not $option;
            for ($option) {
                when (/^ Add \s events \z/xsm)    { $self->_add_events(); }
                when (/^ Delete \s events \z/xsm) { $self->_delete_events(); }
                when (/^ Edit \s events \z/xsm)   { $self->_edit_events(); }
                when (/^ List \s events \z/xsm) {
                    $self->_list_events( prompt => $TRUE );
                }
                when (/^ Rename \s events \z/xsm) { $self->_rename_events(); }
                when (/^ Rename \s locations \z/xsm) {
                    $self->_rename_locations();
                }
                when (/^ Save \z/xsm) { $self->_save_data(); }
                when (/^ Change \s festival \s name \z/xsm) {
                    $self->_set_title();
                }
                when (/^ Write \s output \s files \z/xsm) {
                    $self->_write_output();
                }
                default { say "Unrecognised option '$option'"; }
            }
        }
        $self->_using_menu($FALSE);
    }

    # _select($prompt, $items, $default)                               {{{1
    #
    # does:   select item from list
    # params: $prompt  - menu prompt
    #                    [optional, default='Select option (Esc to exit)']
    #         $items   - menu items, arrayref [optional]
    #         $default - default menu item
    #                    [named parameter, optional, default=0]
    #         $exclude - items to exclude from match, array reference
    #                    [named parameter, optional, default=[]]
    # prints: user interaction
    # return: scalar string
    method _select ($prompt, $items, :$default, :$exclude) {
        if ( not $prompt ) { $prompt = 'Select option (Esc to exit)'; }
        if ( not $items ) { return; }
        if ( ref $items ne 'ARRAY' ) { confess 'Items not an arrayref'; }
        if ( not $default ) { $default = 0; }
        my @exclusions;
        if ($exclude) {
            if ( ref $exclude ne 'ARRAY' ) {
                confess 'Exclusion items not an arrayref';
            }
            @exclusions = @{$exclude};
        }

        # remove excluded items from list
        my @keep;
        foreach my $item ( @{$items} ) {
            if ( not( List::MoreUtils::any {/^$item\z/xsm} @exclusions ) ) {
                push @keep, $item;
            }
        }
        $items = [@keep];

        # select item to return
        my $item_count = scalar @{$items};
        for ($item_count) {
            when ( $_ == 0 ) { return; }
            when ( $_ == 1 ) {
                my $item = @{$items}[0];
                return ( $cp->input_confirm("Is '$item' correct?") )
                    ? $item
                    : undef;
            }
            when ( $_ > 1 ) {
                my $option = Dn::Menu->new(
                    type      => 'term',
                    header    => 'Event Planner',
                    prompt    => $prompt,
                    menu_list => $items,
                    default   => $default,
                )->select_option();
                if ($option) { say "Selected '$option'"; }
                return $option;
            }
            default { confess "Invalid item count '$_'"; }
        }
    }

    # _add_events()                                                    {{{1
    #
    # does:   enter event data
    # params: nil
    # prints: user prompts
    # return: n/a
    method _add_events () {
        my $pause        = $TRUE;
        my $changes_made = $FALSE;
        my ($date_input, $start_input, $end_input,
            $name_input, $location_input
        );
        my ( $prompt, $default );
        while (1) {

            # get date
            my @existing_dates = $self->_events->iso_dates();
            if (@existing_dates) {
                $prompt = 'Select date (Esc to enter new date):';
                $default = $self->_default( $date_input, [@existing_dates] );
                $date_input
                    = $self->_select( $prompt, [@existing_dates],
                    default => $default );
            }
            if ( not $date_input ) {
                $date_input = $cp->input_ask('Enter date (ISO format):');
            }
            if ( not $date_input ) {
                warn "No date entered -- exiting event entry\n";
                last;
            }
            my $date = Date::Simple->new($date_input);
            if ( not $date ) {
                warn "Invalid date '$date_input' -- exiting event entry\n";
                last;
            }

            # get start time
            $start_input
                = $cp->input_ask('Enter start time (24 hour format):');
            my $start;
            if ($start_input) {
                $start = $self->_create_time_object($start_input);
                if ( not $start ) {
                    warn "Invalid time '$start_input' "
                        . "-- exiting event entry\n";
                    last;
                }
            }

            # get end time
            $end_input = $cp->input_ask('Enter end time (24 hour format):');
            my $end;
            if ($end_input) {
                $end = $self->_create_time_object($end_input);
                if ( not $end ) {
                    warn "Invalid time '$end_input' "
                        . "-- exiting event entry\n";
                    last;
                }
            }

            # get event name
            my @names = $self->_events->names();
            if (@names) {
                $prompt     = 'Select event name (Esc to enter new name):';
                $default    = $self->_default( $name_input, [@names] );
                $name_input = $self->_select( $prompt, [@names],
                    default => $default );
            }
            else {
                $name_input = q{};
            }
            if ( not $name_input ) {
                $name_input = $cp->input_ask('Enter event name:');
            }
            if ( not $name_input ) {
                warn "No name entered -- exiting event entry\n";
                last;
            }
            my $name = $name_input;

            # get event location
            # - first try selecting from previous locations for this event
            my @event_locations = $self->_events->event_locations($name);
            if (@event_locations) {
                $prompt = 'Select from previous locations for this event:';
                $default
                    = $self->_default( $location_input, [@event_locations] );
                $location_input
                    = $self->_select( $prompt, [@event_locations],
                    default => $default );
            }
            else {
                $location_input = q{};
            }
            if ( not $location_input ) {    # try selecting from all locations
                my @locations = $self->_events->locations();
                $prompt  = 'Select from all locations (Esc to enter new):';
                $default = 0;
                $location_input
                    = $self->_select( $prompt, [@locations],
                    default => $default );
            }
            if ( not $location_input ) {    # lastly, try for direct input
                $location_input = $cp->input_ask('Enter event location:');
            }
            if ( not $location_input ) {
                warn "No location entered -- exiting event entry\n";
                last;
            }
            my $location = $location_input;

            # construct event object
            my $event = Dn::Event->new(
                date_obj => $date,
                name     => $name,
                location => $location,
            );
            if ($start) { $event->start_time_obj($start); }
            if ($end)   { $event->end_time_obj($end); }

            # add event
            if ( $self->_events->add_event($event) ) {
                $changes_made = $TRUE;
                say 'Event added';
            }
            else {
                warn "Entry not added\n";
            }
        }
        if ($changes_made) {
            $self->_events->sort_events();
            $self->_save($TRUE);
        }
        if ($pause) { sleep 2; }
    }

    # _default($item, $list)                                           {{{1
    #
    # does:   enter event data
    # params: $default - default item [optional]
    #         $items   - list to search for default item, arrayref [optional]
    # prints: nil, except error messages
    # return: scalar integer
    method _default ($default, $items) {
        if ( not $default )          { return 0; }
        if ( not $items )            { return 0; }
        if ( ref $items ne 'ARRAY' ) { confess 'Items not an arrayref'; }
        my $item_count = scalar @{$items};
        if ( $item_count == 0 ) { return 0; }

        # get index of default item
        my $index = List::MoreUtils::first_index {/^$default\z/xsm} @{$items};
        if ( $index == -1 ) { $index = 0; }
        return $index;
    }

    # _create_time_object($time)                                       {{{1
    #
    # does:   create time object
    # params: $time - time string [required]
    # prints: error message
    # return: time object, undef if fails
    method _create_time_object ($time) {
        if ( not $time ) { return; }
        if ( $time =~ /^ ( \d{2} ) ( \d{2} ) \z/xsm ) {
            $time = "$1:$2";
        }
        my $object = eval { Time::Simple->new($time) };
        if ( not $object ) {
            if   ($EVAL_ERROR) { warn "$EVAL_ERROR\n"; }
            else               { warn "Invalid time '$time'\n"; }
            return;
        }
        return $object;
    }

    # _edit_events()                                                   {{{1
    #
    # does:   edit existing events
    # params: nil
    # prints: user prompts
    # return: n/a
    method _edit_events () {
        my $pause        = $TRUE;
        my $changes_made = $FALSE;
        my $default;

        while (1) {

            # check for events
            if ( not $self->_events->has_events ) {
                warn "No events have been defined\n";
                last;
            }

            # get index of event to edit
            my $index = $self->_events->event_index('Select event to edit:');
            if ( not defined $index ) {
                warn "No event selected\n";
                last;
            }

            # get event details
            my @current_events = $self->_events->events;
            my $current_event  = $current_events[$index];
            my $date_input     = $current_event->date_obj->format('%F');
            my $name_input     = $current_event->name;
            my $location_input = $current_event->location;
            my ( $start_input, $end_input );
            if ( $current_event->start_time_obj ) {
                $start_input = $current_event->start_time_obj->format('%H%M');
            }
            if ( $current_event->end_time_obj ) {
                $end_input = $current_event->end_time_obj->format('%H%M');
            }

            # display current event
            my @display
                = ( 'Event to be edited:',
                q{  } . $current_event->summary() );
            my @wrapped = $cp->do_wrap( [@display], hang => 4 );
            $cp->pager( [@wrapped], 'more' );

            # edit event details
            my $prompt;

            # - date
            my $date;
            if ( $cp->input_confirm("Change date from '$date_input'?") ) {
                my @existing_dates = $self->_events->iso_dates();
                if (@existing_dates) {
                    $prompt = 'Select date (Esc to enter new date):';
                    $default
                        = $self->_default( $date_input, [@existing_dates] );
                    $date_input = $self->_select(
                        $prompt, [@existing_dates],
                        default => $default,
                        exclude => [$date_input]
                    );
                }
                if ( not $date_input ) {
                    $date_input = $cp->input_ask('Enter date (ISO format):');
                }
                if ( not $date_input ) {
                    warn "No date entered -- exiting event edit\n";
                    last;
                }
                $date = Date::Simple->new($date_input);
                if ( not $date ) {
                    warn "Invalid date '$date_input' -- exiting event edit\n";
                    last;
                }
            }
            else {
                $date = Date::Simple->new($date_input);
                if ( not $date ) {
                    warn "Current date is invalid! -- exiting event edit\n";
                    last;
                }
            }

            # - start time
            my $start;
            if ( not $start_input ) {
                say 'No start time for this event';
                $prompt = 'Enter start time?';
            }
            else {
                $prompt = "Change start time from '$start_input'?";
            }
            if ( $cp->input_confirm($prompt) ) {
                $start_input
                    = $cp->input_ask('Enter start time (24 hour format):');
                if ( not $start_input ) {
                    warn "No start time entered -- exiting event edit\n";
                    last;
                }
                $start = $self->_create_time_object($start_input);
                if ( not $start ) {
                    warn "Invalid time '$start_input' "
                        . "-- exiting event edit\n";
                    last;
                }
            }
            else {
                if ($start_input) {
                    $start = $self->_create_time_object($start_input);
                    if ( not $start ) {
                        warn 'Current start time is invalid!'
                            . " -- exiting event edit\n";
                        last;
                    }
                }
            }

            # - end time
            my $end;
            if ( not $end_input ) {
                say 'No end time for this event';
                $prompt = 'Enter end time?';
            }
            else {
                $prompt = "Change end time from '$end_input'?";
            }
            if ( $cp->input_confirm($prompt) ) {
                $end_input
                    = $cp->input_ask('Enter end time (24 hour format):');
                if ( not $end_input ) {
                    warn "No end time entered -- exiting event edit\n";
                    last;
                }
                $end = $self->_create_time_object($end_input);
                if ( not $end ) {
                    warn "Invalid time '$end_input' "
                        . "-- exiting event edit\n";
                    last;
                }
            }
            else {
                if ($end_input) {
                    $end = $self->_create_time_object($end_input);
                    if ( not $end ) {
                        warn 'Current end time is invalid!'
                            . "-- exiting event edit\n";
                        last;
                    }
                }
            }

            # - event name
            my $name;
            if ( $cp->input_confirm("Change name from '$name_input'?") ) {
                my @names = $self->_events->names();
                if (@names) {
                    $prompt = 'Select event name (Esc to enter new name):';
                    $default = $self->_default( $name_input, [@names] );
                    $name_input = $self->_select(
                        $prompt, [@names],
                        default => $default,
                        exclude => [$name_input]
                    );
                }
                if ( not $name_input ) {
                    $name_input = $cp->input_ask('Enter event name:');
                }
                if ( not $name_input ) {
                    warn "No name entered -- exiting event edit\n";
                    last;
                }
                $name = $name_input;
            }
            else {
                $name = $name_input;
            }

            # - location
            my $location;
            if ( $cp->input_confirm("Change location from '$location_input'?")
                )
            {
                my $current_location = $location_input;

                # - first try selecting from previous locations
                #   for this event
                my @event_locations = $self->_events->event_locations($name);
                if (@event_locations) {
                    $prompt
                        = 'Select from previous locations for this event:';
                    $default
                        = $self->_default( $location_input,
                        [@event_locations] );
                    $location_input = $self->_select(
                        $prompt, [@event_locations],
                        default => $default,
                        exclude => [$current_location],
                    );
                }
                if ( not $location_input )
                {    # try selecting from all locations
                    my @locations = $self->_events->locations();
                    $prompt = 'Select from all locations (Esc to enter new):';
                    $default        = 0;
                    $location_input = $self->_select(
                        $prompt, [@locations],
                        default => $default,
                        exclude => [$current_location]
                    );
                }
                if ( not $location_input ) {    # lastly, try for direct input
                    $location_input = $cp->input_ask('Enter event location:');
                }
                if ( not $location_input ) {
                    warn "No location entered -- exiting event edit\n";
                    last;
                }
                $location = $location_input;
            }
            else {
                $location = $location_input;
            }

            # construct event object
            my $event = Dn::Event->new(
                date_obj => $date,
                name     => $name,
                location => $location,
            );
            if ($start) { $event->start_time_obj($start); }
            if ($end)   { $event->end_time_obj($end); }

            # replace event
            if ( $event->equal_to($current_event) ) {
                warn "No changes made to event\n";
            }
            else {
                if ( $self->_events->replace_event( $index, $event ) ) {
                    say 'Saved changes';
                    $changes_made = $TRUE;
                }
                else {
                    warn "Changes not saved\n";
                }
            }
        }
        if ($changes_made) {
            $self->_events->sort_events();
            $self->_save($TRUE);
        }
        if ($pause) { sleep 2; }
    }

    # _delete_events()                                                 {{{1
    #
    # does:   delete existing events
    # params: nil
    # prints: user prompts
    # return: n/a
    method _delete_events () {
        while (1) {

            # check for events
            if ( not $self->_events->has_events ) {
                warn "No events have been defined\n";
                last;
            }

            # get index of event to delete
            my $prompt = 'Select event to delete (Esc to exit):';
            my $index  = $self->_events->event_index($prompt);
            if ( not defined $index ) {
                warn "No event selected\n";
                last;
            }

            # delete event
            if ( $self->_events->delete_event($index) ) {
                say 'Deleted event';
                $self->_save($TRUE);
            }
            else {
                warn "Event not deleted\n";
            }
        }
        sleep 2;
    }

    # _list_events($prompt)                                            {{{1
    #
    # does:   list events
    # params: $prompt - whether to prompt user after display
    #                   [named argument, optional, default=false]
    # prints: event details
    # return: n/a
    method _list_events (:$prompt = $FALSE) {
        if ( $self->_events->has_events ) {
            my $divider = q{-} x $cp->term_size->width;
            say $divider;
            my $title;
            if ( $self->_title ) { $title = $self->_title; }
            $self->_events->display_events($title);
            say $divider;
        }
        else {
            warn "No events to display\n";
        }
        if ($prompt) { $cp->prompt(); }
    }

    # _rename_events()                                                 {{{1
    #
    # does:   change existing event names across all events
    # params: nil
    # prints: user prompts
    # return: n/a
    method _rename_events () {
        my $pause        = $TRUE;
        my $changes_made = $FALSE;

        while (1) {

            # check for events
            if ( not $self->_events->has_events ) {
                warn "No events have been defined\n";
                last;
            }

            # get event name to change
            my @names         = $self->_events->names();
            my $prompt        = 'Select event name to change:';
            my $existing_name = $self->_select( $prompt, [@names] );
            if ( not $existing_name ) {
                warn "No event name selected\n";
                last;
            }
            $prompt = "Change name of ALL $existing_name events?";
            if ( not $cp->input_confirm($prompt) ) {
                say 'Exiting event renaming';
                last;
            }

            # get new event name
            my $new_name = $cp->input_ask('Enter new event name:');
            if ( not $new_name ) {
                warn "No event name provided\n";
                last;
            }

            # rename events
            my @args = ( $existing_name, $new_name );
            if ( $self->_events->change_event_name(@args) ) {
                $changes_made = $TRUE;
            }
            else {
                warn "Unable to change event name\n";
            }
        }
        if ($changes_made) {
            $self->_events->sort_events();
            $self->_save($TRUE);
        }
        if ($pause) { sleep 2; }
    }

    # _rename_locations()                                              {{{1
    #
    # does:   change existing event locations across all events
    # params: nil
    # prints: user prompts
    # return: n/a
    method _rename_locations () {
        my $pause        = $TRUE;
        my $changes_made = $FALSE;

        while (1) {

            # check for events
            if ( not $self->_events->has_events ) {
                warn "No events have been defined\n";
                last;
            }

            # get event location to change
            my @locations         = $self->_events->locations();
            my $prompt            = 'Select location to change:';
            my $existing_location = $self->_select( $prompt, [@locations] );
            if ( not $existing_location ) {
                warn "No location selected\n";
                last;
            }
            say 'Note this process will change this location for ALL events';
            say 'at this location';
            $prompt = "Do you want to change location '$existing_location'?";
            if ( not $cp->input_confirm($prompt) ) {
                say 'Exiting location renaming';
                last;
            }

            # get new location
            $prompt = 'Select from existing locations (Esc to enter new):';
            my $new_location = $self->_select( $prompt, [@locations],
                exclude => [$existing_location], );
            if ( not $new_location ) {
                $new_location = $cp->input_ask('Enter event location:');
            }
            if ( not $new_location ) {
                warn "No location entered -- exiting location change\n";
                last;
            }

            # rename location
            my @args = ( $existing_location, $new_location );
            if ( not $self->_events->change_location(@args) ) {
                $changes_made = $TRUE;
            }
            else {
                warn "Unable to change location\n";
            }
        }
        if ($changes_made) {
            $self->_events->sort_events();
            $self->_save($TRUE);
        }
        if ($pause) { sleep 2; }
    }

    # _save_data()                                                     {{{1
    #
    # does:   save data to data store
    # params: nil
    # prints: nil, except error messages
    # return: n/a, dies on failure
    method _save_data () {
        while (1) {
            if ( not $self->_save ) {
                say 'No data has been changed';
                last;
            }
            my $store = $self->datastore;
            my $data  = {};
            if ( $self->_title )  { $data->{'title'}  = $self->_title; }
            if ( $self->_events ) { $data->{'events'} = $self->_events; }
            if ( not %{$data} ) {
                warn "No data to save\n";
                $self->_save($FALSE);
                last;
            }
            if ( Storable::store( $data, $store ) ) {
                say "Saved to data store: '$store'";
            }
            else {
                warn "Unable to save data to: '$store'\n";
            }
            $self->_save($FALSE);
            last;
        }
        if ( $self->_using_menu ) { sleep 2; }
    }

    # _write_output()                                                  {{{1
    #
    # does:   write output files
    # params: nil
    # prints: feedback
    # return: n/a, dies on failure
    # note:   files are 'index.html', '.htaccess',
    #         'manifest.appcache', 'favicon.png'
    method _write_output () {
        while (1) {

            # check for data to write
            if ( not $self->_events->has_events ) {
                my @err = (
                    "No events have been defined\n",
                    "Aborting write of output files\n",
                );
                warn @err;
                last;
            }

            # create output files
            $self->_write_html();
            $self->_write_icon();
            $self->_write_htaccess();
            $self->_write_cache();

            last;
        }

        if ( $self->_using_menu ) { sleep 2; }

        return;
    }

    # _write_html()                                                    {{{1
    #
    # does:   write html output file
    # params: nil
    # prints: nil, except error messages
    # return: n/a, dies on failure
    method _write_html () {

        # create some useful variables
        my @events = $self->_events->events;
        my $title  = $self->_title;
        my $output = 'index.html';
        if ( not $output ) { warn "No output html filepath provided\n"; }

        # - %data: used in creating template variables; has the structure:
        #   (
        #     iso_date_1 => {
        #       long   => long_date,
        #       id     => increment_var,
        #       events => [ event_1, ... ],
        #     },
        #     ... ,
        #   );
        my %data;

        # - %data: create entry for each date having long date and id
        my $id = 1;
        foreach my $event (@events) {
            my $iso_date = $event->iso_date();
            if ( not $data{$iso_date} ) {
                my $long_date = $event->long_date();
                $data{$iso_date}
                    = { long => $long_date, id => $id++, events => [], };
            }
        }

        # - %data: add events for each date
        foreach my $event (@events) {
            my $iso_date = $event->iso_date();
            push @{ $data{$iso_date}->{'events'} }, $event;
        }

        # create template loop variables from data variables
        my @index_entries;
        my @days_events;
        foreach my $date ( sort keys %data ) {
            my $id     = $data{$date}->{'id'};
            my $long   = $data{$date}->{'long'};
            my $events = $data{$date}->{'events'};

            # - load @index_entries
            my $index_entry = { 'url' => $id, 'day' => $long };
            push @index_entries, $index_entry;

            # - load @days_events
            my $day_events = {
                comment    => $long,
                id         => $id,
                header_day => $title,
                date       => $long,
                previous   => q{},
                next       => q{},
            };
            my @events_details;
            foreach my $event ( @{$events} ) {
                if ( $event->iso_date() eq $date ) {
                    my ( $start, $end );
                    if ( $event->start_time() ) {
                        $start = $event->start_time();
                    }
                    if ( $event->end_time() ) { $end = $event->end_time(); }
                    my $event_details = {
                        start    => $start,
                        end      => $end,
                        name     => $event->name,
                        location => $event->location,
                    };
                    push @events_details, $event_details;
                }
            }
            $day_events->{'events'} = [@events_details];
            push @days_events, $day_events;
        }

        # - add next and previous buttons
        my $prev_id;
        foreach my $day_events (@days_events) {
            if ($prev_id) { $day_events->{'previous'} = $prev_id; }
            $prev_id = $day_events->{'id'};
        }
        my $next_id;
        foreach my $day_events ( reverse @days_events ) {
            if ($next_id) { $day_events->{'next'} = $next_id; }
            $next_id = $day_events->{'id'};
        }

        # create template
        my $temp_dir    = $cp->temp_dir();
        my $template_fp = "$temp_dir/html.template";
        if ( not $self->_write_template($template_fp) ) {
            warn "Unable to create html template file\n";
            return;
        }
        open my $tfh, '<', $template_fp;
        my $template
            = HTML::Template->new( type => 'filehandle', source => $tfh );
        close $tfh;
        $template->param( title         => $title );
        $template->param( heading_main  => $title );
        $template->param( index_entries => [@index_entries] );
        $template->param( days_events   => [@days_events] );

        # create output file
        my $content = $template->output();
        return $cp->write_file( $output, $content );
    }

    # _write_template($file)                                           {{{1
    #
    # does:   write html template file
    # params: $file - output file name
    # prints: nil, except error messages
    # return: n/a, dies on failure
    method _write_template ($file) {

        # check arg
        if ( not $file ) { confess 'No teplate file name provided'; }

        # create content
        my @content = (
            q[<!DOCTYPE html>],
            q[<html cache="manifest.appcache">],
            q[],
            q[<head>],
            q[<meta charset="utf-8">],
            q[<meta name="viewport" content="width=device-width, ]
                . q[initial-scale=1"> ],
            q[<title><TMPL_VAR NAME="title"></title>],
            q[<link rel="icon" type="image/png" href="favicon.png" /> ],
            q[<link rel="stylesheet" type="text/css" ]
                . q[href="http://code.jquery.com/mobile/1.4.5/]
                . q[jquery.mobile-1.4.5.min.css" />],
            q[<style type="text/css">h1{color:#0086B9;text-align:center ]
                . q[!important;margin:0px ]
                . q[!important;}.frontpage{background-color:#0086b9 ]
                . q[!important;}.frontpage ]
                . q[h1{color:white;text-shadow:none;}]
                . q[body{text-align:center;}]
                . q[table{padding:1em 0em 1em 0.3em;}]
                . q[#m{padding:0em 1em 0em 1em;}</style>],
            q[</head> ],
            q[],
            q[<body> ],
            q[<!-- Front/index page -->],
            q[<div data-role="page" id="home">],
            q[<div data-role="header" class="frontpage">],
            q[  <h1><TMPL_VAR NAME="heading_main"></h1>],
            q[</div>],
            q[<div data-role="content" >	],
            q[<ul data-role="listview"><TMPL_LOOP NAME="index_entries">],
            q[  <li><a href="#d<TMPL_VAR NAME="url">">]
                . q[<TMPL_VAR NAME="day"></a></li></TMPL_LOOP>],
            q[</ul>],
            q[</div>],
            q[</div>],
            q[<TMPL_LOOP NAME="days_events">],
            q[<!-- <TMPL_VAR NAME="comment"> -->],
            q[<div data-role="page" id="d<TMPL_VAR NAME="id">" ]
                . q[data-theme="a">],
            q[  <div data-role="header" class="frontpage">],
            q[    <h1><TMPL_VAR NAME="header_day"></h1>],
            q[  </div>],
            q[  <div data-role="header" class="secondpage">],
            q[    <h1><TMPL_VAR NAME="date"></h1>],
            q[  </div>],
            q[  <table>],
            q[    <tr><th>When</th><th id="m">What</th><th>Where</th></tr>]
                . q[<TMPL_LOOP NAME="events">],
            q[    <tr><td><TMPL_VAR NAME="start">&ndash;]
                . q[<TMPL_VAR NAME="end"></td>]
                . q[<td id="m"><TMPL_VAR NAME="name"></td>]
                . q[<td><TMPL_VAR NAME="location"></td></tr></TMPL_LOOP>],
            q[  </table>],
            q[  <div data-role="footer" data-theme="d">],
            q[    <h4>],
            q[      <TMPL_IF NAME="previous">]
                . q[<a href="#d<TMPL_VAR NAME="previous">" ]
                . q[data-role="button" data-theme="b">Prev</a></TMPL_IF>],
            q[      <a href="#home" data-role="button" ]
                . q[data-theme="b">Home</a>],
            q[      <TMPL_IF NAME="next"><a href="#d<TMPL_VAR NAME="next">" ]
                . q[data-role="button" data-theme="b">Next</a></TMPL_IF>],
            q[    </h4>],
            q[  </div>],
            q[</div>],
            q[</TMPL_LOOP>],
            q[<script src="http://code.jquery.com/jquery-2.1.4.min.js">]
                . q[</script>],
            q[<script src="http://code.jquery.com/mobile/1.4.5/]
                . q[jquery.mobile-1.4.5.min.js"></script>],
            q[</body>],
            q[],
            q[</html>],
        );

        # write file
        return $cp->write_file( $file, [@content], silent => $TRUE );
    }

    # _write_icon()                                                    {{{1
    #
    # does:   write favourites icon
    # params: nil
    # prints: nil, except error messages
    # return: n/a, dies on failure
    method _write_icon () {
        my $file = 'favicon.png';
        if ( -f $file ) {
            say "File '$file' already exists";
            return;
        }
        my $image
            = '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';
        my $decoded = MIME::Base64::decode($image);
        return $cp->write_file( $file, $decoded );
    }

    # _write_htaccess()                                                {{{1
    #
    # does:   write .htaccess file
    # params: nil
    # prints: nil, except error messages
    # return: n/a, dies on failure
    method _write_htaccess () {
        my $file = '.htaccess';
        if ( -f $file ) {
            say "File '$file' already exists";
            return;
        }
        my @content = ( 'AddType text/cache-manifest .appcache', );
        return $cp->write_file( $file, [@content] );
    }

    # _write_cache()                                                   {{{1
    #
    # does:   write manifest.appcache file
    # params: nil
    # prints: nil, except error messages
    # return: n/a, dies on failure
    method _write_cache () {
        my $file = 'manifest.appcache';
        if ( -f $file ) {
            say "File '$file' already exists";
            return;
        }
        my @content = (
            q{CACHE MANIFEST},
            q{},
            q{# 2015-09-13 rev 2},
            q{},
            q{CACHE:},
            q{http://code.jquery.com/mobile/1.4.5/jquery.mobile-1.4.5.min.css},
            q{http://code.jquery.com/jquery-2.1.4.min.js},
            q{http://code.jquery.com/mobile/1.4.5/jquery.mobile-1.4.5.min.js},
        );

        #    q{http://code.jquery.com/jquery-2.1.4.min.js},
        return $cp->write_file( $file, [@content] );
    }    #                                                             }}}1

}

my $p = Dn::FestivalPlanner->new_with_options->main;

# POD                                                                  {{{1

__END__

=head1 NAME

dn-festival-planner - store festival data and write it to an html file

=head1 USAGE

B<dn-festival-planner > [ B<-s> I<file> ] [ B<-l> ] [ B<-w> ]

B<dn-festival-planner -h>

=head1 OPTIONS

=over

=item B<-s> I<file>

Path to data store. Can be relative or absolute.

Optional. Default: F<festival.data>.

=item B<-l>

List events and exit. Boolean.

Optional. Default: false.

=item B<-w>

Write output files and exit. Boolean.

Optional. Default: false.

=item B<-h>

Display help and exit.

=back

=head1 DESCRIPTION

Used to store details of festival events (or, indeed, events for any multi-day event). The script was originally developed for recording details of various events at the Royal Sydney Easter Show.

The user is required to enter the festival name. It serves as the title of the html output page.

=head2 Event details

Each event is assumed to begin and end during a single day.

For each event the following details are recorded:

=over

=over

=item I<Date>

The day on which the event occurs.

It is assumed all events start and finish within a single day, that is, there are no events spread over multiple days.

For each event the user is presented with a list of dates for which events have already been defined. The most recently used date will be pre-selected. If the user wants to use a new date they simply exit the menu.

ISO format. Required.

=item I<Start time>

Time the event begins.

The time can be in 'HHMM' format, in which leading zeroes must be entered, or 'HH:MM' format, in which leading zeroes can be dropped.

Optional.

=item I<End time>

Time the event ends.

The time can be in 'HHMM' format, in which leading zeroes must be entered, or 'HH:MM' format, in which leading zeroes can be dropped.

Optional.

=item I<Name>

Event name or title.

For each event the user is presented with a list of event names that have already been defined. The most recently used event name will be pre-selected. If the user wants to enter a new name they simply exit the menu.

Required.

=item I<Location>

Location at which event is held.

The user is provided with assistance to enter the event location. If the event name has been entered previously, the user is presented with a list of locations at which that event has previously been held. If the most recently entered location is in that list, it is pre-selected. If the user exits that menu without selecting a location, they are then presented with a list of I<all> previously entered locations (if there are any). If the user exits that menu without selecting a location, they are able to enter the location manually.

Required.

=back

=back

On exiting data is saved to a persistent data store (default: F<festival.data>) if data has been added or edited. When the script is next run the data is loaded from that data store. Note that a different file name can be used (see the I<-s> option).

Entered event details can be edited and entire events can be deleted.

=head2 Main menu options

The following options are available from the main menu:

=over

=over

=item I<Add events>

This option enables the user to enter new events. For date, name and location the user is able to select from previously entered values. If none is suitable the user can enter a new value.

=item I<Change festival name>

The user can edit the festival name.

=item I<List events>

Displays existing events in the terminal. Date and time are formatted such that their column widths are constant.

=item I<Edit events>

Enables the user to select existing events in turn and change any of their details.

=item I<Delete events>

Enables the user to select existing events in turn and delete them.

=item I<Write output files>

Writes the following output files to the current directory:

=over

=over

=item F<index.html>

HTML file displaying festival details. It is optimised for small screen devices.

=item F<.htaccess> and F<manifest.appcache>

Ensure caching of jquery libraries loaded by F<index.html>.

=item F<favicon.png>

An icon that can be used by operating systems to represent the web page. The provided icon is for the Sydney Royal Easter Show. It can be replaced with an appropriate 32x32 png file.

=back

=back

=item I<Rename events>

Enables the user to select an event name and change it. This should be used with caution as every event with this name will be renamed.

=item I<Rename locations>

Enables the user to select locations in turn and change them. This should be used with caution as a location will be changed in every event having that location, regardless of event names, i.e., different events occurring at that location will all have their location changed.

=item I<Save data>

Save existing data to the data store. This option should not be required as data is automatically saved on exit from the script if it has changed.

=back

=back

=head1 DEPENDENCIES

=head2 Perl modules

autodie, Carp, Date::Simple, Dn::Common, Dn::Menu, English, experimental, Function::Parameters, HTML::Template, List::MoreUtils, Moo, MooX::HandlesVia, MooX::Options, namespace::clean, Readonly, Storable, strictures, Time::Simple, Types::Standard, version.

=head1 BUGS AND LIMITATIONS

Please report any bugs to the author.

=head1 AUTHOR

David Nebauer E<lt>davidnebauer@hotkey.net.auE<gt>

=head1 LICENSE AND COPYRIGHT

Copyright (c) 2015 David Nebauer E<lt>davidnebauer@hotkey.net.auE<gt>

This script is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

=cut

# vim:fdm=marker:
