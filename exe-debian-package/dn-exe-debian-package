#!/usr/bin/perl

use Moo;
use strictures 2;
use 5.036_001;
use version; our $VERSION = qv('0.1');

{

  package Dn::Internal;

  use Moo;
  use strictures 2;
  use namespace::clean -except => [ '_options_data', '_options_config' ];
  use Carp qw(croak confess);
  use Const::Fast;
  use MooX::Options;
  use Types::Standard qw(Str);

  with qw(Role::Utils::Dn);

  const my $TRUE  => 1;
  const my $FALSE => 0;

  option 'exe' => (
    is            => 'ro',
    format        => 's',
    required      => $TRUE,
    short         => 'e',
    order         => 1,
    documentation => 'Executable name',
  );

  has '_exe_filepath' => (
    is            => 'rw',
    isa           => Str,
    required      => $FALSE,
    documentation => 'File from which module loaded',
  );

  has '_debian_package' => (
    is            => 'rw',
    isa           => Str,
    required      => $FALSE,
    documentation => 'Debian package providing module',
  );

  # _get_exe_filepath()
  #
  # does:   get path of file
  # params: nil
  # prints: nil
  # return: scalar file path
  sub _get_exe_filepath ($self)
  {    ## no critic (RequireInterpolationOfMetachars)
    my $exe  = $self->exe;
    my $path = $self->path_executable($exe);
    return $self->_exe_filepath($self->path_true($path));
  }

  # _get_debian_package()
  #
  # does:   get file loaded for module
  # params: nil
  # prints: nil
  # return: scalar file path
  sub _get_debian_package ($self)
  {    ## no critic (RequireInterpolationOfMetachars)

    # assemble dpkg command
    my $exe_path = $self->_exe_filepath;
    my $cmd      = [ 'dpkg', '-S', $exe_path ];

    # run dpkg command
    my $result = $self->shell_command($cmd);

    # croak if command fails...
    if (not $result->success) {
      my $err_msg;
      if ($result->has_stderr) {
        my $stderr = join "\n", $result->stderr;
        $err_msg = $stderr;
      }
      else {
        my $cmd_str = join q{ }, @{$cmd};
        $err_msg = "Command '$cmd_str' failed";
      }
      confess $err_msg;
    }

    # ...or output is invalid
    my @output = $result->stdout;
    if (not @output) { exit; }    # error already displayed
    if (scalar @output != 1) {
      my $msg = q{Unexpected output '} . join q{|}, @output . q{'};
      croak $msg;
    }

    # provide deb package name
    my $debian_package = (split /:/xsm, $output[0])[0];
    return $self->_debian_package($debian_package);
  }

  # _provide_feedback()
  #
  # does:   provide feedback to user
  # params: nil
  # prints: feedback
  # return: n/a
  sub _provide_feedback ($self)
  {    ## no critic (RequireInterpolationOfMetachars)
    say 'Executable name:     ' . $self->exe             or croak;
    say 'Executable filepath: ' . $self->_exe_filepath   or croak;
    say 'Debian package:      ' . $self->_debian_package or croak;

    return $TRUE;
  }

  #   main()
  #
  #   does:   main method
  #   params: nil
  #   prints: feedback
  #   return: result
  sub main ($self) {    ## no critic (RequireInterpolationOfMetachars)
    $self->_get_exe_filepath();
    $self->_get_debian_package();
    $self->_provide_feedback();

    return $TRUE;
  }
}

# MAIN PACKAGE

my $p = Dn::Internal->new_with_options->main;

1;

# POD

## no critic (RequirePodSections)

__END__

=head1 NAME

dn-exe-debian-package - find debian package providing executable

=head1 USAGE

B<dn-exe-debian-package > -e executable

B<dn-exe-debian-package -h>

=head1 OPTIONS

=over

=item B<-e> executable

The executable to analyse.

Required.

=item B<-h>

Display help and exit.

=back

=head1 DESCRIPTION

Finds the true path of an executable and finds the debian package providing that file.

=head1 DEPENDENCIES

Carp, Const::Fast, Moo, MooX::Options, namespace::clean, Role::Utils::Dn,
strictures, Types::Standard, version.

=head1 BUGS AND LIMITATIONS

Please report any bugs to the author.

=head1 AUTHOR

David Nebauer E<lt>davidnebauer@hotkey.net.auE<gt>

=head1 LICENSE AND COPYRIGHT

Copyright (c) 2015 David Nebauer E<lt>david at nebauer dot orgE<gt>

This script is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

=cut

