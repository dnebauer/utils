#!/usr/bin/perl

use Moo;                                  #     {{{1
use strictures 2;
use 5.036_002;
use version; our $VERSION = qv('0.2');    #     }}}1

{    # package: Dn::Pair    {{{1

  package Dn::Pair;

  use Moo;
  use strictures 2;
  use namespace::clean;
  use Const::Fast;
  use Types::Standard;

  const my $TRUE  => 1;
  const my $FALSE => 0;

  has 'current' => (
    is            => 'ro',
    isa           => Types::Standard::Str,
    required      => $TRUE,
    documentation => 'Existing file name',
  );

  has 'rename' => (
    is            => 'rw',
    isa           => Types::Standard::Str,
    required      => $TRUE,
    documentation => 'New file name',
  );

}    #     }}}1

{

  package Dn::Internal;    ## no critic (ProhibitMultiplePackages)

  # modules    {{{1
  use Moo;
  use strictures 2;
  use namespace::clean;
  use Carp qw(croak confess);
  use Const::Fast;
  use Dn::Common;
  use English qw(-no_match_vars);
  use File::Copy;
  use MooX::HandlesVia;
  use MooX::Options;
  use Text::Unaccent;
  use Types::Standard;

  with qw(Role::Utils::Dn);

  const my $TRUE               => 1;
  const my $FALSE              => 0;
  const my $ERR_NO_FNAME_PAIRS => 'No file name pairs';
  const my $STAR               => q{*};
  const my $UNDERSCORE         => q{_};                   #     }}}1

  # options

  # artist    {{{1
  option 'artist' => (
    is            => 'ro',
    format        => 's',
    required      => $TRUE,
    short         => 'a',
    documentation => 'Artist name',
  );    #     }}}1

  # _name_pairs, _add_name_pair    {{{1
  has '_new_names_list' => (
    is  => 'rw',
    isa => Types::Standard::ArrayRef [
      Types::Standard::InstanceOf ['Dn::Pair'],
    ],
    lazy        => $TRUE,
    default     => sub { [] },
    handles_via => 'Array',
    handles     => {
      _name_pairs    => 'elements',
      _add_name_pair => 'push',
    },
    documentation => 'Old name - new name pairs',
  );    #     }}}1

  # methods

  # main()    {{{1
  #
  #   does:   main method
  #   params: nil
  #   prints: feedback
  #   return: result
  sub main ($self) {    ## no critic (RequireInterpolationOfMetachars)

    # get mp3 file names
    my @files = sort glob '*.mp3';
    if (not @files) { die "No mp3 files\n"; }

    # create new file names
    $self->_create_new_file_names([@files]);

    # display new file names
    $self->_display_file_names();

    # user can edit new names
    if ($self->input_confirm('Edit file names?')) {
      $self->_edit_file_names();
    }

    # user can abort
    if (not $self->input_confirm('Rename files?')) {
      say 'Ok' or croak;
      exit;
    }

    # rename files
    $self->_rename_files();

    say 'Done' or croak;

    return;
  }

  # _create_new_file_names($files_ref)    {{{1
  #
  #   does:   creates new file names
  #   params: $files - array reference of file names
  #   prints: warning if fail
  #   return: n/a, dies on failure
  sub _create_new_file_names ($self, $files_ref)
  {    ## no critic (RequireInterpolationOfMetachars)

    # check files list
    if (not $files_ref)            { confess 'No files reference provided'; }
    if (ref $files_ref ne 'ARRAY') { confess 'Not an arrayref'; }
    my @files = @{$files_ref};
    if (not @files) { confess 'No files in reference'; }

    # need artist
    if (not $self->artist) { confess 'No artist found'; }
    my $artist = $self->artist;

    # get new names
    foreach my $file (@files) {
      my $new = $self->_convert_filename($artist, $file);
      if (not $new) { die "Unable to convert '$file'\n"; }
      my $pair = Dn::Pair->new(current => $file, rename => $new);
      $self->_add_name_pair($pair);
    }

    return $TRUE;
  }

  # _convert_filename($artist, $file)    {{{1
  #
  # does:   convert filename to new format
  # params: $artist - artist name [required]
  #         $file   - name of file to be renamed [required]
  # return: scalar string
  # note:   assumes all files have extension 'mp3'
  # detail: converts artist and track name, then constructs:
  #         'ARTIST_XX_TRACKNAME.mp3' where 'XX' is the track number
  sub _convert_filename ($self, $artist, $file)
  {    ## no critic (RequireInterpolationOfMetachars)
    if (not($artist and $file)) {
      confess 'Did not get both artist and file';
    }

    my $original_file = $file;

    #say $original_file;

    # escape problematic characters
    #$file =~ s/\(/\(/gxsm;
    #$file =~ s/\)/\)/gxsm;
    #$file =~ s/\+/\+/gxsm;
    #$file =~ s/\,/\,/gxsm;

    my $ext = '.mp3';

    # extract parts of file name
    my ($number, $name) = $file =~ /^ ( \d+ ) [.] ( \p{Any}+? ) $ext $/xsm;
    if (not($number and $name)) {
      say 'Error extracting name and number '
          . "from file name '$original_file'"
          or croak;
      if   ($name) { say "Name: $name"            or croak; }
      else         { say 'Could not extract name' or croak; }
      if   ($number) { say "Number $number"           or croak; }
      else           { say 'Could not extract number' or croak; }
      die "Aborting\n";
    }

    # build new file name
    my $converted_artist = $self->_convert_string($artist);
    if (not $converted_artist) {
      die "Unable to convert artist '$artist'\n";
    }
    my $converted_name = $self->_convert_string($name);
    if (not $converted_name) {
      die "Unable to convert track name part '$name' "
          . "of file name '$original_file'\n";
    }
    my $rename =
          $converted_artist
        . $UNDERSCORE
        . $number
        . $UNDERSCORE
        . $converted_name
        . $ext;

    #say "--> $rename";
    return $rename;
  }

  # _convert_string($string)    {{{1
  #
  # does:   convert string to new format
  # detail: converts to lower case, converts spaces and underscores
  #         to dashes, and removes anything but alphanumerics and dashes
  # params: $string - string to be altered [required]
  # return: scalar string
  # note:   why 'a-z' is used in substitution:
  sub _convert_string ($self, $string)
  {    ## no critic (RequireInterpolationOfMetachars)
    if (not $string) { return q{}; }
    $string = lc $string;         # to lower case
    $string =~ s/[_ ]/-/gxsmg;    # spaces and underscores to dashes
    $string =~ s/&/and/gxsmg;     # will lose ampersands, so convert

 # must use 'a-z' in next operation to strip all *fancy* characters:
 # - although use of 'a-z' in regular expression is frowned upon by PBP,
 #   replacing with '\p{Lowercase}', '\p{Lowercase_Letter}' or '[:lower:]'
 #   results in strange behaviour with input string 'Ah,_non_piÃ¹!'
 # - after stripping the fancy characters the string has an invisible final
 #   character that "swallows" any character that is appended to it, and which
 #   is reported by the 'ord' function as having an ascii or unicode numeric
 #   value of 227, and which is fatal to the 'unac_string' function, causing
 #   it to report an error and return 'undef'
    $string =~ s/[^a-z\d-]//gxsmg;    ## no critic (ProhibitEnumeratedClasses)
    $string =~ s/-+/-/gxsmg;    # stripping can cause multiple dash sequences
    $string = Text::Unaccent::unac_string('UTF-8', $string);
    return $string;
  }

  # _display_file_names()    {{{1
  #
  #   does:   display current file names with new names
  #   params: nil
  #   prints: warning if fail
  #   return: n/a, dies on failure
  sub _display_file_names ($self)
  {    ## no critic (RequireInterpolationOfMetachars)

    # must have file name pairs
    if (not $self->_name_pairs) { confess $ERR_NO_FNAME_PAIRS; }

    # give user feedback
    my @unwrapped;
    push @unwrapped, 'Listing files with proposed new names:';
    push @unwrapped, $STAR;

    # cycle through pairs creating (unwrapped) output
    foreach my $pair ($self->_name_pairs) {
      push @unwrapped, $pair->current;
      push @unwrapped, '  --> ' . $pair->rename;
    }
    push @unwrapped, $STAR;

    # wrap output
    my @output = $self->wrap_text(
      [@unwrapped],
      hang  => 6,
      break => [ q{-}, $UNDERSCORE ],
    );

    # display wrapped output
    $self->pager([@output], 'more');

    return;
  }

  # _edit_file_names()    {{{1
  #
  #   does:   user can edit new file names
  #   params: nil
  #   prints: warning if fail
  #   return: n/a, dies on failure
  sub _edit_file_names ($self)
  {    ## no critic (RequireInterpolationOfMetachars)

    # must have file name pairs
    if (not $self->_name_pairs) { confess $ERR_NO_FNAME_PAIRS; }

    # cycle through pairs asking user for new file names
    foreach my $pair ($self->_name_pairs) {
      my $current = $pair->current;
      my $new     = $pair->rename;
      say "\nCurrent file name: $current" or croak;
      my $edit = $self->interact_ask('New file name:', $new);
      if (not $edit) { die "Cannot have empty file name\n"; }
      if ($edit eq $new) {
        say 'Not changed' or croak;
      }
      else {
        say 'Changed new file name' or croak;
        $pair->rename($edit);
      }
    }
    say q{} or croak;

    return;
  }

  # _rename_files()    {{{1
  #
  #   does:   rename files
  #   params: nil
  #   prints: warning if fail
  #   return: n/a, dies on failure
  sub _rename_files ($self) {   ## no critic (RequireInterpolationOfMetachars)

    # must have file name pairs
    if (not $self->_name_pairs) { confess $ERR_NO_FNAME_PAIRS; }

    # cycle through pairs renaming the files
    foreach my $pair ($self->_name_pairs) {
      my $file = $pair->current;
      my $new  = $pair->rename;

      if (not($file and -e $file)) {
        warn "Invalid file '$file'\n";
        return;
      }

      if (!eval { File::Copy::mv($file, $new); 1 }) {
        warn "Failed renaming '$file' to '$new':\n";
        warn "  $EVAL_ERROR\n";
      }
    }
    return;
  }    #     }}}1

}

my $p = Dn::Internal->new_with_options->main;

1;

#     {{{1

## no critic (RequirePodSections)

__END__

=head1 NAME

dn-abcde-rename - renames mp3 files generated by abcde

=head1 USAGE

B<dn-abcde-rename> -a I<artist>

=head1 OPTIONS

=over

=item -a

Artist name. String. Required.

=item -h

Display help and exit.

=back

=head1 DESCRIPTION

The utility 'abcde' rips cds to disc. The default file name is of the format:

	01.Song_Name.mp3

This script renames all files in the current directory to:

	artist-name_track-number_song-name.mp3

Note conversion to lowercase. All characters that are not alphanumerics, spaces
or dashes are removed.

The artist name must be provided as a parameter. It is safest to enclose it in
quotes.

=head1 DEPENDENCIES

=head2 Perl modules

Carp, Const::Fast, English, File::Copy, Moo, MooX::HandlesVia, MooX::Options,
namespace::clean, Role::Utils::Dn, strictures, Text::Unaccent, Types::Standard,
version.

=head1 BUGS AND LIMITATIONS

Please report any bugs to the author.

=head1 AUTHOR

David Nebauer E<lt>davidnebauer@hotkey.net.auE<gt>

=head1 LICENSE AND COPYRIGHT

Copyright (c) 2015 David Nebauer E<lt>davidnebauer@hotkey.net.auE<gt>

This script is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

=cut
# vim:fdm=marker
