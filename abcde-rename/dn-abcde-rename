#!/usr/bin/perl 

use Moo;    #                                                          {{{1
use strictures 2;
use 5.014_002;
use version; our $VERSION = qv('0.1');    #                            }}}1

{

    package Dn::Pair;    #                                             {{{1

    use Moo;
    use strictures 2;
    use namespace::clean;
    use Readonly;
    use Types::Standard;

    Readonly my $TRUE  => 1;
    Readonly my $FALSE => 0;    #                                      }}}1

    # current                                                          {{{1
    has 'current' => (
        is            => 'ro',
        isa           => Types::Standard::Str,
        required      => $TRUE,
        documentation => 'Existing file name',
    );

    # rename                                                           {{{1
    has 'rename' => (
        is            => 'rw',
        isa           => Types::Standard::Str,
        required      => $TRUE,
        documentation => 'New file name',
    );    #                                                            }}}1

}

{

    package Dn::Internal;    #                                         {{{1

    use Moo;
    use strictures 2;
    use namespace::clean;
    use Carp qw(confess);
    use Dn::Common;
    use English qw(-no_match_vars);
    use File::Copy qw(mv);
    use Function::Parameters;
    use MooX::HandlesVia;
    use MooX::Options;
    use Readonly;
    use Text::Unaccent;
    use Types::Standard;

    use Data::Dumper::Simple;

    my $cp = Dn::Common->new();
    Readonly my $TRUE  => 1;
    Readonly my $FALSE => 0;    #                                      }}}1

    # options

    # artist (-a)                                                      {{{1
    option 'artist' => (
        is            => 'ro',
        format        => 's',
        required      => $TRUE,
        short         => 'a',
        documentation => 'Artist name',
    );    #                                                            }}}1

    # _new_names_list                                                  {{{1
    has '_new_names_list' => (
        is  => 'rw',
        isa => Types::Standard::ArrayRef [
            Types::Standard::InstanceOf ['Dn::Pair']
        ],
        lazy        => $TRUE,
        default     => sub { [] },
        handles_via => 'Array',
        handles     => {
            _name_pairs     => 'elements',
            _add_name_pair  => 'push',
        },
        documentation => 'Old name - new name pairs',
    );    #                                                            }}}1

    # methods

    #   main()                                                         {{{1
    #
    #   does:   main method
    #   params: nil
    #   prints: feedback
    #   return: result
    method main () {

        # get mp3 file names
        my @files = sort glob '*.mp3';
        if ( not @files ) { die "No mp3 files\n"; }

        # create new file names
        $self->_create_new_file_names( [@files] );

        # display new file names
        $self->_display_file_names();

        # user can edit new names
        if ( $cp->input_confirm('Edit file names?') ) {
            $self->_edit_file_names();
        }

        # user can abort
        if ( not $cp->input_confirm('Rename files?') ) { say 'Ok'; exit; }

        # rename files
        $self->_rename_files();

        say 'Done';

        return;
    }

    #   _create_new_file_names($files)                                 {{{1
    #
    #   does:   creates new file names
    #   params: $files - array reference of file names
    #   prints: warning if fail
    #   return: n/a, dies on failure
    method _create_new_file_names ($files_ref) {

        # check files list
        if ( not $files_ref ) { confess 'No files reference provided'; }
        if ( ref $files_ref ne 'ARRAY' ) { confess 'Not an arrayref'; }
        my @files = @{$files_ref};
        if ( not @files ) { confess 'No files in reference'; }

        # need artist
        if ( not $self->artist ) { confess 'No artist found'; }
        my $artist = $self->artist;

        # get new names
        foreach my $file (@files) {
            my $new = $self->_convert_filename( $artist, $file );
            if ( not $new ) { die "Unable to convert '$file'\n"; }
            my $pair = Dn::Pair->new( current => $file, rename => $new );
            $self->_add_name_pair($pair);
        }
    }

    # _convert_filename()                                              {{{1
    #
    # does:   convert filename to new format
    # params: $artist - artist name [required]
    #         $file   - name of file to be renamed [required]
    # return: scalar string
    # note:   assumes all files have extension 'mp3'
    # detail: converts artist and track name, then constructs:
    #         'ARTIST_XX_TRACKNAME.mp3' where 'XX' is the track number
    method _convert_filename ($artist, $file) {
        if ( not( $artist and $file ) ) {
            confess 'Did not get both artist and file';
        }

        # escape problematic characters
        my $original_file = $file;

        #say $original_file;

        #$file =~ s/\(/\(/gxsm;
        #$file =~ s/\)/\)/gxsm;
        #$file =~ s/\+/\+/gxsm;
        #$file =~ s/\,/\,/gxsm;
        my $ext = '.mp3';

        # extract parts of file name
        my ( $number, $name )
            = $file =~ /^ ( \d+ ) [.] ( \p{Any}+? ) $ext $/xsm;
        if ( not( $number and $name ) ) {
            say "Error extracting name and number "
                . "from file name '$original_file'";
            if   ($name) { say "Name: $name"; }
            else         { say 'Could not extract name'; }
            if   ($number) { say "Number $number"; }
            else           { say 'Could not extract number'; }
            die "Aborting\n";
        }

        # build new file name
        my $converted_artist = $self->_convert_string($artist);
        if ( not $converted_artist ) {
            die "Unable to convert artist '$artist'\n";
        }
        my $converted_name = $self->_convert_string($name);
        if ( not $converted_name ) {
            die "Unable to convert track name part '$name' "
                . "of file name '$original_file'\n";
        }
        my $rename
            = $converted_artist . q{_}
            . $number . q{_}
            . $converted_name
            . $ext;

        #say "--> $rename";
        return $rename;
    }

    # _convert_string($string)                                         {{{1
    #
    # does:   convert string to new format
    # detail: converts to lower case, converts spaces and underscores
    #         to dashes, and removes anything but alphanumerics and dashes
    # params: $string - string to be altered [required]
    # return: scalar string
    # note:   why 'a-z' is used in substitution:
    #         although use of 'a-z' in regular expression is frowned upon
    #         by PBP, replacing with '\p{Lowercase}',
    #         '\p{Lowercase_Letter}' or '[:lower:]' results in strange
    #         behaviour with input string 'Ah,_non_piÃ¹!' -- after stripping
    #         stripping the fancy characters the string has an invisible
    #         final character that "swallows" any character that is
    #         appended to it, and which is reported by the 'ord' function
    #         as having an ascii or unicode numeric value of 227, and which
    #         is fatal to the 'unac_string' function, causing it to report
    #         an error and return 'undef'
    method _convert_string ($string) {
        if ( not $string ) { return q{}; }
        $string = lc $string;          # to lower case
        $string =~ s/[_ ]/-/gxsmg;     # spaces and underscores to dashes
        $string =~ s/&/and/gxsmg;      # will lose ampersands, so convert

        # must use 'a-z' in next operation - see notes above
        $string =~ s/[^a-z\d-]//gxsmg;    # strip all *fancy* characters
        $string =~ s/-+/-/gxsmg; # stripping can cause multiple dash sequences
        $string = Text::Unaccent::unac_string( 'UTF-8', $string );
        return $string;
    }

    #   _display_file_names()                                          {{{1
    #
    #   does:   display current file names with new names
    #   params: nil
    #   prints: warning if fail
    #   return: n/a, dies on failure
    method _display_file_names () {

        # must have file name pairs
        if ( not $self->_name_pairs ) { confess 'No file name pairs'; }

        # give user feedback
        my @unwrapped;
        push @unwrapped, 'Listing files with proposed new names:';
        push @unwrapped, '*';

        # cycle through pairs creating (unwrapped) output
        foreach my $pair ( $self->_name_pairs ) {
            push @unwrapped, $pair->current;
            push @unwrapped, '  --> ' . $pair->rename;
        }
        push @unwrapped, '*';

        # wrap output
        my @output
            = $cp->do_wrap( [@unwrapped], hang => 6, break => [ '-', '_' ] );

        # display wrapped output
        $cp->pager( [@output], 'more' );

        return;
    }

    #   _edit_file_names()                                             {{{1
    #
    #   does:   user can edit new file names
    #   params: nil
    #   prints: warning if fail
    #   return: n/a, dies on failure
    method _edit_file_names () {

        # must have file name pairs
        if ( not $self->_name_pairs ) { confess 'No file name pairs'; }

        # cycle through pairs asking user for new file names
        foreach my $pair ( $self->_name_pairs ) {
            my $current = $pair->current;
            my $new     = $pair->rename;
            say "\nCurrent file name: $current";
            my $edit = $cp->input_ask( 'New file name:', $new );
            if ( not $edit ) { die "Cannot have empty file name\n"; }
            if ( $edit eq $new ) {
                say 'Not changed';
            }
            else {
                say 'Changed new file name';
                $pair->rename($edit);
            }
        }
        say q{};

        return;
    }

    #   _rename_files()                                                {{{1
    #
    #   does:   rename files
    #   params: nil
    #   prints: warning if fail
    #   return: n/a, dies on failure
    method _rename_files () {

        # must have file name pairs
        if ( not $self->_name_pairs ) { confess 'No file name pairs'; }

        # cycle through pairs renaming the files
        foreach my $pair ( $self->_name_pairs ) {
            my $file = $pair->current;
            my $new  = $pair->rename;

            if ( not( $file and -f $file ) ) {
                warn "Invalid file '$file'\n";
                return;
            }

            if ( !eval { File::Copy::mv( $file, $new ); 1 } ) {
                warn "Failed renaming '$file' to '$new':\n";
                warn "  $EVAL_ERROR\n";
            }
        }
        return;
    }    #                                                             }}}1

}

my $p = Dn::Internal->new_with_options->main;

1;

# POD                                                                  {{{1
__END__

=head1 NAME

dn-abcde-rename - renames mp3 files generated by abcde

=head1 USAGE

B<dn-abcde-rename> -a I<artist>

=head1 OPTIONS

=over

=item -a

Artist name. String. Required.

=item -h

Display help and exit.

=back

=head1 DESCRIPTION

The utility 'abcde' rips cds to disc. The default file name is of the format:

	01.Song_Name.mp3

This script renames all files in the current directory to:

	artist-name_track-number_song-name.mp3

Note conversion to lowercase. All characters that are not alphanumerics, spaces or dashes are removed.

The artist name must be provided as a parameter. It is safest to enclose it in quotes.

=head1 DEPENDENCIES

=head2 Perl modules

Carp, Dn::Common, English, File::Copy, Function::Parameters, Moo, MooX::HandlesVia, MooX::Options, namespace::clean, Readonly, strictures, Text::Unaccent, Types::Standard, version.

=head1 BUGS AND LIMITATIONS

Please report any bugs to the author.

=head1 AUTHOR

David Nebauer E<lt>davidnebauer@hotkey.net.auE<gt>

=head1 LICENSE AND COPYRIGHT

Copyright (c) 2015 David Nebauer E<lt>davidnebauer@hotkey.net.auE<gt>

This script is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

=cut
# vim:fdm=marker
