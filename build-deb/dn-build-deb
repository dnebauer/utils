#!/usr/bin/env perl

use Moo;    # {{{1
use strictures 2;
use 5.006;
use 5.022_001;
use version; our $VERSION = qv('0.1');
use namespace::clean;    # }}}1

{

    package Dn::BuildDeb;

    use Moo;             # {{{1
    use strictures 2;
    use namespace::clean -except => [ '_options_data', '_options_config' ];
    use autodie qw(open close);
    use Archive::Tar;
    use Carp qw(confess croak);
    use Const::Fast;
    use Dpkg::Version;
    use Email::Date::Format;
    use Email::Valid;
    use English qw(-no_match_vars);
    use Feature::Compat::Try;
    use File::Basename;
    use File::chdir;
    use File::Copy::Recursive qw(dircopy);
    use File::Find::Rule;
    use File::Spec;
    use File::Path qw(make_path);
    use FindBin qw($Script);
    use Function::Parameters;
    use MooX::HandlesVia;
    use MooX::Options protect_argv => 0;
    use Path::Tiny;
    use Scalar::Util qw(blessed reftype);
    use Term::Clui;
    local $ENV{CLUI_DIR} = 'OFF';
    use Term::ReadKey;
    use Types::Standard;

    with qw(
        Dn::Role::HasPath
        Dn::Role::HasUserInteraction
    );

    const my $TRUE           => 1;
    const my $FALSE          => 0;
    const my $LESS_THAN      => -1;
    const my $EQUAL_TO       => 0;
    const my $TERM_MIN_WIDTH => 10;
    const my $TERM_GUTTER    => 5;
    Sys::Syslog::openlog( 'ident', 'user' );    # }}}1

    # debug
    use Data::Dumper::Simple;                   # }}}1

    # options

    # root_dir    (-r)    {{{1
    option 'root_dir' => (
        is       => 'ro',
        format   => 's@',
        required => $TRUE,
        short    => 'r',
        doc      => 'Root directory of project tree [required]',
    );

    # maint_name  (-n)    {{{1
    option 'maint_name' => (
        is       => 'ro',
        format   => 's@',
        required => $TRUE,
        short    => 'n',
        doc      => 'Name of package maintainer [required]',
    );

    # maint_email (-e)    {{{1
    option 'maint_email' => (
        is       => 'ro',
        format   => 's@',
        required => $TRUE,
        short    => 'e',
        doc      => 'Email of package maintainer [required]',
    );

    # pkg_name    (-p)    {{{1
    option 'pkg_name' => (
        is       => 'ro',
        format   => 's@',
        required => $TRUE,
        short    => 'p',
        doc      => 'Name of package [required]',
    );

    # template    (-t)    {{{1
    option 'template' => (
        is    => 'ro',
        short => 't',
        doc   => 'Create empty project template [optional]',
    );

    # dist_build  (-d)    {{{1
    option 'dist_build' => (
        is    => 'ro',
        short => 'd',
        doc   => 'Build from dist tarzip in debian source dir [optional]',
    );    # }}}1

    # attributes

    # _root_dir    {{{1
    has '_root_dir' => (
        is  => 'rw',
        isa => Types::Standard::Maybe [
            Types::Standard::InstanceOf ['Path::Tiny']
        ],
        default => undef,
        doc     => 'Project root directory',
    );

    # _maint_name    {{{1
    has '_maint_name' => (
        is      => 'rw',
        isa     => Types::Standard::Maybe [Types::Standard::Str],
        default => undef,
        doc     => 'Name of package maintainer',
    );

    # _maint_email    {{{1
    has '_maint_email' => (
        is      => 'rw',
        isa     => Types::Standard::Maybe [Types::Standard::Str],
        default => undef,
        doc     => 'Email address of package maintainer',
    );

    # _pkg_name    {{{1
    has '_pkg_name' => (
        is      => 'rw',
        isa     => Types::Standard::Maybe [Types::Standard::Str],
        default => undef,
        doc     => 'Name of package',
    );

    # _init_dir    {{{1
    has '_init_dir' => (
        is  => 'lazy',
        isa => Types::Standard::InstanceOf ['Path::Tiny'],
        doc => 'Directory in which script was executed',
    );

    method _build__init_dir () {

        # get string value of current directory
        my $dir_str = $self->dir_current;

        # create Path::Tiny object
        my $dir = Path::Tiny::path($dir_str)->absolute;

        return $dir;
    }

    # _tar_archive    {{{1
    has '_tar_archive' => (
        is  => 'rw',
        isa => Types::Standard::Maybe [
            Types::Standard::InstanceOf ['Path::Tiny']
        ],
        default => undef,
        doc     => 'Archive directory in autotools build tree',
    );

    # _tar_auto    {{{1
    has '_tar_auto' => (
        is  => 'rw',
        isa => Types::Standard::Maybe [
            Types::Standard::InstanceOf ['Path::Tiny']
        ],
        default => undef,
        doc     => 'Autotools directory in autotools build tree',
    );

    # _tar_build    {{{1
    has '_tar_build' => (
        is  => 'rw',
        isa => Types::Standard::Maybe [
            Types::Standard::InstanceOf ['Path::Tiny']
        ],
        default => undef,
        doc     => 'Build directory in autotools build tree',
    );

    # _tar_source    {{{1
    has '_tar_source' => (
        is  => 'rw',
        isa => Types::Standard::Maybe [
            Types::Standard::InstanceOf ['Path::Tiny']
        ],
        default => undef,
        doc     => 'Source directory in autotools build tree',
    );

    # _deb_debian    {{{1
    has '_deb_debian' => (
        is  => 'rw',
        isa => Types::Standard::Maybe [
            Types::Standard::InstanceOf ['Path::Tiny']
        ],
        default => undef,
        doc     => 'Debian files directory in debian build tree',
    );

    # _deb_scripts    {{{1
    has '_deb_scripts' => (
        is  => 'rw',
        isa => Types::Standard::Maybe [
            Types::Standard::InstanceOf ['Path::Tiny']
        ],
        default => undef,
        doc     => 'Scripts directory in debian build tree',
    );

    # _deb_source    {{{1
    has '_deb_source' => (
        is  => 'rw',
        isa => Types::Standard::Maybe [
            Types::Standard::InstanceOf ['Path::Tiny']
        ],
        default => undef,
        doc     => 'Source directory in debian build tree',
    );

    # _tar_prep    {{{1
    has '_tar_prep' => (
        is  => 'rw',
        isa => Types::Standard::Maybe [
            Types::Standard::InstanceOf ['Path::Tiny']
        ],
        default => undef,
        doc     => 'Bash file run to prepare tarbuild directory files',
    );

    # _deb_prep    {{{1
    has '_deb_prep' => (
        is  => 'rw',
        isa => Types::Standard::Maybe [
            Types::Standard::InstanceOf ['Path::Tiny']
        ],
        default => undef,
        doc     => 'Bash file run to prepare debian directory files',
    );

    # _wrapper    {{{1
    has '_wrapper' => (
        is  => 'rw',
        isa => Types::Standard::Maybe [
            Types::Standard::InstanceOf ['Path::Tiny']
        ],
        default => undef,
        doc     => 'Wrapper for this script',
    );

    # _tar_auto_conf_ac    {{{1
    has '_tar_auto_conf_ac' => (
        is  => 'rw',
        isa => Types::Standard::Maybe [
            Types::Standard::InstanceOf ['Path::Tiny']
        ],
        default => undef,
        doc     => 'configure.ac file in tarball/autotools directory',
    );

    # _tar_auto_conf_ac_regex    {{{1
    has '_tar_auto_conf_ac_regex' => (
        is      => 'rw',
        isa     => Types::Standard::Maybe [Types::Standard::RegexpRef],
        default => undef,
        doc     => 'Regex finding version in configure.ac file',
    );

    # [_set]_conf_ac_part    {{{1
    has '_tar_auto_conf_ac_parts' => (
        is          => 'rw',
        isa         => Types::Standard::HashRef [Types::Standard::Str],
        lazy        => $TRUE,
        default     => sub { {} },
        handles_via => 'Hash',
        handles     => {
            _set_conf_ac_part    => 'set',       # ($x => 'part')
            _conf_ac_part_exists => 'exists',    # ($x) -> bool
            _conf_ac_part        => 'get',       # ($x) -> 'part'
        },
        doc => 'Parts of configure.ac file',
    );

    # _deb_debian_changelog    {{{1
    has '_deb_debian_changelog' => (
        is  => 'rw',
        isa => Types::Standard::Maybe [
            Types::Standard::InstanceOf ['Path::Tiny']
        ],
        default => undef,
        doc     => 'changelog file in debianise/debian directory',
    );

    # _deb_debian_changelog_regex    {{{1
    has '_deb_debian_changelog_regex' => (
        is      => 'rw',
        isa     => Types::Standard::Maybe [Types::Standard::RegexpRef],
        default => undef,
        doc     => 'Regex finding version in changelog file',
    );

    # [_set]_changelog_part    {{{1
    has '_deb_debian_changelog_parts' => (
        is          => 'rw',
        isa         => Types::Standard::HashRef [Types::Standard::Str],
        lazy        => $TRUE,
        default     => sub { {} },
        handles_via => 'Hash',
        handles     => {
            _set_changelog_part    => 'set',       # ($x => 'part')
            _changelog_part_exists => 'exists',    # ($x) -> bool
            _changelog_part        => 'get',       # ($x) -> 'part'
        },
        doc => 'Parts of changelog file',
    );

    # _tar_conf    {{{1
    has '_tar_conf' => (
        is  => 'rw',
        isa => Types::Standard::Maybe [
            Types::Standard::InstanceOf ['Path::Tiny']
        ],
        default => undef,
        doc     => 'configure file in tarball/build directory',
    );

    # _deb_pkg    {{{1
    has '_deb_pkg' => (
        is  => 'rw',
        isa => Types::Standard::Maybe [
            Types::Standard::InstanceOf ['Path::Tiny']
        ],
        default => undef,
        doc     => 'Package (*.deb) file in debianise/source directory',
    );

    # _project_dirs, _add_project_dirs    {{{1
    has '_project_dirs_list' => (
        is  => 'rw',
        isa => Types::Standard::ArrayRef [
            Types::Standard::InstanceOf ['Path::Tiny']
        ],
        default     => sub { [] },
        handles_via => 'Array',
        handles     => {
            _project_dirs     => 'elements',
            _add_project_dirs => 'push',
            _has_project_dirs => 'count',
        },
        doc => 'Directories required for standard autotools projects',
    );

    # _divider    {{{1
    has '_divider' => (
        is      => 'rw',
        isa     => Types::Standard::Maybe [Types::Standard::Str],
        default => undef,
        doc     => 'Divider consisting of dashes',
    );    # }}}1

    # methods

    # main()    {{{1
    #
    # does:   main method
    # params: nil
    # prints: feedback
    # return: n/a, dies on failure
    method main () {

        # set attributes
        $self->_set_attributes;

        # create template if requested
        if ( $self->template ) {
            $self->_create_template;
            return;
        }

        # build distribution tarball
        if ( $self->dist_build ) {
            say 'Got -d flag: skipping build step, expect single tarball'
                or croak;
        }
        else {
            $self->_build_tarball;
        }

        # debianise source
        $self->_debianise;

        # install file (currently disabled by design)
        #$self->_install_package;

        return;
    }

    # _attr_root()    {{{1
    #
    # does:   create Path::Tiny object for project root directory
    # params: nil
    # prints: feedback on error
    # return: n/a, dies on failure
    method _attr_root () {
        my $root_dir;
        my @root_dirs = @{ $self->root_dir };
        if   (@root_dirs) { $root_dir = $root_dirs[0]; }
        else              { die "No project root directory provided\n"; }
        my $dir = Path::Tiny::path($root_dir)->realpath;
        die "Project root '$root_dir' is not a directory\n"
            if not $dir->is_dir;

        return $dir;
    }

    # _attr_string($opt)    {{{1
    #
    # does:  extract string value for attribute from option
    # params: $opt - array reference, should hold one value [required]
    # prints: nil
    # return: boolean, whether non-empty string extracted
    method _attr_string ($opt) {
        my $attr;
        my @attrs = @{$opt};
        if (@attrs) { $attr = $attrs[0]; }

        return $attr;
    }

    # _attr_dir(@parts)    {{{1
    #
    # does:   create Path::Tiny object for directory relative to project root
    # params: @parts - list of directory parts [required]
    # prints: feedback on error
    # return: n/a, dies on failure
    method _attr_dir (@parts) {
        my $root    = $self->_root_dir->canonpath;
        my $dir_str = $self->dir_join( $root, @parts );
        my $dir     = Path::Tiny::path($dir_str)->absolute;

        return $dir;
    }

    # _attr_fp(@parts)    {{{1
    #
    # does:   create Path::Tiny object for filepath relative to project root
    # params: @parts - list of filepath parts [required]
    # prints: feedback on error
    # return: n/a, dies on failure
    method _attr_fp (@parts) {
        my $root   = $self->_root_dir->canonpath;
        my $fp_str = $self->path_join( $root, @parts );
        my $fp     = Path::Tiny::path($fp_str)->absolute;

        return $fp;
    }

    # _build_tarball()    {{{1
    #
    # does:   build distribution tarball in tarball/build
    # params: nil
    # prints: feedback
    # return: n/a, dies on failure
    method _build_tarball () {

        # change package version if desired    {{{2
        $self->_bump_package_version;

        # delete contents of build directory    {{{2
        my $tar_build = $self->_tar_build;
        $self->_dir_clean( $tar_build->canonpath );

        # copy contents of autotools and source to build    {{{2
        my @dirs = ( $self->_tar_auto, $self->_tar_source );
        for my $dir (@dirs) {
            File::Copy::Recursive::dircopy( $dir->canonpath,
                $tar_build->canonpath )
                or die "Unable to copy into build directory: $ERRNO\n";
        }

        # from now on, all commands are run in 'tarball/build'    {{{2
        # - Perl::Critic does not realise that $CWD is a package variable
        ## no critic (Variables::ProhibitLocalVars)
        local $CWD = $self->_tar_build->canonpath;
        ## use critic

        # run project-specific changes to project source    {{{2
        my $tar_prep = $self->_tar_prep;
        if ( $tar_prep->is_file ) {
            say q{Located a 'tar_dir_prepare' script} or croak;
            say 'Running it now...'                   or croak;
            {
                my @cmd = ( $tar_prep->canonpath );
                my $err = 'Script failed';
                $self->_run_cmd( $err, @cmd );
            }
        }

        # run 'autoreconf'    {{{2
        say 'Building distribution tarball' or croak;
        say q{..running 'autoreconf':}      or croak;
        {
            my @cmd = qw(autoreconf --install);
            my $err = 'autoreconf failed';
            $self->_run_cmd( $err, @cmd );
        }

        # escape special filename chars in configure    {{{2
        say q{..escape special filename characters in './configure'} or croak;

        my $conf = $self->_tar_conf;
        die "Cannot locate 'build/configure' file\n" if not $conf->is_file;
        $self->_escape_fname_chars_in_conf;

        # run './configure'    {{{2
        say q{..running './configure':} or croak;
        $conf->chmod('0744');
        {
            my @cmd = qw(./configure);
            my $err = './configure failed';
            $self->_run_cmd( $err, @cmd );
        }

        # run 'make dist'    {{{2
        say q{..running 'make dist':} or croak;
        {
            my @cmd = qw(make dist);
            my $err = 'make dist failed';
            $self->_run_cmd( $err, @cmd );
        }

        # copy tarball to tar/archive directory    {{{2
        say 'Archiving tarball' or croak;
        my $dist;
        {
            my @children  = $tar_build->children(qr/[.]tar[.]gz\z/xsm);
            my $kid_count = scalar @children;
            die "Expected 1 '.tar.gz' file, got $kid_count\n"
                if $kid_count != 1;
            $dist = $children[0];
            my $tar_archive = $self->_tar_archive;
            File::Copy::Recursive::fcopy( $dist->canonpath,
                $tar_archive->canonpath )
                or croak "Unable to archive tarball: $ERRNO";
        }

        # copy tarball to deb/source directory    {{{2
        say 'Copying tarball to debianise/source directory' or croak;
        {
            my $deb_source = $self->_deb_source;
            $self->_dir_clean( $deb_source->canonpath );
            File::Copy::Recursive::fcopy( $dist->canonpath,
                $deb_source->canonpath )
                or croak "Unable to copy tarball to deb source dir: $ERRNO";
        }

        return;    # }}}2

    }

    # _bump_package_version()    {{{1
    #
    # does:   update package version in tar_auto/configure.ac and
    #         deb_debian/changelog
    #
    # params: nil
    # prints: feedback
    # return: n/a, dies on failure
    method _bump_package_version () {

        # check existing version details    {{{2
        # - changelog version includes debian revision, but
        #   configure.ac version does not include debian revision
        my $conf_version   = $self->_conf_ac_part('version');
        my $change_version = $self->_changelog_part('version');
        if ( $conf_version and $change_version ) {
            if ( $conf_version ne ( split /-/xsm, $change_version )[0] ) {
                die "Version mismatch between configure.ac and changelog\n";
            }
        }
        else {
            if ( not $conf_version and not $change_version ) {
                die 'Unable to extract version from '
                    . "configure.ac and changelog\n";
            }
            elsif ( not $conf_version ) {
                die "Extracted version '$change_version' from changelog, "
                    . "but unable to extract version from configure.ac\n";
            }
            else {
                die "Extracted version '$conf_version' from configure.ac, "
                    . "but unable to extract version from changelog\n";
            }
        }
        my $version_current = Dpkg::Version->new($change_version);
        if ( not $version_current->is_valid ) {
            die "Help !Current version $conf_version is invalid!\n";
        }

        # get new version from user    {{{2
        say "Current package version: $version_current" or croak;
        my $prompt = 'Enter package version:';
        my $input  = Term::Clui::ask($prompt);
        if ( not $input ) {
            say 'Remaining at current version' or croak;
            return;
        }
        if ( not $input =~ /-/xsm ) { $input .= '-1'; }
        my $version_new = Dpkg::Version->new($input);
        if ( not $version_new->is_valid ) {
            die "Invalid version: $input\n";
        }
        my $compare = Dpkg::Version::version_compare( $version_new,
            $version_current );
        if ( $compare == $LESS_THAN ) {
            die "New version cannot be lower than current version\n";
        }
        if ( $compare == $EQUAL_TO ) {
            say 'Remaining at current version' or croak;
            return;
        }

        # bump version in configure.ac    {{{2
        my $conf_data
            = $self->_conf_ac_part('pre')
            . ( split /-/xsm, $version_new->as_string )[0]
            . $self->_conf_ac_part('post');
        my $conf_fp = $self->_tar_auto_conf_ac;
        $conf_fp->spew_utf8($conf_data);

        # bump version in changelog    {{{2
        my $date         = Email::Date::Format::email_date;
        my $changelog_fp = $self->_deb_debian_changelog;
        my $changelog_data
            = $self->_changelog_part('pkg') . ' ('
            . $version_new->as_string . ') '
            . $self->_changelog_part('release') . '; '
            . $self->_changelog_part('urgency')
            . "\n\n  * \n\n"
            . $self->_changelog_part('maint') . q{  }
            . $date . "\n\n"
            . $changelog_fp->slurp_utf8;
        $changelog_fp->spew_utf8($changelog_data);
        say 'Press any key to enter release notes...' or croak;
        Term::ReadKey::ReadMode 'cbreak';
        Term::ReadKey::ReadKey(0);
        Term::ReadKey::ReadMode 'normal';
        Term::Clui::edit( $changelog_fp->canonpath );    # }}}2

        return;
    }

    # _changelog_version_regex()    {{{1
    #
    # does:   provide regex for finding version in the
    #         debianise/debian-files/changelog file
    #
    # params: nil
    # prints: nil
    # return: scalar regex
    method _changelog_version_regex () {

        # assume first line of changelog file is well-formed, i.e., like:
        #   dn-cronsudo (2.1-2) UNRELEASED; urgency=low
        # so just assume first pair of parentheses encloses:
        #   package_version-debian_revision

        # building blocks
        my $any = qr/.*?/xsm;

        # in $any can't enclose '.' in a character class ('[.]')
        # because then it wouldn't match newlines
        # (see 'Metacharacters' section in 'perlre' manpage)
        # so need to disable related Perl::Critic warnings

        # first capture: package name

        my $pkg = qr{
            (?<pkg>    # first capture is package name
            \A\S+      # package name
            )          # close capture
            \s+        # followed by space
        }xsm;

        # second capture: version+revision

        ## no critic (ProhibitEscapedMetacharacters)
        my $version = qr{
            \(             # enclosed in parentheses
            (?<version>    # commence capture of version+revision
            [^\)]+         # version+revision
            )              # close second capture
            \)             # enclosed in parentheses
            \s+            # followed by space
        }xsm;
        ## use critic

        # third capture: release

        my $release = qr{
            (?<release>    # commence capture of release
            [^;]+          # release
            )              # close third capture
            ;\s+           # followed by semicolon and space
        }xsm;

        # fourth capture: urgency

        my $urgency = qr{
            (?<urgency>    # commence capture of urgency
            .*?$           # remainder of line
            )              # close fourth capture
            $any           # followed by any content
        }xsm;

        # fifth capture: maintainer

        my $maint = qr{
            (?<maint>    # commence capture of maintainer
            ^[ ]+--\s+   # leading double hyphen
            [^\>]+>      # maintainer name and then <email_address>
            )            # close fifth capture
        }xsm;

        return qr{ $pkg $version $release $urgency $maint }xsm;
    }

    # _configure_ac_version_regex()    {{{1
    #
    # does:   provide regex for finding version in the
    #         tarball/autotools/configure.ac file
    #
    # params: nil
    # prints: nil
    # return: scalar regex
    method _configure_ac_version_regex () {

        # building blocks
        my $any = qr/.*?/xsm;
        my $arg = qr{
            \[.*?\]    # argument, enclosed in square brackets
            $any  # interargument characters, may include newline
        }xsm;

        # in $any can't enclose '.' in a character class ('[.]')
        # because then it wouldn't match newlines
        # (see 'Metacharacters' section in 'perlre' manpage)
        # so need to disable related Perl::Critic warnings

        # first capture: all of file before version

        ## no critic (ProhibitEscapedMetacharacters)
        my $pre_version = qr{
            (?<pre>    # first capture is all of file before version
            \A$any     # capture from beginning of file
            AC_INIT    # version is an argument to the AC_INIT macro
            $any       # chars between macro name and opening '('
            \(         # open arguments for AC_INIT macro
            $arg       # first AC_INIT argument: description
            \[         # opening brace of second argument
            )          # close first capture
        }xsm;
        ## use critic

        # second capture: version

        my $version = qr{
            (?<version>    # second capture is version
            $any           # second AC_INIT argument: version
            )              # close second capture
        }xsm;

        # third capture: all of file after version

        ## no critic (ProhibitEscapedMetacharacters)
        my $post_version = qr{
            (?<post>     # third capture is all of file after version no.
            \]           # closing brace of second argument
            $any         # interargument chars, may include newline
            $arg         # third AC_INIT argument: maintainer email
            $arg         # fourth AC_INIT argument: distribution name
            \)           # close AC_INIT macro
            $any\z       # include remainder of file
            )
        }xsm;
        ## use critic

        return qr{ $pre_version $version $post_version }xsm;
    }

    # _create_template()    {{{1
    #
    # does:   create empty project template
    #
    # params: nil
    # prints: feedback
    # return: n/a, dies on failure
    method _create_template () {

        # project root directory must be empty
        my $root     = $self->_root_dir->canonpath;
        my @contents = $self->_root_dir->children;
        die "Project root directory is not empty: $root\n" if @contents;

        # create project directories
        my @dirs = $self->_project_dirs;
        if ( not $self->dir_make(@dirs) ) { die "Aborting...\n"; }

        # create scripts
        $self->_write_tar_prep;
        $self->_write_deb_prep;
        $self->_write_wrapper;

        say "Created template in: $root" or croak;
        return;
    }

    # _debianise()    {{{1
    #
    # does:   debianise distribution source
    #
    # params: nil
    # prints: feedback on error
    # return: n/a, dies on failure
    method _debianise () {

        # note that Perl::Critic does not see that $CWD is a package variable

        # extract tarball    {{{2
        my $deb_source = $self->_deb_source;
        ## no critic (Variables::ProhibitLocalVars)
        local $CWD = $deb_source->canonpath;
        ## use critic
        my $tarball;
        {
            my @children   = $deb_source->children;
            my $kids_count = scalar @children;
            croak "Expected 1 file in debianise/source, got $kids_count"
                if $kids_count != 1;
            $tarball = $children[0];
            say 'Extracting source from distribution archive' or croak;
            my $extract   = Archive::Tar->new( $tarball->canonpath );
            my $extracted = $extract->extract;
            croak "Unable to extract source: $ERRNO" if not $extracted;
        }
        my $source_base;
        {
            my @dir_children = $self->dir_list( $deb_source->canonpath );
            my $kids_count   = scalar @dir_children;
            croak "Expected 1 directory, got $kids_count" if $kids_count != 1;
            $source_base = Path::Tiny::path( $dir_children[0] )->absolute;
        }

        # initial debianisation with dh_make    {{{2
        say q{Initial debianisation using 'dh_make':} or croak;
        ## no critic (Variables::ProhibitLocalVars)
        local $CWD = $source_base->canonpath;
        ## use critic
        {
            my @cmd = (
                'dh_make', '--single',
                '--email', $self->_maint_email,
                '--file',  $tarball->canonpath,
            );
            my $err = 'dh_make failed';
            $self->_run_cmd( $err, @cmd );
        }

        # copy customised files to debian subdirectory    {{{2
        say 'Copying customised files to debian subdirectory' or croak;
        {
            # Path::Tiny::children() requires qr// even for fixed string match
            ## no critic (RegularExpressions::ProhibitFixedStringMatches)
            my @children = $source_base->children(qr/\Adebian\z/xsm);
            ## use critic
            my $kids_count = scalar @children;
            croak "Expected 1 'debian' child, got $kids_count"
                if $kids_count != 1;
            my $debian = $children[0];
            croak q{'debian' is not a directory} if not $debian->is_dir;
            $self->_dir_clean($debian);
            my $custom = $self->_deb_debian;
            File::Copy::Recursive::dircopy( $custom->canonpath,
                $debian->canonpath )
                or die "Unable to custom debian files: $ERRNO\n";
        }

        # run project-specific changes to project source    {{{2
        my $deb_prep = $self->_deb_prep;
        if ( $deb_prep->is_file ) {
            say q{Located a 'deb_dir_prepare' script} or croak;
            say 'Running it now...'                   or croak;
            {
                my @cmd = ( $deb_prep->canonpath );
                my $err = 'Script failed';
                $self->_run_cmd( $err, @cmd );
            }
        }

        # build package    {{{2
        say q{Build package ['dpkg-buildpackage -rfakeroot -us -uc']:}
            or croak;
        {
            my @cmd = qw(dpkg-buildpackage -rfakeroot -us -uc);
            my $err = 'Package build failed';
            $self->_run_cmd( $err, @cmd );
        }

        # check for package file    {{{2
        {
            my @children   = $deb_source->children(qr/[.]deb\z/xsm);
            my $kids_count = scalar @children;
            croak "Expected 1 package file, got $kids_count"
                if $kids_count != 1;
            my $pkg = $children[0];
            croak "$pkg is not a file" if not $pkg->is_file;
            $self->_deb_pkg($pkg);
            say 'Debian package build is complete' or croak;
        }    # }}}2

        return;
    }

    # _dir_clean($dir)    {{{1
    #
    # does:   remove all contents of directory
    #
    # params: $dir - dirpath to check [Path::Tiny object or string, required]
    # prints: feedback on error
    # return: n/a, dies on failure
    method _dir_clean ($dir_param) {

        # check directory param    {{{2
        my $dir;
        my $dir_reftype  = Scalar::Util::reftype $dir_param;
        my $dir_obj_type = Scalar::Util::blessed $dir_param;
        if ( defined $dir_reftype ) {

            # is a reference
            if ( defined $dir_obj_type ) {

                # is an object
                if ( $dir_obj_type eq 'Path::Tiny' ) { $dir = $dir_param; }
                else { confess "Invalid directory: is $dir_obj_type object"; }
            }
            else { confess "Invalid directory: is $dir_reftype"; }
        }
        else {
            # scalar, presumed to be string file path
            $dir = Path::Tiny::path($dir_param)->absolute;
        }
        if ( not $dir ) { confess 'Unable to determine directory path'; }

        # delete directory contents    {{{2
        my @children  = map { $_->canonpath } $dir->children;
        my $to_delete = scalar @children;
        my $deleted   = File::Path::remove_tree(@children);
        if ( $deleted < $to_delete ) {
            croak "Tried to delete $to_delete items, deleted $deleted";
        }    # }}}2

        return;
    }

    # _escape_fname_chars_in_conf()    {{{1
    #
    # does:   backslash-escape filenames in 'tarball/build/configure' file
    #
    # params: nil
    # prints: feedback on error
    # return: n/a, dies on failure
    # note:   only character currently escaped in ampersand ('&')
    method _escape_fname_chars_in_conf () {

        # characters to escape    {{{2
        my @chars = qw(&);

        # filenames to escape    {{{2
        my $tar_build = $self->_tar_build;
        my @fps       = File::Find::Rule->file()->in( $tar_build->canonpath );
        my @fnames;
        {
            # - strip directory path
            my $sep          = File::Spec->catfile( q{}, q{} );
            my $base_dirpath = $tar_build->canonpath . $sep;
            my @fnames_in    = map {s/\A$base_dirpath//xsmr} @fps;

            # - strip '.in' suffix
            push @fnames, map {s/[.]in\z//xsmr} @fnames_in;
        }

        # get content of configure file    {{{2
        my $conf    = $self->_tar_conf;
        my $content = $conf->slurp_utf8;

        # escape filenames in configure file content    {{{2
        for my $char (@chars) {
            my $escaped_char = q{\\} . $char;
            for my $fname (@fnames) {
                my $escaped_fname = $fname =~ s/$char/$escaped_char/xsmgr;
                $content =~ s/$fname/$escaped_fname/xsmg;
            }
        }

        # write edited content back to configure file    {{{2
        my @new_content = split /\n/xsm, $content;
        $self->_write_file( [@new_content], $conf );    # }}}2

        return;
    }

    # _install_package()    {{{1
    #
    # does:   install debian package
    #
    # params: nil
    # prints: feedback
    # return: n/a, dies on failure
    method _install_package () {

        my $pkg_fp  = $self->_deb_pkg->canonpath;
        my $divider = $self->_divider;

        # first, try 'sudo dpkg'
        say q{Installing package using 'sudo dpkg':} or croak;
        my @cmd     = ( 'sudo', 'dpkg', '-i', $pkg_fp );
        my $success = $TRUE;
        say $divider or croak;
        if ( system @cmd ) { $success = $FALSE; }
        say $divider or croak;
        if ($success) {
            say 'Install complete' or croak;
            return;
        }

        # second, try 'su -c dpkg'
        say q{Okay, that failed - let's try as superuser} or croak;
        say 'Enter root password'                         or croak;
        @cmd     = ( 'su', '-c', "dpkg -i $pkg_fp" );
        $success = $TRUE;
        say $divider or croak;
        if ( system @cmd ) { $success = $FALSE; }
        say $divider or croak;
        if   ($success) { say 'Install complete' or croak; }
        else            { warn "Install failed\n"; }

        return;
    }

    # _run_cmd($err, @cmd)    {{{1
    #
    # does:   run system command and die on failure
    #
    # params: $err - error message [scalar string, required, can be undef]
    #         @cmd - command and arguments [list, required]
    # prints: feedback
    # return: n/a, dies on failure
    method _run_cmd ( $err, @cmd ) {

        if ( not @cmd ) { croak 'No command provided'; }
        my $divider = $self->_divider;
        say $divider or croak;
        if ( system @cmd ) {

            say $divider or croak;
            my $cmd_str = join q{ }, @cmd;
            if ($err) { warn "$err\n"; }
            warn "Failed command: $cmd_str\n";

            # perlcritic mistakenly complains about ${^CHILD_ERROR_NATIVE}
            # being a "magic punctuation variable" but it is actually the
            # long name from the English module, so perlcritic is wrong
            ## no critic (ProhibitPunctuationVars)
            my $err = ${^CHILD_ERROR_NATIVE};
            ## use critic

            # decode the exit status with POSIX module functions
            if ( POSIX::WIFEXITED($err) ) {
                warn '- exited with status ', POSIX::WEXITSTATUS($err), "\n";
            }
            my $exit_status = 1;
            if ( POSIX::WIFSIGNALED($err) ) {
                warn '- killed by signal ', POSIX::WTERMSIG($err), "\n";
                $exit_status = POSIX::WTERMSIG($err);
            }

            warn "Aborting...\n";
            exit $exit_status;
        }
        say $divider or croak;

        return;
    }

    # _set_attributes()    {{{1
    #
    # does:   set attributes
    # params: nil
    # prints: feedback on error
    # return: n/a, dies on failure
    method _set_attributes () {

        # set project root directory    {{{2
        my $root_dir = $self->_attr_root;
        $self->_root_dir($root_dir);

        # set maintainer name    {{{2
        my $maint_name = $self->_attr_string( $self->maint_name );
        die "No maintainer name provided\n" if not $maint_name;
        $self->_maint_name($maint_name);

        # set maintainer email    {{{2
        my $maint_email = $self->_attr_string( $self->maint_email );
        die "No maintainer email provided\n" if not $maint_email;
        die "Invalid maintainer email address: $maint_email\n"
            if not Email::Valid->address($maint_email);
        $self->_maint_email($maint_email);

        # set package name    {{{2
        my $pkg_name = $self->_attr_string( $self->pkg_name );
        die "No package name provided\n" if not $pkg_name;
        $self->_pkg_name($pkg_name);

        # set tarball archive directory path    {{{2
        my $tar_archive = $self->_attr_dir( 'tarball', 'archive' );
        if ( not $self->template ) {
            die "Missing $tar_archive, perhaps '-t' is missing?\n"
                if not $tar_archive->is_dir;
        }
        $self->_tar_archive($tar_archive);

        # set tarball autotools directory path    {{{2
        my $tar_auto = $self->_attr_dir( 'tarball', 'autotools' );
        if ( not $self->template ) {
            die "Missing $tar_auto, perhaps '-t' is missing?\n"
                if not $tar_auto->is_dir;
        }
        $self->_tar_auto($tar_auto);

        # set tarball build directory path    {{{2
        my $tar_build = $self->_attr_dir( 'tarball', 'build' );
        if ( not $self->template ) {
            die "Missing $tar_build, perhaps '-t' is missing?\n"
                if not $tar_build->is_dir;
        }
        $self->_tar_build($tar_build);

        # set tarball source directory path    {{{2
        my $tar_source = $self->_attr_dir( 'tarball', 'source' );
        if ( not $self->template ) {
            die "Missing $tar_source, perhaps '-t' is missing?\n"
                if not $tar_source->is_dir;
        }
        $self->_tar_source($tar_source);

        # set debianise debian files directory path    {{{2
        my $deb_debian = $self->_attr_dir( 'debianise', 'debian-files' );
        if ( not $self->template ) {
            die "Missing $deb_debian, perhaps '-t' is missing?\n"
                if not $deb_debian->is_dir;
        }
        $self->_deb_debian($deb_debian);

        # set debianise scripts directory path    {{{2
        my $deb_scripts = $self->_attr_dir( 'debianise', 'scripts' );
        if ( not $self->template ) {
            die "Missing $deb_scripts, perhaps '-t' is missing?\n"
                if not $deb_scripts->is_dir;
        }
        $self->_deb_scripts($deb_scripts);

        # set debianise source directory path    {{{2
        my $deb_source = $self->_attr_dir( 'debianise', 'source' );
        if ( not $self->template ) {
            die "Missing $deb_source, perhaps '-t' is missing?\n"
                if not $deb_source->is_dir;
        }
        $self->_deb_source($deb_source);

        # set list of project directories    {{{2
        my @project_dirs = (
            $deb_debian,  $deb_scripts, $deb_source, $tar_build,
            $tar_archive, $tar_auto,    $tar_source,
        );
        $self->_add_project_dirs(@project_dirs);

        # set file path to tarball directory preparation script    {{{2
        my $tar_prep
            = $self->_attr_fp( 'debianise', 'scripts', 'tar-dir-prepare' );
        if ( not $self->template ) {
            if ( not $tar_prep->is_file ) {
                say "Note: there is no $tar_prep file" or croak;
            }
        }
        $self->_tar_prep($tar_prep);

        # set file path to debianise directory preparation script    {{{2
        my $deb_prep
            = $self->_attr_fp( 'debianise', 'scripts', 'deb-dir-prepare' );
        if ( not $self->template ) {
            if ( not $deb_prep->is_file ) {
                say "Note: there is no $deb_prep file" or croak;
            }
        }
        $self->_deb_prep($deb_prep);

        # set file path to wrapper for this script    {{{2
        my $wrapper = $self->_attr_fp( 'debianise', 'scripts', 'build-deb' );
        if ( not $self->template ) {
            die "Missing $wrapper, perhaps '-t' is missing?\n"
                if not $wrapper->is_file;
        }
        $self->_wrapper($wrapper);

        # set file path to configure.ac file    {{{2
        my $tar_auto_conf_ac
            = $self->_attr_fp( 'tarball', 'autotools', 'configure.ac' );
        if ( not $self->template ) {
            die "Missing $tar_auto_conf_ac, perhaps '-t' is missing?\n"
                if not $tar_auto_conf_ac->is_file;
        }
        $self->_tar_auto_conf_ac($tar_auto_conf_ac);

        # set file path to changelog file    {{{2
        my $deb_debian_changelog
            = $self->_attr_fp( 'debianise', 'debian-files', 'changelog' );
        if ( not $self->template ) {
            die "Missing $deb_debian_changelog, perhaps '-t' is missing?\n"
                if not $deb_debian_changelog->is_file;
        }
        $self->_deb_debian_changelog($deb_debian_changelog);

        # set file path to configure file    {{{2
        my $tar_conf = $self->_attr_fp( 'tarball', 'build', 'configure' );
        $self->_tar_conf($tar_conf);

        # set regex and file parts for configure.ac file    {{{2
        {
            my $re = $self->_configure_ac_version_regex;
            $self->_tar_auto_conf_ac_regex($re);
            my $data = $tar_auto_conf_ac->slurp_utf8;
            if ( $data =~ $re ) {
                $self->_set_conf_ac_part( pre => "$LAST_PAREN_MATCH{'pre'}" );
                $self->_set_conf_ac_part(
                    version => "$LAST_PAREN_MATCH{'version'}" );
                $self->_set_conf_ac_part(
                    post => "$LAST_PAREN_MATCH{'post'}" );
            }
            else {
                die "Error: Unable to extract version from configure.ac\n";
            }
        }

        # set regex and file parts for changelog file    {{{2
        {
            my $re = $self->_changelog_version_regex;
            $self->_deb_debian_changelog_regex($re);
            my $data = $deb_debian_changelog->slurp_utf8;
            if ( $data =~ $re ) {
                $self->_set_changelog_part(
                    pkg => "$LAST_PAREN_MATCH{'pkg'}" );
                $self->_set_changelog_part(
                    version => "$LAST_PAREN_MATCH{'version'}" );
                $self->_set_changelog_part(
                    release => "$LAST_PAREN_MATCH{'release'}" );
                $self->_set_changelog_part(
                    urgency => "$LAST_PAREN_MATCH{'urgency'}" );
                $self->_set_changelog_part(
                    maint => "$LAST_PAREN_MATCH{'maint'}" );
            }
            else {
                die "Error: Unable to extract version from changelog\n";
            }
        }

        # set divider    {{{2
        {
            my $width = $self->term_width;
            if ( $width < $TERM_MIN_WIDTH ) {
                croak "Terminal < $TERM_MIN_WIDTH chars($width)";
            }
            my $length  = $width - $TERM_GUTTER;
            my $divider = q{-} x $length;
            $self->_divider($divider);
        }    # }}}2

        return;
    }

    # _write_tar_prep()    {{{1
    #
    # does:   write tarball directory preparation script
    #
    # params: nil
    # prints: nil
    # return: n/a, dies on failure
    method _write_tar_prep () {

        # set vars
        my $file = File::Basename::fileparse( $self->_tar_prep->canonpath );
        my $pkg  = $self->_pkg_name;
        my $tar_build = $self->_tar_build->canonpath;
        my @c;

        # create content
        # - causes multiple Perl::Critic warnings that strings *may* require
        #   interpolation because includes uninterpolated variables and shell
        #   commands
        push @c,
            (
            q[#!/bin/sh],
            q[],
            qq[# File: $file],
            q[],
            qq[# Package: $pkg],
            q[],
            qq[# This script will be run by $Script just prior to],
            q[# building the source distribution in 'tarball/build'.],
            q[],
            q[# This script is run from the directory],
            qq[# '$tar_build'.],
            q[],
            q[#############################################################],
            q[],
            );

        # write file
        $self->_write_file( [@c], $self->_tar_prep, '0744' );

        return;
    }

    # _write_deb_prep()    {{{1
    #
    # does:   write debianise directory preparation script
    #
    # params: nil
    # prints: nil
    # return: n/a, dies on failure
    method _write_deb_prep () {

        # set vars
        my $file = File::Basename::fileparse( $self->_deb_prep->canonpath );
        my $pkg  = $self->_pkg_name;
        my $deb_source = $self->_deb_source->canonpath;
        my @c;

        # create content
        # - causes multiple Perl::Critic warnings that strings *may* require
        #   interpolation because includes uninterpolated variables and shell
        #   commands
        push @c,
            (
            q[#!/bin/sh],
            q[],
            qq[# File: $file],
            q[],
            qq[# Package: $pkg],
            q[],
            qq[# This script is run by $Script after copying],
            q[# customised debian control files to the debian package],
            q[# source and just prior to building the package.],
            q[],
            q[# This script is run from the directory],
            qq[# '$deb_source/<archive>'.],
            q[# where <archive> is the top-level directory in the source],
            q[# project tarzipped distribution built in 'tarball/build'.],
            q[],
            q[#############################################################],
            q[],
            );

        # write file
        $self->_write_file( [@c], $self->_deb_prep, '0744' );

        return;
    }

    # _write_wrapper()    {{{1
    #
    # does:   write wrapper script for this script
    #
    # params: nil
    # prints: nil
    # return: n/a, dies on failure
    method _write_wrapper () {

        # set vars
        my $file  = File::Basename::fileparse( $self->_wrapper->canonpath );
        my $root  = $self->_root_dir;
        my $pkg   = $self->_pkg_name;
        my $name  = $self->_maint_name;
        my $email = $self->_maint_email;
        my @c;

        # create content
        push @c,
            (
            q[#!/bin/sh],
            q[],
            qq[# File: $file  [wrapper for '$Script']],
            q[],
            q[],
            q[# PARAMETERS],
            q[],
            q[# root directory of project],
            qq[root="$root"],
            q[],
            q[# package name],
            qq[pkg="$pkg"],
            q[],
            q[# package maintainer's name],
            qq[name="$name"],
            q[],
            q[# package maintainer's email address],
            qq[email="$email"],
            q[],
            q[],
            q[# RUN SCRIPT],
            q[],
            qq[$Script -r "\$root" -p "\$pkg" -n "\$name" -e "\$email"],
            );

        # write file
        $self->_write_file( [@c], $self->_wrapper, '0744' );

        return;
    }

    # _write_file($content, $file, [$perm])    {{{1
    #
    # does:   write file
    #
    # params: $content - file content [array reference, required]
    #         $file    - file path to write to
    #                    [string or Path::Tiny object, required]
    #         $perm    - permissions for file [quoted octal string, optional,
    #                                          default=current umask]
    # prints: nil, except on failure
    # return: n/a, dies on file operation failure
    method _write_file ( $content, $file, $perm = undef ) {

        # set vars
        if ( not $content ) {
            confess 'No content provided';
        }
        if ( ref $content ne 'ARRAY' ) {
            confess 'Content not an array';
        }
        if ( not $file ) {
            confess 'No file provided';
        }
        my $dest;
        my $file_reftype  = Scalar::Util::reftype $file;
        my $file_obj_type = Scalar::Util::blessed $file;
        if ( defined $file_reftype ) {

            # is a reference
            if ( defined $file_obj_type ) {

                # is an object
                if ( $file_obj_type eq 'Path::Tiny' ) { $dest = $file; }
                else { confess "Invalid file: is $file_obj_type object"; }
            }
            else { confess "Invalid file: is $file_reftype"; }
        }
        else {
            # scalar, presumed to be string file path
            $dest = Path::Tiny::path($file)->absolute;
        }
        if ( not $dest ) {
            confess 'Unable to determine destination file path';
        }

        # write file
        my @lines = map {"$_\n"} @{$content};
        try { $dest->spew_utf8(@lines); }
        catch ($err) { confess "Unable to write to '$dest': $err"; }

        # set file permissions
        # - use of Feature::Compat::Try's try construct causes Perl::Critic to
        #   issue warning regarding use of postfix control "if"
        if ($perm) {    ## no critic (ProhibitPostfixControls)
            try {
                $dest->chmod($perm);
            }
            catch ($err) {
                confess "Unable to modify permissions of '$dest': $err";
            }
        }

        return;
    }

    # }}}1
}

my $p = Dn::BuildDeb->new_with_options->main;

1;

# POD    {{{1
__END__

=encoding utf8

=head1 NAME

dn-build-deb - generate deb package for project

=head1 USAGE

B<dn-build-deb> B<-r> I<root> B<-n> I<name> B<-e> I<email> B<-p> I<pkg>
[B<-t>] [B<-d>]

B<dn-build-deb -h>

=head1 REQUIRED ARGUMENTS

Nil.

=head1 REQUIRED OPTIONS

=over

=item B<-r>|B<--root_dir> I<val>

The root directory of the source project.

Scalar string. Required. No default.

=item B<-n>|B<--maint_name> I<val>

Name of the package maintainer.

Scalar string. Required. No default.

=item B<-e>|B<--maint_email> I<val>

Email address of the package maintainer.

Scalar string. Required. No default.

=item B<-p>|B<--pkg_name> I<val>

Package name.

Not used by this script but made available to sourced customisation files (see
L</Customising the build process>).

Scalar string. Required. No default.

=back

=head1 OPTIONS

=over

=item B<-t>|B<--template>

Create empty project template consisting of the required directories (see
L</Source Project>).

Also creates empty customisation files and a wrapper for this script.

Note the root directory must be empty if a project template is to be created in
it.

Boolean. Optional. Default: false.

=item B<-d>|B<--dist_build>

Skip building of the targzipped project distribution and copying it to the
F<debianise/source> directory (see L</Build Process>). Instead assume there is
a single such file in that directory.

This option is designed for use when building a previous version of a project
from an archived distribution targzip file. If reverting to an earlier version
of the project, make sure debian control files such as
F<debian-files/changelog> are consistent.

Boolean. Optional. Default: false.

=item B<-h>

Display help and exit.

=back

=head1 DESCRIPTION

=head2 Source Project

This script is intended to work with standard autotools-compliant projects. The following directory structure is required:
       
    <root>
     | 
     |-- debianise
     |   |
     |   |-- debian-files
     |   |
     |   |-- scripts
     |   |
     |   `-- source
     | 
     `-- tarball
         |
         |-- autotools
         |
         |-- build
         |
         |-- archive
         |
         `-- source

=over

=item debianise

The debian build files.

=item debian

Debian control files to be copied in to the debian project file tree when it is
created. Some common files copied include F<changelog>, F<control>,
F<copyright> and F<rules>.

=item scripts

Any scripts required by the build process.

Traditionally contains a script called F<build-deb> which invokes this
utility with the appropriate arguments.

Can also contain either or both of two customisation files that this script
will look for during the build process (see L</Customising the build process>).

=item source

The source project is copied here, suitably altered and then the debian package
is built. The final debian package will be created in this directory.

=item tarball

The source project files.

=item autotools

Files required by autotools.

These files are copied or symlinked to the F<build> directory.

Some common autotools files include F<ChangeLog>, F<Makefile.am> and
F<configure.ac>.

=item build

Where the distribution tarball is built.

This directory is emptied at the start of the debian build process. Autotools
files and source files are copied or symlinked from their respective
directories. Then the autotools are used to build the tarball.

=item archive

Each time a distribution tarball is built a copy is stored in this directory.
The idea is to keep an archive of all versions of the project.

=item source

Here the project source files are kept.

=back

=head2 Build Process

=head3 Default build process

In the default build process the following steps are followed:

=over

=item *

Build a targzipped project distribution in the F<tarball/build> directory with
the commands C<autoreconf>, C<./configure>, and C<make dist>.

=item *

Copy the newly-created tarball to the F<debianise/source> directory and extract
it in place.

=item *

Perform initial initial debianisation with the command C<< dh_make --single
--email <email> --file ../<targzip> >>.

where C<< <email> >> is the email address provided as an argument to this
script and C<< <targzip> >> is the project distribution file.

=item *

The default debian control files in the F<debian> subdirectory are deleted and
any customised debian control files in the F<debianise/debian-files> are copied
into the F<debian> subdirectory.

=item *

The final package is built with the command F<dpkg-buildpackage -rfakeroot -us
-uc>.

=back

=head3 Customising the build process

The default build process provides no opportunities for performing
project-specific actions on the initial project source or debian package source
aside from controlling what control files are present in a project's
F<debianise/debian-files> directory.

To enable this sort of customisation this script looks in the
F<debianise/scripts> directory for the files F<tar-dir-prepare> and
F<deb-dir-prepare>:

=over

=item *

F<tar-dir-prepare>: if this script is found and executable it will be executed
just before the C<autoreconf> command is executed. The script is executed in
the F<tarball/build> directory.

=item *

F<deb-dir-prepare>: if this script is found and executable it will be executed
immediately after any customised debian control files are copied into the
package source. The script is executed in the F<< debianise/source/<archive> >>
directory, where F<< <archive> >> is the top level directory of the extracted
tarball source distribution. The default version of this script performs the
following replacement on all debian control files: I<@pkg_name@> is replaced by
the package name (this is analagous to using F<configure.ac> to perform
substitutions on all source files).

=back

=head1 CONFIGURATION

There is no configuration of this script.

There are ways to customise the build process for a given project. See L</Customising the build process> for further details.

=head1 INCOMPATIBILITIES

There are no known incompatibilities.

=head1 DIAGNOSTICS

Report bugs to the project maintainer.

=head1 EXIT STATUS

If the script exits because a shell command failed, the exit status is that reported by POSIX::WTERMSIG or, if that is not available, 1.

If the script exits because of a C<croak>, C<confess> or C<die> command, the
exist status is that provided by the default command.

=head1 DEPENDENCIES

=head2 Perl modules

autodie, Archive::Tar, Carp, Const::Fast, Dn::Role::HasPath,
Dn::Role::HasUserInteraction, Dpkg::Version, Email::Date::Format, Email::Valid,
English, Feature::Compat::Try, File::Basename, File::Copy::Recursive,
File::Find::Rule, File::Path, File::Spec, File::chdir, FindBin,
Function::Parameters, Moo, MooX::HandlesVia, MooX::Options, namespace::clean,
Path::Tiny, Scalar::Util, strictures, Term::Clui, Term::ReadKey,
Types::Standard, version.

=head2 Executables

autoreconf, dh_make, dpkg, dpkg-buildpackage, make, su, sudo.

=head1 BUGS AND LIMITATIONS

Please report any bugs to the author.

=head1 AUTHOR

David Nebauer (david at nebauer dot org)

=head1 LICENSE AND COPYRIGHT

Copyright (c) 2021 David Nebauer (david at nebauer dot org)

This script is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.

=cut

# vim:foldmethod=marker:
