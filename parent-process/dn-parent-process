#!/usr/bin/perl

use Moo;    # {{{1
use strictures 2;
use 5.014_002;
use version; our $VERSION = qv('0.1');

# package Dn::Internal::Pair {{{1
{

  package Dn::Internal::Pair;

  use Moo;
  use strictures 2;
  use namespace::clean;
  use Const::Fast;
  use Text::Table;
  use Text::Wrap;
  use Types::Standard qw(Int Str);

  const my $TRUE  => 1;
  const my $FALSE => 0;

  has 'parent' => (
    is            => 'ro',
    isa           => Int,
    required      => $TRUE,
    documentation => 'Parent process id',
  );

  has 'child' => (
    is            => 'ro',
    isa           => Int,
    required      => $TRUE,
    documentation => 'Child process id',
  );

  has 'command' => (
    is            => 'ro',
    isa           => Str,
    required      => $TRUE,
    documentation => 'Child process command',
  );

}    # }}}1

{

  package Dn::Internal;    ## no critic (ProhibitMultiplePackages)

  use Moo;                 # {{{1
  use strictures 2;
  use MooX::HandlesVia;
  use namespace::clean -except => [ '_options_data', '_options_config', ];
  use Carp;
  use Dn::Common;
  use Dn::Internal::Pair;
  use English qw(-no_match_vars);
  use Function::Parameters;
  use Getopt::Long::Descriptive;
  use List::Util;
  use Const::Fast;
  use Types::Standard qw(Int);
  use autodie         qw(open close);
  use experimental 'switch';
  my $cp = Dn::Common->new();

  const my $TRUE  => 1;
  const my $FALSE => 0;    # }}}1

  # attributes

  # _pid {{{1
  has '_pid' => (
    is  => 'lazy',
    isa => Types::Standard::Int,
    doc => 'Child process id',     ## no critic (ProhibitDuplicateLiteral)
  );

  method _build__pid () {    ## no critic (ProhibitUnusedPrivateSubroutines)

    my @args = List::Util::uniq @ARGV;

    # no duplicates allowed
    if (scalar @ARGV > scalar @args) {
      die "Duplicate arguments not allowed\n";
    }

    # must have one argument only
    die "No argument provided\n"               if not @args;
    die "Too many arguments (need one only)\n" if scalar @args > 1;

    return $args[0];
  }

  # _data {{{1
  has '_data' => (
    is  => 'rw',
    isa => Types::Standard::ArrayRef [
      Types::Standard::InstanceOf ['Dn::Internal::Pair'],
    ],
    required    => $TRUE,
    default     => sub { [] },
    handles_via => 'Array',
    handles     => {
      _add_pair => 'push',
      _pairs    => 'elements',
    },
    documentation => 'Parent and child process details',

    # structure: [
    #   [ parent, child ],
    #   ... ,
    # ]
  );    # }}}1

  # methods

  #   main() {{{1
  #
  #   does:   main method
  #   params: nil
  #   prints: feedback
  #   return: result
  method main () {
    $self->_usage;    # print usage message if help requested
    $self->_get_process_data();
    $self->_print_data();
    return;
  }

  # _usage() {{{1
  #
  # does:   print usage message if requested
  # params: nil
  # prints: feedback
  # return: n/a, dies on failure
  method _usage () {

    # handle args
    my ($opt, $usage) =
        Getopt::Long::Descriptive::describe_options('%c %o <pid>', [],
      [ 'help|h', 'print usage message and exit', { shortcircuit => 1 }, ],
        );
    if ($opt->help) {
      print $usage->text or croak;
      exit;
    }

    return;
  }

  # _get_process_data() {{{1
  #
  # does:   get data on process parentage
  # params: nil
  # prints: nil
  # return: n/a, dies on failure
  method _get_process_data () {
    my $child = $self->_pid;
    while ($child != 0) {    # 0 is kernel, the final parent
      my $parent  = $cp->process_parent($child);
      my $command = $cp->pid_command($child);
      my $pair    = Dn::Internal::Pair->new(
        parent  => $parent,
        child   => $child,
        command => $command,
      );
      $self->_add_pair($pair);
      $child = $parent;
    }
    return;
  }

  # _print_data() {{{1
  #
  # does:   print process data in pretty table
  # params: nil
  # prints: nil
  # return: n/a, dies on failure
  method _print_data () {

    # create table and header
    my $sep = \' | ';
    my $t   = Text::Table->new("Parent\nPID", $sep, "Child\nPID", $sep,
      "Child\nprocess");

    # get width of last column
    # - localise package variable as per Perl Best Practice (pp. 77-79)
    const my $LAST_COL_MIN_WIDTH => 15;
    const my $OTHER_COLS_WIDTH   => 18;
    my $term_width     = $cp->term_size->width;
    my $last_col_width = $term_width - $OTHER_COLS_WIDTH;
    if ($last_col_width < $LAST_COL_MIN_WIDTH) {
      die "Terminal is too narrow for display\n";
    }
    local $Text::Wrap::columns = $Text::Wrap::columns;
    $Text::Wrap::columns = $last_col_width;

    # add data rows (wrapping long commands)
    for my $pair (reverse $self->_pairs) {
      my $parent  = $pair->parent;
      my $child   = $pair->child;
      my $command = Text::Wrap::wrap(q{}, q{}, $pair->command);
      $t->add($parent, $child, $command);
    }

    # print table
    my @output;
    my $rule = $t->rule(q{-}, q{+});    # horizontal divider
    push @output, $t->title();
    my @body = $t->body();
    foreach my $line (@body) {
      if ($line !~ /^ \s{7} [|] \s{7} [|]/xsm) {
        push @output, $rule;    # because NOT a wrapped continuation
      }
      push @output, $line;
    }
    foreach my $line (@output) { $line = q{ } . $line; }    # prepend space
    foreach my $line (@output) { print $line or croak; }

    return;
  }    # }}}1

}

my $p = Dn::Internal->new->main;

1;

# POD {{{1

## no critic (RequirePodSections)

__END__

=head1 NAME

dn-process-parent - find a process's parent recursively

=head1 USAGE

B<dn-process-parent> pid

B<dn-process-parent -h>

=head1 REQUIRED ARGUMENTS

=over

=item pid

Id of process to investigate. Must be a running PID. Required.

=back

=head1 OPTIONS

=over

=item B<-h>

Display help and exit.

=back

=head1 DESCRIPTION

Find a process's parent process recursively, and present information in a
tabular format.

=head1 DEPENDENCIES

=head2 Perl modules

autodie, Carp, Const::Fast, Dn::Common, English, experimental,
Function::Parameters, Getopt::Long::Descriptive, List::Util, Moo,
MooX::HandlesVia, namespace::clean, strictures, Text::Table, Text::Wrap,
Types::Dn, Types::Standard, version.

=head2 Executables

ps.

=head1 CONFIGURATION AND ENVIRONMENT

=head2 Operating systems

Underlying library L</"Dn::Common"> uses module L</"Proc::ProcessTable"> to
determine process parentage. At the time of writing this module worked on
darwin, nonstop-ux, Cygwin on Windows, linux, solaris, aix, hpux, freebsd,
irix, dec_osf, bsdi, netbsd, unixware 7.x, SunOS and openbsd.

Note that it does not work on Windows natively, but on Cygwin on Windows. See
the module's current README for updated information.

=head1 BUGS AND LIMITATIONS

Please report any bugs to the author.

=head1 AUTHOR

David Nebauer (david at nebauer dot org)

=head1 LICENSE AND COPYRIGHT

Copyright (c) 2017 David Nebauer (david at nebauer dot org)

This script is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

=cut

# vim:fdm=marker
